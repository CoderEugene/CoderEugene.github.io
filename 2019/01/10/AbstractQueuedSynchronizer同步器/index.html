<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>AQS同步器 - Mr·Zh</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta name="description" content="&amp;emsp;&amp;emsp;在 java.util.concurrent (JUC) 并发包中，如 ReentrantLock，Semaphore，CountDownLatch 等并发类的同步控制都是基于 AbstractQueuedSynchronizer (简称 AQS) 这个同步器抽象类来实现的。在这里较为深入的讨论同步器抽象类的实现原理与应用。 AQS简介AbstractQueuedSynch">
<meta name="keywords" content="Java,锁,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="AQS同步器">
<meta property="og:url" content="http://yoursite.com/2019/01/10/AbstractQueuedSynchronizer同步器/index.html">
<meta property="og:site_name" content="Mr·Zh">
<meta property="og:description" content="&amp;emsp;&amp;emsp;在 java.util.concurrent (JUC) 并发包中，如 ReentrantLock，Semaphore，CountDownLatch 等并发类的同步控制都是基于 AbstractQueuedSynchronizer (简称 AQS) 这个同步器抽象类来实现的。在这里较为深入的讨论同步器抽象类的实现原理与应用。 AQS简介AbstractQueuedSynch">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/aqs01.png">
<meta property="og:updated_time" content="2020-11-03T09:24:35.790Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AQS同步器">
<meta name="twitter:description" content="&amp;emsp;&amp;emsp;在 java.util.concurrent (JUC) 并发包中，如 ReentrantLock，Semaphore，CountDownLatch 等并发类的同步控制都是基于 AbstractQueuedSynchronizer (简称 AQS) 这个同步器抽象类来实现的。在这里较为深入的讨论同步器抽象类的实现原理与应用。 AQS简介AbstractQueuedSynch">
<meta name="twitter:image" content="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/aqs01.png">





<link rel="icon" href="/images/logo.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="AQS同步器" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/tags">Tags</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/CoderEugene">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-9-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- 增加图标 -->
                <div class="level-item has-text-grey" style="float: left;"> 
                    <i class="fas fa-calendar-alt"></i>&nbsp;&nbsp; <time class="level-item has-text-grey" datetime="2019-01-10T11:53:57.000Z">2019-01-10</time>
                </div>
                
                <div class="level-item">
                <i class="fas fa-folder-open"></i>&nbsp;&nbsp;
                <a class="has-link-grey -link" href="/categories/JUC/">JUC</a>
                </div>
                
                
                <!-- 增加计数和相关图标 -->
                
                    <dev class="level-item has-text-grey"><i class="fa fa-eye"></i>&nbsp;&nbsp;Visitors&nbsp;<span id="busuanzi_value_page_pv"></span></dev>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal" align="center">
            
                AQS同步器
            
        </h1>
        <div class="content">
            <p>&emsp;&emsp;在 java.util.concurrent (JUC) 并发包中，如 ReentrantLock，Semaphore，CountDownLatch 等并发类的同步控制都是基于 AbstractQueuedSynchronizer (简称 AQS) 这个同步器抽象类来实现的。在这里较为深入的讨论同步器抽象类的实现原理与应用。</p>
<h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><p>AbstractQueuedSynchronizer 内部维护着一个 FIFO 的 CLH 队列，队列中的每个 Node 代表着一个需要获取锁的线程</p>
<p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/aqs01.png" alt=""></p>
<blockquote>
<i class="far fa-bell"></i> 
<p>&emsp;&emsp;自旋锁：自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是立刻进入线程挂起或睡眠状态。</p>
<ul>
<li>CLH 锁（Craig, Landin, and Hagersten  locks）：基于链表的可扩展、高性能、公平的自旋锁，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋</li>
<li>MCS 锁：在当前结点自旋，但由前驱结点通知其结束自旋</li>
</ul>
</blockquote>
<p>AQS 采用的是一种变种的 CLH 队列锁：原始 CLH 是在前驱结点自旋，通过判断 pred.locked 来自旋，而 <strong>AQS 的 CLH 则是根据前驱结点的状态来控制阻塞，不会一直自旋。同时当前驱结点释放锁时会去唤醒该结点使其参与竞争锁。</strong> AQS 的结点的定义如下：</p>
<a id="more"></a>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 指向 Condition 队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Node 结点中分别有指向前驱，后继的结点，入队时的线程以及结点状态（Condition 队列本文不涉及）。结点状态会存在以下几种：</p>
<ul>
<li>CANCELLED：线程取消</li>
<li>SIGNAL：当前线程的后继线程被阻塞或者即将被阻塞，当前线程释放锁或者取消后需要唤醒后继线程</li>
<li>CONDITION：在等待 Condition ，也就是在 Condition 队列中</li>
<li>PROPAGATE：当头结点处于 PROPAGATE，需要唤醒后继线程，为了保证共享模式下唤醒机制正常</li>
<li>0：初始状态</li>
</ul>
<p>基于上述 Node 的定义，AQS 基本属性如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 队列的头结点</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 队列的尾节点</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 同步状态</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;</span><br></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>AbstractQueuedSynchronizer 的提供的接口主要有两种类型</p>
<h3 id="控制同步状态"><a href="#控制同步状态" class="headerlink" title="控制同步状态"></a>控制同步状态</h3><p>AbstractQueuedSynchronizer 并不实现同步接口，所有对同步状态的控制都交由子类同步组件控制。比如 tryAcquire 代表由子类控制当前线程是否能独占式获取同步状态成功</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean tryAcquire(int arg)</td>
<td>独占式获取同步状态</td>
</tr>
<tr>
<td>boolean tryRelease(int arg)</td>
<td>独占式释放同步状态</td>
</tr>
<tr>
<td>int tryAcquireShared(int arg)</td>
<td>共享式获取同步状态</td>
</tr>
<tr>
<td>boolean tryReleaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td>boolean isHeldExclusively()</td>
<td>检测当前线程是否获取独占锁</td>
</tr>
</tbody>
</table>
<p>而在多线程环境中对状态的操纵必须确保原子性，因此它还提供了对状态控制的三组 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int getState()</td>
<td>获取同步状态</td>
</tr>
<tr>
<td>void setState()</td>
<td>设置同步状态</td>
</tr>
<tr>
<td>boolean compareAndSetState(int expect, int update)</td>
<td>通过 CAS 设置同步状态</td>
</tr>
</tbody>
</table>
<p>通过这三组 API，子类可以线程安全的控制同步状态（同时子类需要确保实现是非阻塞的）</p>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>模板方法封装了获取同步状态成功或失败后的在队列中的一系列操作，子类可以直接调用</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void acquire(int arg)</td>
<td>独占式获取同步状态，该方法将会调用 tryAcquire 尝试获取同步状态。获取成功则返回，获取失败，线程进入同步队列等待。</td>
</tr>
<tr>
<td>void acquireInterruptibly(int arg)</td>
<td>响应中断版的 acquire</td>
</tr>
<tr>
<td>boolean tryAcquireNanos(int arg,long nanos)</td>
<td>超时 + 响应中断版的 acquire</td>
</tr>
<tr>
<td>void acquireShared(int arg)</td>
<td>共享式获取同步状态，同一时刻可能会有多个线程获得同步状态。比如读写锁的读锁就是就是调用这个方法获取同步状态的。</td>
</tr>
<tr>
<td>void acquireSharedInterruptibly(int arg)</td>
<td>响应中断版的 acquireShared</td>
</tr>
<tr>
<td>boolean tryAcquireSharedNanos(int arg,long nanos)</td>
<td>超时 + 响应中断版的 acquireShared</td>
</tr>
<tr>
<td>boolean release(int arg)</td>
<td>独占式释放同步状态</td>
</tr>
<tr>
<td>boolean releaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
</tbody>
</table>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAcquire 方法代表尝试获取一次互斥锁，需要子类根据需求去实现（比如 ReentrantLock 实现了公平锁和非公平锁），通过布尔变量来标志获取状态：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若获取失败，则通过 addWaiter 方法将当前线程添加至阻塞队列</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 将线程封装在Node节点中</span></span><br><span class="line">    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// CAS 尝试将该节点插在队列尾</span></span><br><span class="line">    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="hljs-keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 如果不成功则通过自旋的方式插到队尾，直到插入成功</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="hljs-keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="hljs-comment">// 设置头结点，初始情况下，头结点是一个空结点(这里不会直接返回，因此即使阻塞队列为空，当前节点仍然是插在空结点之后)</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        <span class="hljs-comment">// 插入该结点到队尾</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="hljs-keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入完成后，则会调用 acquireQueued() 方法对该结点进行有限次自旋获取锁，并在到达边界条件后阻塞</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="hljs-comment">// 如果该节点的前一节点为头节点，那么它将有资格参与竞争锁</span></span><br><span class="line">            <span class="hljs-comment">// 如果获取锁成功，则将当前结点设为头结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span></span><br><span class="line">                failed = <span class="hljs-keyword">false</span>;</span><br><span class="line">                <span class="hljs-keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="hljs-comment">// 判断线程需不需要阻塞，和 CLH 不同，线程并不总是参与竞争锁，而是仅当线程被唤醒时竞争锁</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="hljs-comment">// 如果前驱节点为 SIGNAL 状态，那么在释放锁时会唤醒后继结点</span></span><br><span class="line">    <span class="hljs-comment">// 因此这种情况当前结点会阻塞自己</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 如果前驱节点为 CANCELLED 状态，那么从后向前找到第一个非取消状态的节点</span></span><br><span class="line">    <span class="hljs-comment">// 并更新当前结点的前驱为该结点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="hljs-comment">// 如果前驱节点为 0 或 PROPAGATE，那么设置前驱结点的状态为 SIGNAL（可以说这一步才是标志会将每一个节点阻塞的一步）</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// LockSupport.park(this) 来挂起线程，然后就停在这里了，等待被唤醒</span></span><br><span class="line"><span class="hljs-comment">// 返回的时候会先判断是否由线程中断造成的，如果由线程中断造成，在这里会接下去置中断标记</span></span><br><span class="line"><span class="hljs-comment">// 而 lockInterruptibly 方法则是抛出异常</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span>  <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="hljs-keyword">this</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么总结下 acquire 方法的逻辑：</p>
<ol>
<li>尝试获取互斥锁，若获取成功则直接返回</li>
<li>若获取失败，则将当前线程添加到阻塞队列尾（CAS 操作插入，自旋直到插入成功为止）</li>
<li>自旋/阻塞获取锁<ol>
<li>尝试获取互斥锁（前驱结点必须为头结点时，当前结点才有资格竞争锁），若获取成功则将当前结点设为头结点后退出</li>
<li>若前驱结点为 SIGNAL 状态，则阻塞当前结点（唤醒后继续循环 <em>自旋/阻塞获取锁</em> ）</li>
<li>若前驱结点为 CANCELLED 状态，则更新前驱到非取消结点</li>
<li>若前驱结点为 0 或 PROPAGATE，则设置前驱结点状态为 SIGNAL 状态</li>
</ol>
</li>
</ol>
<h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// h == null 的情况就是阻塞队列为空（前面说过，第一个线程持有锁时不会放到头结点中）</span></span><br><span class="line">        <span class="hljs-comment">// h.waitStatus = 0，那么其后的结点必定没有阻塞（前面也说过，因为该值是由后继结点来赋值的，然后仅当该结点状态为阻塞状态，后继结点才会将自己阻塞，即 CLH 特性，根据前驱结点状态来控制自己）</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryRelease 方法代表尝试释放一次互斥锁，需要子类根据需求去实现，通过布尔变量来标志获取状态：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在释放锁成功后，会判断当前结点状态来唤醒后继结点，即当前结点状态为 SIGNAL 状态时会唤醒后继结点</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)</span><br><span class="line">    unparkSuccessor(h);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="hljs-keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-comment">// 设置头结点状态为 0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 从队尾往前找，找到 waitStatus &lt;= 0 的所有节点中排在最前面的(&gt; 0 代表节点取消阻塞)</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        s = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 唤醒该节点，也就是头结点的下一个不为取消阻塞状态的节点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么总结下 release 方法的逻辑：</p>
<ol>
<li>尝试释放一次互斥锁，若释放失败，则直接返回失败</li>
<li>释放成功后，唤醒一个后继结点</li>
</ol>
<h2 id="互斥锁案例"><a href="#互斥锁案例" class="headerlink" title="互斥锁案例"></a>互斥锁案例</h2><p>通过以上的理解，可以实现一个简单的互斥锁</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MutexLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sync</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            setState(<span class="hljs-number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))&#123;</span><br><span class="line"></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> release)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(getState() == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);</span><br><span class="line">            setState(<span class="hljs-number">0</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquireInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.release(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类 Sync 继承 AbstractQueuedSynchronizer，并重载 tryAcquire 和 tryRelease 方法</p>
<ul>
<li>tryAcquire 通过 CAS 尝试获取一次同步状态（0 -&gt; 1），若获取成功则设置当前持有锁的线程为自己</li>
<li>tryRelease 判断同步状态是否为 1，若是则重置同步状态为 0，且设置当前获取锁的线程为 null，否则抛出异常（互斥锁的释放不会有并发）</li>
</ul>
<p>我们可以写个简单的并发计数测试：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 计数</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">final</span> Mutex mutex = <span class="hljs-keyword">new</span> Mutex();</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        count = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++)&#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">                        mutex.lock();</span><br><span class="line"></span><br><span class="line">                        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;<span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                            mutex.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"assert "</span> + threadCnt * <span class="hljs-number">10000</span> + <span class="hljs-string">" = "</span> + count + <span class="hljs-string">" is true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常输出为：</p>
<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 100000 = 100000 is true</span><br></pre></td></tr></table></figure>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAcquireShared 方法尝试获取一次共享锁，需要子类根据需求去实现。但和互斥锁不同的是，它以整型作为状态标志，负数代表获取失败，非负数代表获取成功，0 代表成功但之后的竞争线程不会成功</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取共享锁失败时，会调用 doAcquireShared 将当前线程添加至阻塞队列并自旋获取共享锁</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 将当前线程添加至阻塞队列</span></span><br><span class="line">    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="hljs-comment">// 如果该节点的前一节点为头节点，那么它将有资格参与竞争锁</span></span><br><span class="line">            <span class="hljs-comment">// 如果获取锁成功，则将当前结点设为头结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-comment">// 和互斥锁不同的点，共享锁会在获取锁成功后唤醒后继结点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="hljs-keyword">false</span>;</span><br><span class="line">                    <span class="hljs-keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 判断线程需不需要阻塞</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的大体逻辑和互斥锁的自旋获取锁逻辑相同，但是它们之间有个很重要的不同点，即共享锁在获取锁成功后调用 setHeadAndPropagate 来唤醒后继结点</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="hljs-comment">// Record old head for check below</span></span><br><span class="line">    <span class="hljs-comment">// 设为头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 唤醒后继结点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="hljs-comment">// 如果头结点处于 SIGNAL 状态，唤醒后继结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 如果头结点处于 0 的状态，设置头结点状态为 PROPAGATE</span></span><br><span class="line">            <span class="hljs-comment">// 这是为了解决共享锁的并发唤醒后继结点导致极端情况下存在线程永远无法唤醒的情况</span></span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))</span><br><span class="line">	            <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span></span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在判断是否需要唤醒后继结点这步，它的判断逻辑是 propagate &gt; 0 || h.waitStatus &lt; 0：</p>
<ul>
<li>propagate &gt; 0 ：tryAcquireShared 方法的返回值，代表当前线程获取共享锁成功（按理说 propagate = 0 的情况也属于获取锁成功，为什么不加进去呢？这是因为当 propagate = 0 时代表当前已经没有共享资源了，所以唤醒也没有意义了）</li>
<li>h.waitStatus &lt; 0 ：头结点状态为 SIGNAL 或 PROPAGATE 时</li>
</ul>
<blockquote><p><i class="far fa-bell"></i> </p>
<p>&emsp;&emsp;在共享锁中会存在 PROPAGATE 状态：</p>
<ul>
<li><p>获取共享锁成功后，如果头结点状态为 0（unparkSuccessor 时会将头结点状态设为0），会将头结点状态设为 PROPAGATE</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="line">​    !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))</span><br><span class="line">​    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断后继结点是否需要唤醒时会判断头结点的状态 propagate &gt; 0 || h.waitStatus &lt; 0</p>
</li>
</ul>
<p>之所以需要这个状态是因为共享锁的 <em>唤醒后继结点</em>  操作是并发操作，同时 propagate = 0 的情况不会唤醒后继结点，因此在一些极端情况下会存在阻塞结点无法被唤醒的情况</p>
</blockquote>
<p>那么我们总结下获取共享锁的逻辑：</p>
<ol>
<li>尝试获取共享锁，若获取成功则直接返回</li>
<li>若获取失败，则将当前线程添加到阻塞队列尾（CAS 操作插入，自旋直到插入成功为止）</li>
<li>自旋/阻塞获取锁<ol>
<li>尝试获取共享锁（前驱结点必须为头结点时，当前结点才有资格竞争锁），若获取成功则尝试唤醒一个<strong>后继结点</strong>（唤醒的结点如果获取锁成功又会继续唤醒接下去的结点）</li>
<li>前驱结点为 SIGNAL 状态，则阻塞当前结点（唤醒后继续循环 <em>自旋/阻塞获取锁</em> ）</li>
<li>前驱结点为 CANCELLED 状态，则更新前驱到非取消结点</li>
<li>前驱结点为 0 或 PROPAGATE，则设置前驱结点状态为 SIGNAL 状态</li>
</ol>
</li>
</ol>
<blockquote>
<p>不知道大家注意到了没有，在获取共享锁时，若新线程直接通过 tryAcquireShared 获取锁成功，它是不会入 Node 结点的，那么它也就不会去传播式的唤醒 CLH 队列中的后继节点了，这和上面的结论是否存在矛盾呢？其实这是正常的，我们可以考虑正在和新线程争抢共享锁的结点（头结点的后继结点），如果它抢到了共享锁，那么它会去唤醒后继节点；如果连它都抢不到锁，那么唤醒后继节点已经没有必要了。这个时候只需要等某个持有共享锁的线程释放锁来唤醒就可以了</p>
</blockquote>
<h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryReleaseShared 方法代表尝试释放一次共享锁，需要子类根据需求去实现，通过布尔变量来标志获取状态：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放成功后会调用 doReleaseShared 尝试唤醒一个后继结点，上面已经解释了。</p>
<h2 id="共享锁案例"><a href="#共享锁案例" class="headerlink" title="共享锁案例"></a>共享锁案例</h2><p>基于以上分析，我们也可以实现一个同时允许 N 个线程进入的共享锁</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShareLock</span><span class="hljs-params">(Integer permit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync(permit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="hljs-keyword">int</span> permit)&#123;</span><br><span class="line"></span><br><span class="line">            setState(permit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">int</span> expect = getState();</span><br><span class="line">                <span class="hljs-keyword">int</span> update = expect - acquire;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span>(update &lt; <span class="hljs-number">0</span> || compareAndSetState(expect, update))&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">return</span> update;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> release)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">int</span> expect = getState();</span><br><span class="line">                <span class="hljs-keyword">int</span> update = expect + release;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span>(compareAndSetState(expect, update))&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquireShared(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquireShared(<span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.releaseShared(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来对共享锁进行简单的测试：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">final</span> ShareLock shareLock = <span class="hljs-keyword">new</span> ShareLock(<span class="hljs-number">2</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++)&#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    shareLock.lock();</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": is running"</span>);</span><br><span class="line"></span><br><span class="line">                        Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                        shareLock.unlock();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试程序创建了一个允许最多两个线程同时进入的共享锁。因此正常情况下，日志会成双打印。</p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><ul>
<li>thread.interrupt()：中断线程，将会设置该线程的中断状态位，即设置为 true（<strong>不会中断一个正在运行的线程，而是中断阻塞的线程</strong>）</li>
<li>thread.interrupted()：判断某个线程是否已被发送过中断请求，该方法调用后会将中断标示位清除，即重新设置为 false</li>
<li>Thread.currentThread().isInterrupted()：判断某个线程是否已被发送过中断请求，不会将中断标示位清除</li>
</ul>
<p>如果一个线程处于了阻塞状态（如线程调用了 thread.sleep、thread.join、thread.wait、1.5 中的 condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态），线程在检查中断标示时如果发现中断标示为 true，则会在这些阻塞方法调用处抛出 InterruptedException 异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为 false。而如果线程处于非阻塞状态，则需要通过判断 Thread.interrupted() 或者 Thread.isInterrupted() 来循环检测</p>
<blockquote><p><i class="far fa-bell"></i> </p>
<ol>
<li><p>Synchronized 在获锁的过程中是不能被中断的，意思是说如果产生了死锁，则不可能被中断</p>
</li>
<li><p>LockSupport 的 park 方法阻塞，能够响应中断，但是不会抛出 InterruptedException 异常</p>
</li>
<li><p>一个支持中断线程的程序的标准处理模式</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">​    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="hljs-comment">// do something</span></span><br><span class="line"></span><br><span class="line">​        <span class="hljs-comment">// 1. !Thread.currentThread().isInterrupted() 确保在非阻塞时能响应中断</span></span><br><span class="line">​        <span class="hljs-comment">// 2. try-catch 后对 InterruptedException 处理确保阻塞时对中断进行处理</span></span><br><span class="line">​        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="hljs-keyword">do</span>) &#123;</span><br><span class="line">​            <span class="hljs-keyword">do</span> more work </span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">​        <span class="hljs-comment">//线程在 wait 或 sleep 期间被中断了</span></span><br><span class="line">​    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">​        <span class="hljs-comment">//线程结束前做一些清理工作</span></span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p>在之前所说的 acquire，ascquireShared 方法均不支持中断操作</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="hljs-keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>它们在 LockSupport.park 响应中断后只是置一个中断标记，但是并不会处理，仍然自旋获取锁直到获取成功或阻塞。而 acquireInterruptibly，acquireSharedInterruptibly 方法支持中断操作</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure>
<p>它们会在 LockSupport.park 响应中断后抛出 InterruptedException 异常结束线程</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://segmentfault.com/a/1190000014721183" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></li>
<li><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a></li>
<li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></li>
</ul>

        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/Java/">Java</a>, <a class="has-link-grey -link" href="/tags/多线程/">多线程</a>, <a class="has-link-grey -link" href="/tags/锁/">锁</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2019/01/14/ReentrantLock/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">ReentrantLock</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2018/12/22/内存屏障/">
                <span class="level-item">内存屏障</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">Comments</h3>
        
<div id="comment-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script>
<script>
    var gitalk = new Gitalk({
        clientID: 'a6ee64392ee1dba6a516',
        clientSecret: '7638214b6ca106a17ff2301358bd4297d6e47773',
        id: '7309d774307e9359f0806cb5bd3094a1',
        repo: 'CoderEugene.github.io',
        owner: 'CoderEugene',
        admin: ["CoderEugene"]
    })
    gitalk.render('comment-container')
</script>

    </div>
</div>
</div>
                




<div class="column is-4-tablet is-3-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    <img class="image is-128x128 has-mb-6" src="/images/avatar.JPG" alt="Mr·Zh">
                    
                    <p class="is-size-4 is-block">
                        Mr·Zh
                    </p>
                    
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Hangzhou, China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Posts
                    </p>
                    <p class="title has-text-weight-normal">
                        15
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categories
                    </p>
                    <p class="title has-text-weight-normal">
                        7
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <p class="title has-text-weight-normal">
                        18
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/CoderEugene">
                Follow</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Github" href="https://github.com/CoderEugene">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Youtube" href="https://www.youtube.com/channel/UCw0q8SAGateu9wq6ERunCNw?view_as=subscriber">
                
                <i class="fab fa-youtube"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="RSS" href="/atom.xml">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
<div class="card widget" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Catalogue
            </h3>
            <ul class="menu-list"><li>
        <a class="is-flex" href="#AQS简介">
        <span class="has-mr-6">1</span>
        <span>AQS简介</span>
        </a></li><li>
        <a class="is-flex" href="#API">
        <span class="has-mr-6">2</span>
        <span>API</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#控制同步状态">
        <span class="has-mr-6">2.1</span>
        <span>控制同步状态</span>
        </a></li><li>
        <a class="is-flex" href="#模板方法">
        <span class="has-mr-6">2.2</span>
        <span>模板方法</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#互斥锁">
        <span class="has-mr-6">3</span>
        <span>互斥锁</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#acquire">
        <span class="has-mr-6">3.1</span>
        <span>acquire</span>
        </a></li><li>
        <a class="is-flex" href="#release">
        <span class="has-mr-6">3.2</span>
        <span>release</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#互斥锁案例">
        <span class="has-mr-6">4</span>
        <span>互斥锁案例</span>
        </a></li><li>
        <a class="is-flex" href="#共享锁">
        <span class="has-mr-6">5</span>
        <span>共享锁</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#acquireShared">
        <span class="has-mr-6">5.1</span>
        <span>acquireShared</span>
        </a></li><li>
        <a class="is-flex" href="#releaseShared">
        <span class="has-mr-6">5.2</span>
        <span>releaseShared</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#共享锁案例">
        <span class="has-mr-6">6</span>
        <span>共享锁案例</span>
        </a></li><li>
        <a class="is-flex" href="#中断">
        <span class="has-mr-6">7</span>
        <span>中断</span>
        </a></li><li>
        <a class="is-flex" href="#参考">
        <span class="has-mr-6">8</span>
        <span>参考</span>
        </a></li></ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categories
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/JUC/">
            <span class="level-start">
                <span class="level-item">JUC</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/JVM/">
            <span class="level-start">
                <span class="level-item">JVM</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Java基础/">
            <span class="level-start">
                <span class="level-item">Java基础</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Mysql/">
            <span class="level-start">
                <span class="level-item">Mysql</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Netty/">
            <span class="level-start">
                <span class="level-item">Netty</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Tomcat/">
            <span class="level-start">
                <span class="level-item">Tomcat</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/计算机通信/">
            <span class="level-start">
                <span class="level-item">计算机通信</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Tag Cloud
        </h3>
        <a href="/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JVM/" style="font-size: 12.5px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/NIO/" style="font-size: 12.5px;">NIO</a> <a href="/tags/Reactor/" style="font-size: 12.5px;">Reactor</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/UDP/" style="font-size: 10px;">UDP</a> <a href="/tags/volatile/" style="font-size: 10px;">volatile</a> <a href="/tags/内存屏障/" style="font-size: 10px;">内存屏障</a> <a href="/tags/可见性/" style="font-size: 10px;">可见性</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/故障排查/" style="font-size: 10px;">故障排查</a> <a href="/tags/最佳实践/" style="font-size: 15px;">最佳实践</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/锁/" style="font-size: 17.5px;">锁</a>
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/09/">
                <span class="level-start">
                    <span class="level-item">September 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/08/">
                <span class="level-start">
                    <span class="level-item">August 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/07/">
                <span class="level-start">
                    <span class="level-item">July 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/05/">
                <span class="level-start">
                    <span class="level-item">May 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">February 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/12/">
                <span class="level-start">
                    <span class="level-item">December 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/06/">
                <span class="level-start">
                    <span class="level-item">June 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">February 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/01/">
                <span class="level-start">
                    <span class="level-item">January 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/12/">
                <span class="level-start">
                    <span class="level-item">December 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="AQS同步器" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 Mr·Zh&nbsp;
                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
				&nbsp;<i class="far fa-eye"></i>&nbsp;PV&nbsp;&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;&nbsp;&nbsp;<i class="fa fa-user-md"></i>&nbsp;UV&nbsp;&nbsp;<span id="busuanzi_value_site_uv"></span>
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/CoderEugene">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>