<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Tomcat 线程模型详解 - Mr·Zh</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



    <meta name="description" content="Tomcat 作为最常见的 Servlet 容器，在 6.x 版本就支持了 NIO 模式的 Connector 和 Reactor 模式相比有什么特殊之处吗？首先来看下面的表格：     Java Nio Connector NIO Java Nio2 Connector NIO2 APR/native Connector APR     Classname Http11NioProtocol H">
<meta name="keywords" content="Reactor,NIO,Tomcat">
<meta property="og:type" content="article">
<meta property="og:title" content="Tomcat 线程模型详解">
<meta property="og:url" content="http://yoursite.com/2020/08/30/Tomcat-线程模型详解/index.html">
<meta property="og:site_name" content="Mr·Zh">
<meta property="og:description" content="Tomcat 作为最常见的 Servlet 容器，在 6.x 版本就支持了 NIO 模式的 Connector 和 Reactor 模式相比有什么特殊之处吗？首先来看下面的表格：     Java Nio Connector NIO Java Nio2 Connector NIO2 APR/native Connector APR     Classname Http11NioProtocol H">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/Tomcat线程模型.png">
<meta property="og:image" content="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/image-20200830112515693.png">
<meta property="og:updated_time" content="2020-08-30T04:38:24.452Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Tomcat 线程模型详解">
<meta name="twitter:description" content="Tomcat 作为最常见的 Servlet 容器，在 6.x 版本就支持了 NIO 模式的 Connector 和 Reactor 模式相比有什么特殊之处吗？首先来看下面的表格：     Java Nio Connector NIO Java Nio2 Connector NIO2 APR/native Connector APR     Classname Http11NioProtocol H">
<meta name="twitter:image" content="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/Tomcat线程模型.png">





<link rel="icon" href="/images/logo.png">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="Tomcat 线程模型详解" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/tags">Tags</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    
                    <a class="navbar-item" target="_blank" title="Download on GitHub" href="https://github.com/CoderEugene">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-9-desktop is-9-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- 增加图标 -->
                <div class="level-item has-text-grey" style="float: left;"> 
                    <i class="fas fa-calendar-alt"></i>&nbsp;&nbsp; <time class="level-item has-text-grey" datetime="2020-08-30T04:26:10.000Z">2020-08-30</time>
                </div>
                
                <div class="level-item">
                <i class="fas fa-folder-open"></i>&nbsp;&nbsp;
                <a class="has-link-grey -link" href="/categories/计算机通信/">计算机通信</a>
                </div>
                
                
                <!-- 增加计数和相关图标 -->
                
                    <dev class="level-item has-text-grey"><i class="fa fa-eye"></i>&nbsp;&nbsp;Visitors&nbsp;<span id="busuanzi_value_page_pv"></span></dev>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal" align="center">
            
                Tomcat 线程模型详解
            
        </h1>
        <div class="content">
            <p>Tomcat 作为最常见的 Servlet 容器，在 6.x 版本就支持了 NIO 模式的 Connector 和 Reactor 模式相比有什么特殊之处吗？首先来看下面的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center">Java Nio Connector NIO</th>
<th style="text-align:center">Java Nio2 Connector NIO2</th>
<th>APR/native Connector APR</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Classname</td>
<td style="text-align:center"><code>Http11NioProtocol</code></td>
<td style="text-align:center"><code>Http11Nio2Protocol</code></td>
<td><code>Http11AprProtocol</code></td>
</tr>
<tr>
<td style="text-align:left">Tomcat Version</td>
<td style="text-align:center">since 6.0.x</td>
<td style="text-align:center">since 8.0.x</td>
<td>since 5.5.x</td>
</tr>
<tr>
<td style="text-align:left">Support Polling</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td>YES</td>
</tr>
<tr>
<td style="text-align:left">Polling Size</td>
<td style="text-align:center"><code>maxConnections</code></td>
<td style="text-align:center"><code>maxConnections</code></td>
<td><code>maxConnections</code></td>
</tr>
<tr>
<td style="text-align:left">Read Request Headers</td>
<td style="text-align:center">Non Blocking</td>
<td style="text-align:center">Non Blocking</td>
<td>Non Blocking</td>
</tr>
<tr>
<td style="text-align:left">Read Request Body</td>
<td style="text-align:center">Blocking</td>
<td style="text-align:center">Blocking</td>
<td>Blocking</td>
</tr>
<tr>
<td style="text-align:left">Write Response Headers and Body</td>
<td style="text-align:center">Blocking</td>
<td style="text-align:center">Blocking</td>
<td>Blocking</td>
</tr>
<tr>
<td style="text-align:left">Wait for next Request</td>
<td style="text-align:center">Non Blocking</td>
<td style="text-align:center">Non Blocking</td>
<td>Non Blocking</td>
</tr>
<tr>
<td style="text-align:left">SSL Support</td>
<td style="text-align:center">Java SSL or OpenSSL</td>
<td style="text-align:center">Java SSL or OpenSSL</td>
<td>OpenSSL</td>
</tr>
<tr>
<td style="text-align:left">SSL Handshake</td>
<td style="text-align:center">Non blocking</td>
<td style="text-align:center">Non blocking</td>
<td>Blocking</td>
</tr>
<tr>
<td style="text-align:left">Max Connections</td>
<td style="text-align:center"><code>maxConnections</code></td>
<td style="text-align:center"><code>maxConnections</code></td>
<td><code>maxConnections</code></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>这是从 <a href="https://tomcat.apache.org/tomcat-9.0-doc/config/http.html#Connector_Comparison" target="_blank" rel="noopener">Apache Tomcat 9 Configuration Reference-Connector Comparison</a> 中得到的多种模式下的 Connector 的对比：</p>
<ul>
<li><p>NIO 就是我们熟悉的同步非阻塞 I/O 模型</p>
</li>
<li><p>NIO2 指的是 AIO，即异步 I/O 模型，其实 Netty 已经抛弃 AIO，至于原因根据 <a href="https://github.com/netty/netty/issues/2515" target="_blank" rel="noopener">ISSUE-NIO.2 support</a> 介绍主要还是 Linux 下技术不够成熟以及复杂度的考虑</p>
</li>
<li><p>ARP 实际上还是 NIO 模式，只不过它是基于 ARP（Apache Portable Runtime Libraries，由 C 写的 Apache 可移植运行时库）实现以提高性能。我们在启动 Tomcat 经常能看到 <em>The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path:</em> 提示就是指需要我们安装指定的环境以便正常启动 ARP 模式，当然我们现在常见使用的还是 NIO 模式，所以可以忽略该条提示</p>
</li>
</ul>
<p>我们主要关心的是 NIO 模式，而从表格中可以知道比较重要的点：</p>
<ul>
<li>Read Request Body/Write Response Headers and Body 是阻塞的</li>
<li>Read Request Headers/Wait for next Request 是非阻塞的</li>
</ul>
<p>既然使用 NIO 模式为什么还要阻塞的读写数据呢？因为 Tomcat 是 Servlet 容器，Read Request Body/Write Response Headers and Body 是由 ServletInputStream 和 ServletOutputStream 定义的，而在 Servlet3.1 之前的规范中 ServletInputStream 和 ServletOutputStream 是<strong>阻塞</strong>的。</p>
<h2 id="Tomcat-线程模型"><a href="#Tomcat-线程模型" class="headerlink" title="Tomcat 线程模型"></a>Tomcat 线程模型</h2><p>下图是 Tomcat 的整体线程模型：</p>
<p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/Tomcat线程模型.png" alt="Tomcat线程模型"></p>
<ul>
<li><p>Acceptor：<strong>单线程阻塞</strong>监听连接事件，和 Multi-Reactor 模型的 Main Reactor + Acceptor 的作用相似</p>
</li>
<li><p>Poller：Acceptor 接收到的连接事件将通过 PollEvent 事件传递到 Poller 线程池处理，本质上就是将该 Socket 后续的读写事件交由 Poller 线程中的 Selector 进行监听并分派。Poller 线程池的线程池数为 CPU * 2，和 Multi-Reactor 模型的 Sub Reactor 的作用类似</p>
<blockquote>
<p>在 Multi-Reactor 模型中，读写 I/O 也是在 Sub Reactor 中执行的，而在 Tomcat 中仅有 Http 请求头，请求行是在 Poller 中执行的</p>
</blockquote>
</li>
<li><p>Worker（Servlet）：Poller 在解析完 Http 请求行，请求头后会将请求交由 Worker 业务线程池进行处理，默认情况下会创建最大线程数为 200 的线程池。当用户通过 ServletInputStream.read/write 读取 Request Body 或写入时将会向 Block Poller 注册监听读写事件，和 Multi-Reactor 模型的 Handler 的作用类似</p>
</li>
<li><p>Block Poller：这是 Multi-Reactor 模型没有的角色，单线程的监听向其注册的 Socket 的读写事件，当事件发生后将交由 Worker 线程阻塞读写。它主要是结合 Worker 线程实现基于 NIO 的模拟阻塞读写，在后文会通过源码进行解析</p>
</li>
</ul>
<p>Servlet 规范导致 Tomcat 的线程模型和 Reactor 模式具有一定差距，在 Multi-Reactor 中，I/O 读写（Sub-Reactor 线程执行）和业务阻塞是分离的（Handler 所在业务线程执行），而 Tomcat 的 I/O 读写和业务阻塞均在同个 Worker 线程（也可以称为 Servlet 线程），这在业务阻塞时长比较大的情况下具有比较大的影响</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="阻塞读取Request-Body"><a href="#阻塞读取Request-Body" class="headerlink" title="阻塞读取Request Body"></a>阻塞读取Request Body</h3><p>Tomcat 的 Request Body 的读取是阻塞式的，调用 <code>ServletInputStream.read</code> 时会触发读取 Request Body，在 Tomcat 中的实现是 <code>CoyoteInputStream.read</code>。其内部会触发 ActiveFilter 链的调用</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.Http11InputBuffer#doRead</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doRead</span><span class="hljs-params">(ApplicationBufferHandler handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (lastActiveFilter == -<span class="hljs-number">1</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> inputStreamInputBuffer.doRead(handler);</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        <span class="hljs-keyword">return</span> activeFilters[lastActiveFilter].doRead(handler);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认处理非 chunked 请求的 Filter 是 IdentityInputFilter</p>
<blockquote>
<p>chunked 请求：HTTP1.1 长连接模式下，为了能正确复用 TCP 连接，需要通过 Content-Length 或 chunked 来标志响应体大小，但诸如网络文件等要想准确获取长度需要生成完成才能确认，所以通过 chunked 分块编码来提高性能</p>
</blockquote>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.filters.IdentityInputFilter#doRead</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doRead</span><span class="hljs-params">(ApplicationBufferHandler handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> result = -<span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (contentLength &gt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (remaining &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> nRead = buffer.doRead(handler);</span><br><span class="line">            <span class="hljs-keyword">if</span> (nRead &gt; remaining) &#123;</span><br><span class="line">                <span class="hljs-comment">// The chunk is longer than the number of bytes remaining</span></span><br><span class="line">                <span class="hljs-comment">// in the body; changing the chunk length to the number</span></span><br><span class="line">                <span class="hljs-comment">// of bytes remaining</span></span><br><span class="line">                handler.getByteBuffer().limit(handler.getByteBuffer().position() + (<span class="hljs-keyword">int</span>) remaining);</span><br><span class="line">                result = (<span class="hljs-keyword">int</span>) remaining;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                result = nRead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (nRead &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                remaining = remaining - nRead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// No more bytes left to be read : return -1 and clear the</span></span><br><span class="line">            <span class="hljs-comment">// buffer</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (handler.getByteBuffer() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                handler.getByteBuffer().position(<span class="hljs-number">0</span>).limit(<span class="hljs-number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result = -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里插一句和线程模型无关的知识点，即如何判断 Http 请求已读取完成？根据上面的逻辑可以看出，Tomcat 在读取每个 Http 请求的时候是根据 Header 中的 Content-Length 来读取字节的，每次读取一定字节时会更新 <code>remaining = remaining - nRead</code>，当 remaining = 0 时代表当前 Http 请求的 Request Body 已读取完成，因此当 CoyoteInputStream.read 未返回 -1 时均代表当前 Http 请求未接收完整</p>
</blockquote>
<p>其中 <code>buffer.doRead(handler)</code> 调用的实际上是 <code>Http11InputBuffer.SocketInputBuffer#doRead</code></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketInputBuffer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InputBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doRead</span><span class="hljs-params">(ApplicationBufferHandler handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (byteBuffer.position() &gt;= byteBuffer.limit()) &#123;</span><br><span class="line">            <span class="hljs-comment">// The application is reading the HTTP request body which is</span></span><br><span class="line">            <span class="hljs-comment">// always a blocking operation.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!fill(<span class="hljs-keyword">true</span>))</span><br><span class="line">                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> length = byteBuffer.remaining();</span><br><span class="line">        handler.setByteBuffer(byteBuffer.duplicate());</span><br><span class="line">        byteBuffer.position(byteBuffer.limit());</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意在调用 <code>fill</code> 方法时会传入 true，代表<strong>阻塞的获取 Http request body</strong>。去除无关的调用链，最终读取的关键位置在 <code>NioSelectorPool#read</code>，该方法通过 NIO 模拟阻塞</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.tomcat.util.net.NioBlockingSelector#read</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(ByteBuffer buf, NioChannel socket, <span class="hljs-keyword">long</span> readTimeout)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(sm.getString(<span class="hljs-string">"nioBlockingSelector.keyNotRegistered"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    KeyReference reference = keyReferenceStack.pop();</span><br><span class="line">    <span class="hljs-keyword">if</span> (reference == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        reference = <span class="hljs-keyword">new</span> KeyReference();</span><br><span class="line">    &#125;</span><br><span class="line">    NioSocketWrapper att = (NioSocketWrapper) key.attachment();</span><br><span class="line">    <span class="hljs-keyword">int</span> read = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> timedout = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> keycount = <span class="hljs-number">1</span>; <span class="hljs-comment">//assume we can read</span></span><br><span class="line">    <span class="hljs-keyword">long</span> time = System.currentTimeMillis(); <span class="hljs-comment">//start the timeout timer</span></span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span>(!timedout) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (keycount &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//only read if we were registered for a read</span></span><br><span class="line">                read = socket.read(buf);</span><br><span class="line">                <span class="hljs-keyword">if</span> (read != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> ( att.getReadLatch()==<span class="hljs-keyword">null</span> || att.getReadLatch().getCount()==<span class="hljs-number">0</span>) att.startReadLatch(<span class="hljs-number">1</span>);</span><br><span class="line">                poller.add(att,SelectionKey.OP_READ, reference);</span><br><span class="line">                <span class="hljs-keyword">if</span> (readTimeout &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    att.awaitReadLatch(Long.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    att.awaitReadLatch(readTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                <span class="hljs-comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> ( att.getReadLatch()!=<span class="hljs-keyword">null</span> &amp;&amp; att.getReadLatch().getCount()&gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">//we got interrupted, but we haven't received notification from the poller.</span></span><br><span class="line">                keycount = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">//latch countdown has happened</span></span><br><span class="line">                keycount = <span class="hljs-number">1</span>;</span><br><span class="line">                att.resetReadLatch();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (readTimeout &gt;= <span class="hljs-number">0</span> &amp;&amp; (keycount == <span class="hljs-number">0</span>))</span><br><span class="line">                timedout = (System.currentTimeMillis() - time) &gt;= readTimeout;</span><br><span class="line">        &#125; <span class="hljs-comment">//while</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (timedout)</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SocketTimeoutException();</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        poller.remove(att,SelectionKey.OP_READ);</span><br><span class="line">        <span class="hljs-keyword">if</span> (timedout &amp;&amp; reference.key!=<span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            poller.cancelKey(reference.key);</span><br><span class="line">        &#125;</span><br><span class="line">        reference.key = <span class="hljs-keyword">null</span>;</span><br><span class="line">        keyReferenceStack.push(reference);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码逻辑为：</p>
<ul>
<li><p>通过 <code>socket.read(buf)</code> 尝试进行读取一次，若读取成功则返回</p>
</li>
<li><p>若当前不可读，则通过 <code>poller.add(att,SelectionKey.OP_READ, reference)</code> 向 BlockPoller 注册 OP_READ 事件，然后通过 CountDownLatch 将当前 Worker 线程阻塞</p>
</li>
<li><p>由 BlockPoller 单线程监听 OP_READ 事件，在可读时唤醒 Worker 线程，由 Worker 线程进行读取</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.tomcat.util.net.NioBlockingSelector.BlockPoller#run</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = keyCount &gt; <span class="hljs-number">0</span> ? selector.selectedKeys().iterator() : <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line"><span class="hljs-comment">// any active event.</span></span><br><span class="line"><span class="hljs-keyword">while</span> (run &amp;&amp; iterator != <span class="hljs-keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey sk = iterator.next();</span><br><span class="line">    NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        sk.interestOps(sk.interestOps() &amp; (~sk.readyOps()));</span><br><span class="line">        <span class="hljs-keyword">if</span> ( sk.isReadable() ) &#123;</span><br><span class="line">            countDown(attachment.getReadLatch());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (sk.isWritable()) &#123;</span><br><span class="line">            countDown(attachment.getWriteLatch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="hljs-keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">        sk.cancel();</span><br><span class="line">        countDown(attachment.getReadLatch());</span><br><span class="line">        countDown(attachment.getWriteLatch());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="hljs-comment">//while</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>所以实际上 Request Body 的读取是由 Worker 线程阻塞读取完成的，至于 BlockPoller 其实类似 Poller，只不过它的 Selector 单独处理 Request Body 的读写事件</p>
<h3 id="阻塞写入数据"><a href="#阻塞写入数据" class="headerlink" title="阻塞写入数据"></a>阻塞写入数据</h3><p>Tomcat 的写入同样是阻塞式的，由 <code>ServletInputStream.write</code> 时会触发，在 Tomcat 的实现类为 <code>CoyoteOutputStream#write</code>，其内部同样有个 OutputFilter</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.Http11OutputBuffer#flush</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (lastActiveFilter == -<span class="hljs-number">1</span>) &#123;</span><br><span class="line">        outputStreamOutputBuffer.flush();</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        activeFilters[lastActiveFilter].flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下调用的是 <code>IdentityOutputFilter.write</code></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.filters.IdentityOutputFilter#doWrite</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(ByteBuffer chunk)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> result = -<span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (contentLength &gt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (remaining &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            result = chunk.remaining();</span><br><span class="line">            <span class="hljs-keyword">if</span> (result &gt; remaining) &#123;</span><br><span class="line">                <span class="hljs-comment">// The chunk is longer than the number of bytes remaining</span></span><br><span class="line">                <span class="hljs-comment">// in the body; changing the chunk length to the number</span></span><br><span class="line">                <span class="hljs-comment">// of bytes remaining</span></span><br><span class="line">                chunk.limit(chunk.position() + (<span class="hljs-keyword">int</span>) remaining);</span><br><span class="line">                result = (<span class="hljs-keyword">int</span>) remaining;</span><br><span class="line">                remaining = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                remaining = remaining - result;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.doWrite(chunk);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// No more bytes left to be written : return -1 and clear the</span></span><br><span class="line">            <span class="hljs-comment">// buffer</span></span><br><span class="line">            chunk.position(<span class="hljs-number">0</span>);</span><br><span class="line">            chunk.limit(<span class="hljs-number">0</span>);</span><br><span class="line">            result = -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// If no content length was set, just write the bytes</span></span><br><span class="line">        result = chunk.remaining();</span><br><span class="line">        buffer.doWrite(chunk);</span><br><span class="line">        result -= chunk.remaining();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里同样插一句和线程模型无关的知识点，即如何判断 Http 请求已写入完成？根据上面的逻辑可以看出，Tomcat 在读取每个 Http 请求的时候是根据 Response Header 中的 Content-Length 来读取字节的，每次读取一定字节时会更新 <code>remaining = remaining - nRead</code>，当 remaining = 0 时代表当前 Http 请求的 Reponse 已写入完成</p>
</blockquote>
<p>其中 <code>buffer.doWrite(chunk);</code> 调用的实际上是 <code>Http11OutputBuffer.SocketOutputBuffer#doWrite</code></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.Http11OutputBuffer.SocketOutputBuffer#doWrite</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(ByteBuffer chunk)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = chunk.remaining();</span><br><span class="line">        socketWrapper.write(isBlocking(), chunk);</span><br><span class="line">        len -= chunk.remaining();</span><br><span class="line">        byteCount += len;</span><br><span class="line">        <span class="hljs-keyword">return</span> len;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        response.action(ActionCode.CLOSE_NOW, ioe);</span><br><span class="line">        <span class="hljs-comment">// Re-throw</span></span><br><span class="line">        <span class="hljs-keyword">throw</span> ioe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>socketWrapper.write(isBlocking(), chunk);</code> 会使用<strong>阻塞的方式进行写入</strong>，最终写入的核心方法为 <code>NioSelectorPool#write</code> </p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.tomcat.util.net.NioBlockingSelector#write</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">write</span><span class="hljs-params">(ByteBuffer buf, NioChannel socket, <span class="hljs-keyword">long</span> writeTimeout)</span></span></span><br><span class="line"><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(sm.getString(<span class="hljs-string">"nioBlockingSelector.keyNotRegistered"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    KeyReference reference = keyReferenceStack.pop();</span><br><span class="line">    <span class="hljs-keyword">if</span> (reference == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        reference = <span class="hljs-keyword">new</span> KeyReference();</span><br><span class="line">    &#125;</span><br><span class="line">    NioSocketWrapper att = (NioSocketWrapper) key.attachment();</span><br><span class="line">    <span class="hljs-keyword">int</span> written = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> timedout = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> keycount = <span class="hljs-number">1</span>; <span class="hljs-comment">//assume we can write</span></span><br><span class="line">    <span class="hljs-keyword">long</span> time = System.currentTimeMillis(); <span class="hljs-comment">//start the timeout timer</span></span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> ( (!timedout) &amp;&amp; buf.hasRemaining()) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (keycount &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//only write if we were registered for a write</span></span><br><span class="line">                <span class="hljs-keyword">int</span> cnt = socket.write(buf); <span class="hljs-comment">//write the data</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (cnt == -<span class="hljs-number">1</span>)</span><br><span class="line">                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EOFException();</span><br><span class="line">                written += cnt;</span><br><span class="line">                <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    time = System.currentTimeMillis(); <span class="hljs-comment">//reset our timeout timer</span></span><br><span class="line">                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//we successfully wrote, try again without a selector</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> ( att.getWriteLatch()==<span class="hljs-keyword">null</span> || att.getWriteLatch().getCount()==<span class="hljs-number">0</span>) att.startWriteLatch(<span class="hljs-number">1</span>);</span><br><span class="line">                poller.add(att,SelectionKey.OP_WRITE,reference);</span><br><span class="line">                <span class="hljs-keyword">if</span> (writeTimeout &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    att.awaitWriteLatch(Long.MAX_VALUE,TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                <span class="hljs-comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> ( att.getWriteLatch()!=<span class="hljs-keyword">null</span> &amp;&amp; att.getWriteLatch().getCount()&gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">//we got interrupted, but we haven't received notification from the poller.</span></span><br><span class="line">                keycount = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">//latch countdown has happened</span></span><br><span class="line">                keycount = <span class="hljs-number">1</span>;</span><br><span class="line">                att.resetWriteLatch();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (writeTimeout &gt; <span class="hljs-number">0</span> &amp;&amp; (keycount == <span class="hljs-number">0</span>))</span><br><span class="line">                timedout = (System.currentTimeMillis() - time) &gt;= writeTimeout;</span><br><span class="line">        &#125; <span class="hljs-comment">//while</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (timedout)</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SocketTimeoutException();</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        poller.remove(att,SelectionKey.OP_WRITE);</span><br><span class="line">        <span class="hljs-keyword">if</span> (timedout &amp;&amp; reference.key!=<span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            poller.cancelKey(reference.key);</span><br><span class="line">        &#125;</span><br><span class="line">        reference.key = <span class="hljs-keyword">null</span>;</span><br><span class="line">        keyReferenceStack.push(reference);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码逻辑为：</p>
<ul>
<li><p>通过 <code>socket.write(buf)</code> 尝试进行写入一次，若读取成功则返回</p>
</li>
<li><p>若当前不可写，则通过 <code>poller.add(att,SelectionKey.OP_WRITE, reference)</code> 向 BlockPoller 注册 OP_WRITE 写入事件，然后通过 CountDownLatch 将当前 Worker 线程阻塞</p>
</li>
<li><p>由 BlockPoller 单线程监听 OP_WRITE 事件，在可读时唤醒 Worker 线程，由 Worker 线程进行读取</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.tomcat.util.net.NioBlockingSelector.BlockPoller#run</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = keyCount &gt; <span class="hljs-number">0</span> ? selector.selectedKeys().iterator() : <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line"><span class="hljs-comment">// any active event.</span></span><br><span class="line"><span class="hljs-keyword">while</span> (run &amp;&amp; iterator != <span class="hljs-keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey sk = iterator.next();</span><br><span class="line">    NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        sk.interestOps(sk.interestOps() &amp; (~sk.readyOps()));</span><br><span class="line">        <span class="hljs-keyword">if</span> ( sk.isReadable() ) &#123;</span><br><span class="line">            countDown(attachment.getReadLatch());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (sk.isWritable()) &#123;</span><br><span class="line">            countDown(attachment.getWriteLatch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="hljs-keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">        sk.cancel();</span><br><span class="line">        countDown(attachment.getReadLatch());</span><br><span class="line">        countDown(attachment.getWriteLatch());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="hljs-comment">//while</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>所以写数据和读取 Request Body 是非常相似的过程</p>
<h2 id="Servlet-异步接口"><a href="#Servlet-异步接口" class="headerlink" title="Servlet 异步接口"></a>Servlet 异步接口</h2><p>上面提到了 Tomcat 的 I/O 读写和业务阻塞均在同个 Servlet 线程，这在业务阻塞时间较长时很容易出现 Tomcat 的 Worker 线程池任务堆积（默认最大 200 个线程），无法支撑高并发场景。而在 Servlet3.1 开始支持了非阻塞 I/O，示例代码如下：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext actx = request.startAsync();</span><br><span class="line">actx.setTimeout(<span class="hljs-number">20000</span>);</span><br><span class="line">ServletInputStream in = request.getInputStream();</span><br><span class="line">in.setReadListener(<span class="hljs-keyword">new</span> MyReadListener(in,actx));</span><br></pre></td></tr></table></figure>
<p>通过异步模式可以将 I/O 读写和业务阻塞分离以达到复用 Worker 线程的作用。根据 <a href="http://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">Apache Tomcat Versions</a> 的介绍，在 Tomcat8.x 中已经支持了 Servlet3.1</p>
<p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/image-20200830112515693.png" alt="image-20200830112515693"></p>
<p>通过异步 Servlet 的支持，<strong>Tomcat 既解决了“一个连接一个请求”的问题，又解决高并发下业务阻塞会影响到读写线程的问题</strong>。当然对于如何使用异步 Servlet 以及 Tomcat 如何实现的感兴趣的话可以通过源码深入，本文不做过多介绍</p>
<h2 id="Tomcat-or-Netty"><a href="#Tomcat-or-Netty" class="headerlink" title="Tomcat or Netty"></a>Tomcat or Netty</h2><p>Tomcat 属于 Servlet 容器，Netty 属于异步网络编程框架，但它们都能作为 web 容器。上面介绍了 Tomcat 的线程模型，那么和 Netty 相比，谁更适合做 Web 服务器呢？如果针对于 Http 协议，那么 Tomcat 是毫无疑问的，它对于 Http 有着更完善的支持，比如 Chunk 分块传输。而 Netty 是基于传输层的，所以可以支持更多的应用层协议。</p>
<p>那么 Tomcat 和 Netty 的线程模型谁更有优势呢？其实没有本质上的区别，Tomcat 的 NIO 模式和 Netty 的 Multi-Reactor 模式都解决了“一个连接一个线程”的问题，且默认模式下业务处理和 I/O 读写都是在同个线程</p>
<ul>
<li>Netty 的默认模型并不是 Multi-Reactor 模型，所以业务处理默认情况下是和 Sub Reactor 处于同个线程</li>
<li>Tomcat 的读写均在 Worker 线程</li>
</ul>
<p>所以容器可优化业务阻塞时间较长场景的方案是：采用业务阻塞和 I/O 阻塞分离的方式实现（异步 Servlet 或 Multi-Reactor 模式）。但这已经是容器优化的极限了，它仍然无法解决大量业务线程阻塞时间过长时仍然会导致大量的线程产生的问题。因此要想进一步提高性能，不能只看容器，而需要将业务阻塞（比如缓存，数据库，RPC 等）操作变为非阻塞操作以提高线程复用程度</p>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>Http Request Body 是由用户在 Servlet 线程进行阻塞读取的，假如用户不主动读取上传的问题会出现什么情况呢，比如上传一个 100M 的文件 Tomcat 会自动接收吗？</p>
<ul>
<li><p>从 TCP 层面来看，如果数据一直不被接收，那么 Recv Buffer 会很快被占满，根据流量控制机制发送方将不会再发送数据，所以是不会自动接收所有数据的</p>
</li>
<li><p>从 Tomcat 层面来看，我们可以观察 <code>IdentityInputFilter#end</code> 方法</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.filters.IdentityInputFilter#end</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> maxSwallowSizeExceeded = (maxSwallowSize &gt; -<span class="hljs-number">1</span> &amp;&amp; remaining &gt; maxSwallowSize);</span><br><span class="line">    <span class="hljs-keyword">long</span> swallowed = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Consume extra bytes.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (remaining &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> nread = buffer.doRead(<span class="hljs-keyword">this</span>);</span><br><span class="line">        tempRead = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nread &gt; <span class="hljs-number">0</span> ) &#123;</span><br><span class="line">            swallowed += nread;</span><br><span class="line">            remaining = remaining - nread;</span><br><span class="line">            <span class="hljs-keyword">if</span> (maxSwallowSizeExceeded &amp;&amp; swallowed &gt; maxSwallowSize) &#123;</span><br><span class="line">                <span class="hljs-comment">// Note: We do not fail early so the client has a chance to</span></span><br><span class="line">                <span class="hljs-comment">// read the response before the connection is closed. See:</span></span><br><span class="line">                <span class="hljs-comment">// https://httpd.apache.org/docs/2.0/misc/fin_wait_2.html#appendix</span></span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(sm.getString(<span class="hljs-string">"inputFilter.maxSwallow"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// errors are handled higher up.</span></span><br><span class="line">            remaining = <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// If too many bytes were read, return the amount.</span></span><br><span class="line">    <span class="hljs-keyword">return</span> -remaining;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在请求结束后 Tomcat 会自动调用该方法，其代码如果缓存中存在剩余的字节，Tomcat 会自动读取，但是会有限制，默认只读取 2M(由 maxSwallowSize 确定)，如果请求体数据大于 2M，Tomcat 会抛出异常并关闭连接。</p>
<blockquote>
<p>The maximum number of request body bytes (excluding transfer encoding overhead) that will be swallowed by Tomcat for an aborted upload. An aborted upload is when Tomcat knows that the request body is going to be ignored but the client still sends it. If Tomcat does not swallow the body the client is unlikely to see the response. If not specified the default of 2097152 (2 megabytes) will be used. A value of less than zero indicates that no limit should be enforced.</p>
<p>​                                                       <a href="https://tomcat.apache.org/tomcat-8.0-doc/config/http.html" target="_blank" rel="noopener">The HTTP Connector</a></p>
</blockquote>
</li>
</ul>

        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/NIO/">NIO</a>, <a class="has-link-grey -link" href="/tags/Reactor/">Reactor</a>, <a class="has-link-grey -link" href="/tags/Tomcat/">Tomcat</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2020/08/23/Reactor模式/">
                <span class="level-item">Reactor模式</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">Comments</h3>
        
<div id="comment-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script>
<script>
    var gitalk = new Gitalk({
        clientID: 'a6ee64392ee1dba6a516',
        clientSecret: '7638214b6ca106a17ff2301358bd4297d6e47773',
        id: 'b6867b34790304f4d3b02755d96a4d27',
        repo: 'CoderEugene.github.io',
        owner: 'CoderEugene',
        admin: ["CoderEugene"]
    })
    gitalk.render('comment-container')
</script>

    </div>
</div>
</div>
                




<div class="column is-4-tablet is-3-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    <img class="image is-128x128 has-mb-6" src="/images/avatar.JPG" alt="Mr·Zh">
                    
                    <p class="is-size-4 is-block">
                        Mr·Zh
                    </p>
                    
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Hangzhou, China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Posts
                    </p>
                    <p class="title has-text-weight-normal">
                        14
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categories
                    </p>
                    <p class="title has-text-weight-normal">
                        5
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <p class="title has-text-weight-normal">
                        19
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/CoderEugene">
                Follow</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Github" href="https://github.com/CoderEugene">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Youtube" href="https://www.youtube.com/channel/UCw0q8SAGateu9wq6ERunCNw?view_as=subscriber">
                
                <i class="fab fa-youtube"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="RSS" href="/atom.xml">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
<div class="card widget" id="toc">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Catalogue
            </h3>
            <ul class="menu-list"><li>
        <a class="is-flex" href="#Tomcat-线程模型">
        <span class="has-mr-6">1</span>
        <span>Tomcat 线程模型</span>
        </a></li><li>
        <a class="is-flex" href="#源码解析">
        <span class="has-mr-6">2</span>
        <span>源码解析</span>
        </a><ul class="menu-list"><li>
        <a class="is-flex" href="#阻塞读取Request-Body">
        <span class="has-mr-6">2.1</span>
        <span>阻塞读取Request Body</span>
        </a></li><li>
        <a class="is-flex" href="#阻塞写入数据">
        <span class="has-mr-6">2.2</span>
        <span>阻塞写入数据</span>
        </a></li></ul></li><li>
        <a class="is-flex" href="#Servlet-异步接口">
        <span class="has-mr-6">3</span>
        <span>Servlet 异步接口</span>
        </a></li><li>
        <a class="is-flex" href="#Tomcat-or-Netty">
        <span class="has-mr-6">4</span>
        <span>Tomcat or Netty</span>
        </a></li><li>
        <a class="is-flex" href="#拓展">
        <span class="has-mr-6">5</span>
        <span>拓展</span>
        </a></li></ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categories
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/JUC/">
            <span class="level-start">
                <span class="level-item">JUC</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/JVM/">
            <span class="level-start">
                <span class="level-item">JVM</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Java基础/">
            <span class="level-start">
                <span class="level-item">Java基础</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Mysql/">
            <span class="level-start">
                <span class="level-item">Mysql</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/计算机通信/">
            <span class="level-start">
                <span class="level-item">计算机通信</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Tag Cloud
        </h3>
        <a href="/tags/DNS/" style="font-size: 10px;">DNS</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/JVM/" style="font-size: 12.5px;">JVM</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/Mysql/" style="font-size: 10px;">Mysql</a> <a href="/tags/NIO/" style="font-size: 12.5px;">NIO</a> <a href="/tags/Netty/" style="font-size: 10px;">Netty</a> <a href="/tags/Reactor/" style="font-size: 12.5px;">Reactor</a> <a href="/tags/Tomcat/" style="font-size: 10px;">Tomcat</a> <a href="/tags/UDP/" style="font-size: 10px;">UDP</a> <a href="/tags/volatile/" style="font-size: 10px;">volatile</a> <a href="/tags/内存屏障/" style="font-size: 10px;">内存屏障</a> <a href="/tags/可见性/" style="font-size: 10px;">可见性</a> <a href="/tags/多线程/" style="font-size: 15px;">多线程</a> <a href="/tags/操作系统/" style="font-size: 10px;">操作系统</a> <a href="/tags/故障排查/" style="font-size: 10px;">故障排查</a> <a href="/tags/最佳实践/" style="font-size: 15px;">最佳实践</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a> <a href="/tags/锁/" style="font-size: 17.5px;">锁</a>
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/08/">
                <span class="level-start">
                    <span class="level-item">August 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/07/">
                <span class="level-start">
                    <span class="level-item">July 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/05/">
                <span class="level-start">
                    <span class="level-item">May 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">February 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/12/">
                <span class="level-start">
                    <span class="level-item">December 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/06/">
                <span class="level-start">
                    <span class="level-item">June 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">February 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/01/">
                <span class="level-start">
                    <span class="level-item">January 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/12/">
                <span class="level-start">
                    <span class="level-item">December 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="Tomcat 线程模型详解" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 Mr·Zh&nbsp;
                <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
				&nbsp;<i class="far fa-eye"></i>&nbsp;PV&nbsp;&nbsp;<span id="busuanzi_value_site_pv"></span>&nbsp;&nbsp;&nbsp;<i class="fa fa-user-md"></i>&nbsp;UV&nbsp;&nbsp;<span id="busuanzi_value_site_uv"></span>
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" title="Download on GitHub" href="https://github.com/CoderEugene">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {matchFontHeight: false},
        SVG: {matchFontHeight: false},
        CommonHTML: {matchFontHeight: false}
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>