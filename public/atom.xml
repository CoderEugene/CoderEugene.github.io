<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr·Zh</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-13T15:38:26.916Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Mr·Zh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拆包粘包到底在解决什么问题</title>
    <link href="http://yoursite.com/2020/09/13/%E6%8B%86%E5%8C%85%E7%B2%98%E5%8C%85%E5%88%B0%E5%BA%95%E5%9C%A8%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/09/13/拆包粘包到底在解决什么问题/</id>
    <published>2020-09-13T14:56:07.000Z</published>
    <updated>2020-09-13T15:38:26.916Z</updated>
    
    <content type="html"><![CDATA[<p>”TCP 拆包粘包“网络上的争论挺大的，原因在于这一概念在 RFC 中并未提到过，(*￣︶￣)有点民科的赶脚。但实际上它是挺常见的一个问题，比较准确的描述应该是<strong>应用层分包</strong>问题。那么为什么提到这一概念总是会带上 TCP 而不是 UDP 呢？因为应用层分包问题<strong>本质是接收方在某个时刻接收到的数据不构成一条完整的消息</strong></p><ul><li><p>对于 UDP 来说，它并未在 IP 协议外作出额外的可靠性特性，所以无论发送的数据荷载是多少都会完整的交由 IP 层处理，而 IP 层虽然会根据 MTU 进行分包，但是接收方会确保在 IP 层重组完成才会交由 UDP 处理，否则会直接丢弃。所以基于 UDP 协议实现的应用层协议<strong>每次接收到的数据都是完整的消息</strong>，无需应用层做额外的分包和重组</p></li><li><p>对于 TCP 来说，它是无边界的字节流协议，为了解决可靠性的问题以及各种性能优化会<strong>导致接收方收到的数据不是完整的消息</strong>，比如：</p><ul><li>若数据荷载过小时，TCP 根据 Nagle 算法整合多个小数据包统一发送</li><li>若数据荷载过大时，TCP 会根据 MSS 大小对数据进行分段发送</li></ul><p>这也就是为啥”拆包粘包“总是碰瓷 TCP 的原因了</p></li></ul><a id="more"></a><p>对于 HTTP1.0 时代，每个 HTTP 请求对应一个 TCP 连接，所以实际上每个 Socket 只会存在一个消息，所以接收方只需要一次性读到对端关闭写即可，无需考虑分包问题。而从 HTTP1.1 开始支持了 TCP 长连接，一个 TCP 连接可能顺序传过来多个请求，因此需要考虑分包策略。常见的分包策略有：</p><ul><li><strong>固定的消息长度</strong>，比如每 100 个字节代表一个消息，若不足则补位对齐。解码器处理时只需要判断当前可读的字节数，每次读取到指定长度的字节后进行解码处理即可</li><li><strong>消息头中设置长度字段</strong>，比如每个消息的前 4 个字节用于标志本次消息 Body 的大小。解码器处理时需要先判断 当前可读的字节数是否大于 Header 的大小（这里就是 4 个字节），然后解码出本次消息 Body 的大小，最后根据长度读取到消息 Body 进行解码处理</li><li><strong>使用特殊的字符作为消息边界</strong>，比如把 <code>&quot;\r\n&quot;</code> 当作消息分隔符，当解码器处理到 <code>&quot;\r\n&quot;</code> 时就可以将先前接收到的字节作为一个消息解码</li></ul><p>在消息头设置 Body 的长度应该是最常使用的方式，因为它具有一定的灵活性的同时也比较好实现。而 HTTP 协议是同时基于 <strong>消息头中设置长度字段(<code>Content-length</code>)</strong> + <strong>使用特殊的字符作为消息边界(<code>\r\n</code>)</strong> 实现的：</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/http-request.png" alt="http-request"></p><p>以 Netty 的实现为例，epoll 的 LT 模式（水平模式）下 Socket buffer 只要存在数据就会交由解码器进行处理，因此解码时可读取消息可能为半包状态，以下为相应的解码逻辑：</p><ul><li><p><strong>解码请求行</strong>：由于 HTTP 协议的 Request Line 和 Header 使用 <code>ascii</code> 码字符集，所以解码器将每个字节转为字符判断是否为 <code>\r\n</code>，若发现分隔符则将本行认为是请求行，接下去就会解析请求头</p><blockquote><p>若是此时读取的字节没有 <code>\r\n</code> 会怎么办呢？答案是会将已读取到字节放入 <code>char[]</code>，然后等待后续的字节到来拼接为完整的请求行</p></blockquote></li><li><p><strong>解码请求头</strong>：在解码出请求行后当前解析状态就会进入到解析请求头的过程，具体和请求行类似。稍微有些特殊的是只有当读取到某一行只有 <code>\r\n</code> 时才代表请求头解析完毕。请求头中有一个非常重要的字段叫做 <code>Content-length</code>，它代表后续的请求头的长度以便后续解码请求头</p></li><li><p><strong>解码请求体</strong>：当请求头中解析出来的 <code>Content-length &gt; 0</code> 就会进入到解码请求体的过程，因为 <code>Content-length</code> 已经标记了字节长度，所以只需要读取对应字节数交由应用层处理即可</p></li></ul><p>在 HTTP1.1 时代多路复用存在线头阻塞，因此虽然使用 TCP 长连接，但一个请求被响应前是无法发送下一个请求的，所以接收方接收到的同个请求的字节流自然是连续的，使用上述解码没有问题</p><blockquote><p>其实这种方案应该可以适用于大部分多路复用场景，即使是并发发送，只要发送方控制好多个消息的发送正确性，确保同个消息的字节流总是连续的即可，像 Dubbo，RocketMQ 都是类似的方案</p></blockquote><p>但 HTTP2.0 的支持并发发送的多路复用实现方案是允许同个消息的字节流非连续的，比如 A 消息还未发送完全就可以发送 B 消息了，这是怎么做到的呢？原因在于 HTTP2.0 将一个消息拆分为了多个二进制帧，每个二进制帧都会维护一个消息标记（Stream Identifier），发送方并发传输多个帧，接收方则根据消息标记进行重组。相较于之前的消息维度提高了并发度。下图是乱序发送的一个示例：</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/image-20200913223831809.png" alt="http2.0"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;”TCP 拆包粘包“网络上的争论挺大的，原因在于这一概念在 RFC 中并未提到过，(*￣︶￣)有点民科的赶脚。但实际上它是挺常见的一个问题，比较准确的描述应该是&lt;strong&gt;应用层分包&lt;/strong&gt;问题。那么为什么提到这一概念总是会带上 TCP 而不是 UDP 呢？因为应用层分包问题&lt;strong&gt;本质是接收方在某个时刻接收到的数据不构成一条完整的消息&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于 UDP 来说，它并未在 IP 协议外作出额外的可靠性特性，所以无论发送的数据荷载是多少都会完整的交由 IP 层处理，而 IP 层虽然会根据 MTU 进行分包，但是接收方会确保在 IP 层重组完成才会交由 UDP 处理，否则会直接丢弃。所以基于 UDP 协议实现的应用层协议&lt;strong&gt;每次接收到的数据都是完整的消息&lt;/strong&gt;，无需应用层做额外的分包和重组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于 TCP 来说，它是无边界的字节流协议，为了解决可靠性的问题以及各种性能优化会&lt;strong&gt;导致接收方收到的数据不是完整的消息&lt;/strong&gt;，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若数据荷载过小时，TCP 根据 Nagle 算法整合多个小数据包统一发送&lt;/li&gt;
&lt;li&gt;若数据荷载过大时，TCP 会根据 MSS 大小对数据进行分段发送&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这也就是为啥”拆包粘包“总是碰瓷 TCP 的原因了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机通信" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat 线程模型详解</title>
    <link href="http://yoursite.com/2020/08/30/Tomcat-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/30/Tomcat-线程模型详解/</id>
    <published>2020-08-30T04:26:10.000Z</published>
    <updated>2020-11-05T09:35:09.260Z</updated>
    
    <content type="html"><![CDATA[<p>Tomcat 作为最常见的 Servlet 容器，在 6.x 版本就支持了 NIO 模式的 Connector 和 Reactor 模式相比有什么特殊之处吗？首先来看下面的表格：</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:center">Java Nio Connector NIO</th><th style="text-align:center">Java Nio2 Connector NIO2</th><th>APR/native Connector APR</th></tr></thead><tbody><tr><td style="text-align:left">Classname</td><td style="text-align:center"><code>Http11NioProtocol</code></td><td style="text-align:center"><code>Http11Nio2Protocol</code></td><td><code>Http11AprProtocol</code></td></tr><tr><td style="text-align:left">Tomcat Version</td><td style="text-align:center">since 6.0.x</td><td style="text-align:center">since 8.0.x</td><td>since 5.5.x</td></tr><tr><td style="text-align:left">Support Polling</td><td style="text-align:center">YES</td><td style="text-align:center">YES</td><td>YES</td></tr><tr><td style="text-align:left">Polling Size</td><td style="text-align:center"><code>maxConnections</code></td><td style="text-align:center"><code>maxConnections</code></td><td><code>maxConnections</code></td></tr><tr><td style="text-align:left">Read Request Headers</td><td style="text-align:center">Non Blocking</td><td style="text-align:center">Non Blocking</td><td>Non Blocking</td></tr><tr><td style="text-align:left">Read Request Body</td><td style="text-align:center">Blocking</td><td style="text-align:center">Blocking</td><td>Blocking</td></tr><tr><td style="text-align:left">Write Response Headers and Body</td><td style="text-align:center">Blocking</td><td style="text-align:center">Blocking</td><td>Blocking</td></tr><tr><td style="text-align:left">Wait for next Request</td><td style="text-align:center">Non Blocking</td><td style="text-align:center">Non Blocking</td><td>Non Blocking</td></tr><tr><td style="text-align:left">SSL Support</td><td style="text-align:center">Java SSL or OpenSSL</td><td style="text-align:center">Java SSL or OpenSSL</td><td>OpenSSL</td></tr><tr><td style="text-align:left">SSL Handshake</td><td style="text-align:center">Non blocking</td><td style="text-align:center">Non blocking</td><td>Blocking</td></tr><tr><td style="text-align:left">Max Connections</td><td style="text-align:center"><code>maxConnections</code></td><td style="text-align:center"><code>maxConnections</code></td><td><code>maxConnections</code></td></tr></tbody></table><a id="more"></a><p>这是从 <a href="https://tomcat.apache.org/tomcat-9.0-doc/config/http.html#Connector_Comparison" target="_blank" rel="noopener">Apache Tomcat 9 Configuration Reference-Connector Comparison</a> 中得到的多种模式下的 Connector 的对比：</p><ul><li><p>NIO 就是我们熟悉的同步非阻塞 I/O 模型</p></li><li><p>NIO2 指的是 AIO，即异步 I/O 模型，其实 Netty 已经抛弃 AIO，至于原因根据 <a href="https://github.com/netty/netty/issues/2515" target="_blank" rel="noopener">ISSUE-NIO.2 support</a> 介绍主要还是 Linux 下技术不够成熟以及复杂度的考虑</p></li><li><p>ARP 实际上还是 NIO 模式，只不过它是基于 ARP（Apache Portable Runtime Libraries，由 C 写的 Apache 可移植运行时库）实现以提高性能。我们在启动 Tomcat 经常能看到 <em>The APR based Apache Tomcat Native library which allows optimal performance in production environments was not found on the java.library.path:</em> 提示就是指需要我们安装指定的环境以便正常启动 ARP 模式，当然我们现在常见使用的还是 NIO 模式，所以可以忽略该条提示</p></li></ul><p>我们主要关心的是 NIO 模式，而从表格中可以知道比较重要的点：</p><ul><li>Read Request Body/Write Response Headers and Body 是阻塞的</li><li>Read Request Headers/Wait for next Request 是非阻塞的</li></ul><p>既然使用 NIO 模式为什么还要阻塞的读写数据呢？因为 Tomcat 是 Servlet 容器，Read Request Body/Write Response Headers and Body 是由 ServletInputStream 和 ServletOutputStream 定义的，而在 Servlet3.1 之前的规范中 ServletInputStream 和 ServletOutputStream 是<strong>阻塞</strong>的。</p><h2 id="Tomcat-线程模型"><a href="#Tomcat-线程模型" class="headerlink" title="Tomcat 线程模型"></a>Tomcat 线程模型</h2><p>下图是 Tomcat 的整体线程模型：</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/Tomcat线程模型.png" alt="Tomcat线程模型"></p><ul><li><p>Acceptor：<strong>单线程阻塞</strong>监听连接事件，和 Multi-Reactor 模型的 Main Reactor + Acceptor 的作用相似</p></li><li><p>Poller：Acceptor 接收到的连接事件将通过 PollEvent 事件传递到 Poller 线程池处理，本质上就是将该 Socket 后续的读写事件交由 Poller 线程中的 Selector 进行监听并分派。Poller 线程池的线程池数为 CPU * 2，和 Multi-Reactor 模型的 Sub Reactor 的作用类似</p><blockquote><p>在 Multi-Reactor 模型中，读写 I/O 也是在 Sub Reactor 中执行的，而在 Tomcat 中仅有 Http 请求头，请求行是在 Poller 中执行的</p></blockquote></li><li><p>Worker（Servlet）：Poller 在解析完 Http 请求行，请求头后会将请求交由 Worker 业务线程池进行处理，默认情况下会创建最大线程数为 200 的线程池。当用户通过 ServletInputStream.read/write 读取 Request Body 或写入时将会向 Block Poller 注册监听读写事件，和 Multi-Reactor 模型的 Handler 的作用类似</p></li><li><p>Block Poller：这是 Multi-Reactor 模型没有的角色，单线程的监听向其注册的 Socket 的读写事件，当事件发生后将交由 Worker 线程阻塞读写。它主要是结合 Worker 线程实现基于 NIO 的模拟阻塞读写，在后文会通过源码进行解析</p></li></ul><p>Servlet 规范导致 Tomcat 的线程模型和 Reactor 模式具有一定差距，在 Multi-Reactor 中，I/O 读写（Sub-Reactor 线程执行）和业务阻塞是分离的（Handler 所在业务线程执行），而 Tomcat 的 I/O 读写和业务阻塞均在同个 Worker 线程（也可以称为 Servlet 线程），这在业务阻塞时长比较大的情况下具有比较大的影响</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="阻塞读取Request-Body"><a href="#阻塞读取Request-Body" class="headerlink" title="阻塞读取Request Body"></a>阻塞读取Request Body</h3><p>Tomcat 的 Request Body 的读取是阻塞式的，调用 <code>ServletInputStream.read</code> 时会触发读取 Request Body，在 Tomcat 中的实现是 <code>CoyoteInputStream.read</code>。其内部会触发 ActiveFilter 链的调用</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.Http11InputBuffer#doRead</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doRead</span><span class="hljs-params">(ApplicationBufferHandler handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (lastActiveFilter == -<span class="hljs-number">1</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> inputStreamInputBuffer.doRead(handler);</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        <span class="hljs-keyword">return</span> activeFilters[lastActiveFilter].doRead(handler);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认处理非 chunked 请求的 Filter 是 IdentityInputFilter</p><blockquote><p>chunked 请求：HTTP1.1 长连接模式下，为了能正确复用 TCP 连接，需要通过 Content-Length 或 chunked 来标志响应体大小，但诸如网络文件等要想准确获取长度需要生成完成才能确认，所以通过 chunked 分块编码来提高性能</p></blockquote><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.filters.IdentityInputFilter#doRead</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doRead</span><span class="hljs-params">(ApplicationBufferHandler handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> result = -<span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (contentLength &gt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (remaining &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> nRead = buffer.doRead(handler);</span><br><span class="line">            <span class="hljs-keyword">if</span> (nRead &gt; remaining) &#123;</span><br><span class="line">                <span class="hljs-comment">// The chunk is longer than the number of bytes remaining</span></span><br><span class="line">                <span class="hljs-comment">// in the body; changing the chunk length to the number</span></span><br><span class="line">                <span class="hljs-comment">// of bytes remaining</span></span><br><span class="line">                handler.getByteBuffer().limit(handler.getByteBuffer().position() + (<span class="hljs-keyword">int</span>) remaining);</span><br><span class="line">                result = (<span class="hljs-keyword">int</span>) remaining;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                result = nRead;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (nRead &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                remaining = remaining - nRead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// No more bytes left to be read : return -1 and clear the</span></span><br><span class="line">            <span class="hljs-comment">// buffer</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (handler.getByteBuffer() != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                handler.getByteBuffer().position(<span class="hljs-number">0</span>).limit(<span class="hljs-number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            result = -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里插一句和线程模型无关的知识点，即如何判断 Http 请求已读取完成？根据上面的逻辑可以看出，Tomcat 在读取每个 Http 请求的时候是根据 Header 中的 Content-Length 来读取字节的，每次读取一定字节时会更新 <code>remaining = remaining - nRead</code>，当 remaining = 0 时代表当前 Http 请求的 Request Body 已读取完成，因此当 CoyoteInputStream.read 未返回 -1 时均代表当前 Http 请求未接收完整</p></blockquote><p>其中 <code>buffer.doRead(handler)</code> 调用的实际上是 <code>Http11InputBuffer.SocketInputBuffer#doRead</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketInputBuffer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InputBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doRead</span><span class="hljs-params">(ApplicationBufferHandler handler)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (byteBuffer.position() &gt;= byteBuffer.limit()) &#123;</span><br><span class="line">            <span class="hljs-comment">// The application is reading the HTTP request body which is</span></span><br><span class="line">            <span class="hljs-comment">// always a blocking operation.</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!fill(<span class="hljs-keyword">true</span>))</span><br><span class="line">                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> length = byteBuffer.remaining();</span><br><span class="line">        handler.setByteBuffer(byteBuffer.duplicate());</span><br><span class="line">        byteBuffer.position(byteBuffer.limit());</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意在调用 <code>fill</code> 方法时会传入 true，代表<strong>阻塞的获取 Http request body</strong>。去除无关的调用链，最终读取的关键位置在 <code>NioSelectorPool#read</code>，该方法通过 NIO 模拟阻塞</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.tomcat.util.net.NioBlockingSelector#read</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(ByteBuffer buf, NioChannel socket, <span class="hljs-keyword">long</span> readTimeout)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(sm.getString(<span class="hljs-string">"nioBlockingSelector.keyNotRegistered"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    KeyReference reference = keyReferenceStack.pop();</span><br><span class="line">    <span class="hljs-keyword">if</span> (reference == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        reference = <span class="hljs-keyword">new</span> KeyReference();</span><br><span class="line">    &#125;</span><br><span class="line">    NioSocketWrapper att = (NioSocketWrapper) key.attachment();</span><br><span class="line">    <span class="hljs-keyword">int</span> read = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> timedout = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> keycount = <span class="hljs-number">1</span>; <span class="hljs-comment">//assume we can read</span></span><br><span class="line">    <span class="hljs-keyword">long</span> time = System.currentTimeMillis(); <span class="hljs-comment">//start the timeout timer</span></span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span>(!timedout) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (keycount &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//only read if we were registered for a read</span></span><br><span class="line">                read = socket.read(buf);</span><br><span class="line">                <span class="hljs-keyword">if</span> (read != <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> ( att.getReadLatch()==<span class="hljs-keyword">null</span> || att.getReadLatch().getCount()==<span class="hljs-number">0</span>) att.startReadLatch(<span class="hljs-number">1</span>);</span><br><span class="line">                poller.add(att,SelectionKey.OP_READ, reference);</span><br><span class="line">                <span class="hljs-keyword">if</span> (readTimeout &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    att.awaitReadLatch(Long.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    att.awaitReadLatch(readTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                <span class="hljs-comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> ( att.getReadLatch()!=<span class="hljs-keyword">null</span> &amp;&amp; att.getReadLatch().getCount()&gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">//we got interrupted, but we haven't received notification from the poller.</span></span><br><span class="line">                keycount = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">//latch countdown has happened</span></span><br><span class="line">                keycount = <span class="hljs-number">1</span>;</span><br><span class="line">                att.resetReadLatch();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (readTimeout &gt;= <span class="hljs-number">0</span> &amp;&amp; (keycount == <span class="hljs-number">0</span>))</span><br><span class="line">                timedout = (System.currentTimeMillis() - time) &gt;= readTimeout;</span><br><span class="line">        &#125; <span class="hljs-comment">//while</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (timedout)</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SocketTimeoutException();</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        poller.remove(att,SelectionKey.OP_READ);</span><br><span class="line">        <span class="hljs-keyword">if</span> (timedout &amp;&amp; reference.key!=<span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            poller.cancelKey(reference.key);</span><br><span class="line">        &#125;</span><br><span class="line">        reference.key = <span class="hljs-keyword">null</span>;</span><br><span class="line">        keyReferenceStack.push(reference);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码逻辑为：</p><ul><li><p>通过 <code>socket.read(buf)</code> 尝试进行读取一次，若读取成功则返回</p></li><li><p>若当前不可读，则通过 <code>poller.add(att,SelectionKey.OP_READ, reference)</code> 向 BlockPoller 注册 OP_READ 事件，然后通过 CountDownLatch 将当前 Worker 线程阻塞</p></li><li><p>由 BlockPoller 单线程监听 OP_READ 事件，在可读时唤醒 Worker 线程，由 Worker 线程进行读取</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.tomcat.util.net.NioBlockingSelector.BlockPoller#run</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = keyCount &gt; <span class="hljs-number">0</span> ? selector.selectedKeys().iterator() : <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line"><span class="hljs-comment">// any active event.</span></span><br><span class="line"><span class="hljs-keyword">while</span> (run &amp;&amp; iterator != <span class="hljs-keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey sk = iterator.next();</span><br><span class="line">    NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        sk.interestOps(sk.interestOps() &amp; (~sk.readyOps()));</span><br><span class="line">        <span class="hljs-keyword">if</span> ( sk.isReadable() ) &#123;</span><br><span class="line">            countDown(attachment.getReadLatch());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (sk.isWritable()) &#123;</span><br><span class="line">            countDown(attachment.getWriteLatch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="hljs-keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">        sk.cancel();</span><br><span class="line">        countDown(attachment.getReadLatch());</span><br><span class="line">        countDown(attachment.getWriteLatch());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="hljs-comment">//while</span></span><br></pre></td></tr></table></figure></li></ul><p>所以实际上 Request Body 的读取是由 Worker 线程阻塞读取完成的，至于 BlockPoller 其实类似 Poller，只不过它的 Selector 单独处理 Request Body 的读写事件</p><h3 id="阻塞写入数据"><a href="#阻塞写入数据" class="headerlink" title="阻塞写入数据"></a>阻塞写入数据</h3><p>Tomcat 的写入同样是阻塞式的，由 <code>ServletOutputStream.write</code> 时会触发，在 Tomcat 的实现类为 <code>CoyoteOutputStream#write</code>，其内部同样有个 OutputFilter</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.Http11OutputBuffer#flush</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (lastActiveFilter == -<span class="hljs-number">1</span>) &#123;</span><br><span class="line">        outputStreamOutputBuffer.flush();</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        activeFilters[lastActiveFilter].flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下调用的是 <code>IdentityOutputFilter.write</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.filters.IdentityOutputFilter#doWrite</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(ByteBuffer chunk)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> result = -<span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (contentLength &gt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (remaining &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            result = chunk.remaining();</span><br><span class="line">            <span class="hljs-keyword">if</span> (result &gt; remaining) &#123;</span><br><span class="line">                <span class="hljs-comment">// The chunk is longer than the number of bytes remaining</span></span><br><span class="line">                <span class="hljs-comment">// in the body; changing the chunk length to the number</span></span><br><span class="line">                <span class="hljs-comment">// of bytes remaining</span></span><br><span class="line">                chunk.limit(chunk.position() + (<span class="hljs-keyword">int</span>) remaining);</span><br><span class="line">                result = (<span class="hljs-keyword">int</span>) remaining;</span><br><span class="line">                remaining = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                remaining = remaining - result;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.doWrite(chunk);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-comment">// No more bytes left to be written : return -1 and clear the</span></span><br><span class="line">            <span class="hljs-comment">// buffer</span></span><br><span class="line">            chunk.position(<span class="hljs-number">0</span>);</span><br><span class="line">            chunk.limit(<span class="hljs-number">0</span>);</span><br><span class="line">            result = -<span class="hljs-number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// If no content length was set, just write the bytes</span></span><br><span class="line">        result = chunk.remaining();</span><br><span class="line">        buffer.doWrite(chunk);</span><br><span class="line">        result -= chunk.remaining();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里同样插一句和线程模型无关的知识点，即如何判断 Http 请求已写入完成？根据上面的逻辑可以看出，Tomcat 在写入每个 Http 请求的时候是根据 Response Header 中的 Content-Length 来写入字节的，每次写入一定字节时会更新 <code>remaining = remaining - nRead</code>，当 remaining = 0 时代表当前 Http 请求的 Reponse 已写入完成</p></blockquote><p>其中 <code>buffer.doWrite(chunk);</code> 调用的实际上是 <code>Http11OutputBuffer.SocketOutputBuffer#doWrite</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.Http11OutputBuffer.SocketOutputBuffer#doWrite</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(ByteBuffer chunk)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> len = chunk.remaining();</span><br><span class="line">        socketWrapper.write(isBlocking(), chunk);</span><br><span class="line">        len -= chunk.remaining();</span><br><span class="line">        byteCount += len;</span><br><span class="line">        <span class="hljs-keyword">return</span> len;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        response.action(ActionCode.CLOSE_NOW, ioe);</span><br><span class="line">        <span class="hljs-comment">// Re-throw</span></span><br><span class="line">        <span class="hljs-keyword">throw</span> ioe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>socketWrapper.write(isBlocking(), chunk);</code> 会使用<strong>阻塞的方式进行写入</strong>，最终写入的核心方法为 <code>NioSelectorPool#write</code> </p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.tomcat.util.net.NioBlockingSelector#write</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">write</span><span class="hljs-params">(ByteBuffer buf, NioChannel socket, <span class="hljs-keyword">long</span> writeTimeout)</span></span></span><br><span class="line"><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    SelectionKey key = socket.getIOChannel().keyFor(socket.getPoller().getSelector());</span><br><span class="line">    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(sm.getString(<span class="hljs-string">"nioBlockingSelector.keyNotRegistered"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    KeyReference reference = keyReferenceStack.pop();</span><br><span class="line">    <span class="hljs-keyword">if</span> (reference == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        reference = <span class="hljs-keyword">new</span> KeyReference();</span><br><span class="line">    &#125;</span><br><span class="line">    NioSocketWrapper att = (NioSocketWrapper) key.attachment();</span><br><span class="line">    <span class="hljs-keyword">int</span> written = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> timedout = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> keycount = <span class="hljs-number">1</span>; <span class="hljs-comment">//assume we can write</span></span><br><span class="line">    <span class="hljs-keyword">long</span> time = System.currentTimeMillis(); <span class="hljs-comment">//start the timeout timer</span></span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> ( (!timedout) &amp;&amp; buf.hasRemaining()) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (keycount &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//only write if we were registered for a write</span></span><br><span class="line">                <span class="hljs-keyword">int</span> cnt = socket.write(buf); <span class="hljs-comment">//write the data</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (cnt == -<span class="hljs-number">1</span>)</span><br><span class="line">                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EOFException();</span><br><span class="line">                written += cnt;</span><br><span class="line">                <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    time = System.currentTimeMillis(); <span class="hljs-comment">//reset our timeout timer</span></span><br><span class="line">                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//we successfully wrote, try again without a selector</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> ( att.getWriteLatch()==<span class="hljs-keyword">null</span> || att.getWriteLatch().getCount()==<span class="hljs-number">0</span>) att.startWriteLatch(<span class="hljs-number">1</span>);</span><br><span class="line">                poller.add(att,SelectionKey.OP_WRITE,reference);</span><br><span class="line">                <span class="hljs-keyword">if</span> (writeTimeout &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    att.awaitWriteLatch(Long.MAX_VALUE,TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    att.awaitWriteLatch(writeTimeout,TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                <span class="hljs-comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> ( att.getWriteLatch()!=<span class="hljs-keyword">null</span> &amp;&amp; att.getWriteLatch().getCount()&gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-comment">//we got interrupted, but we haven't received notification from the poller.</span></span><br><span class="line">                keycount = <span class="hljs-number">0</span>;</span><br><span class="line">            &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                <span class="hljs-comment">//latch countdown has happened</span></span><br><span class="line">                keycount = <span class="hljs-number">1</span>;</span><br><span class="line">                att.resetWriteLatch();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (writeTimeout &gt; <span class="hljs-number">0</span> &amp;&amp; (keycount == <span class="hljs-number">0</span>))</span><br><span class="line">                timedout = (System.currentTimeMillis() - time) &gt;= writeTimeout;</span><br><span class="line">        &#125; <span class="hljs-comment">//while</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (timedout)</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SocketTimeoutException();</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        poller.remove(att,SelectionKey.OP_WRITE);</span><br><span class="line">        <span class="hljs-keyword">if</span> (timedout &amp;&amp; reference.key!=<span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            poller.cancelKey(reference.key);</span><br><span class="line">        &#125;</span><br><span class="line">        reference.key = <span class="hljs-keyword">null</span>;</span><br><span class="line">        keyReferenceStack.push(reference);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码逻辑为：</p><ul><li><p>通过 <code>socket.write(buf)</code> 尝试进行写入一次，若读取成功则返回</p></li><li><p>若当前不可写，则通过 <code>poller.add(att,SelectionKey.OP_WRITE, reference)</code> 向 BlockPoller 注册 OP_WRITE 写入事件，然后通过 CountDownLatch 将当前 Worker 线程阻塞</p></li><li><p>由 BlockPoller 单线程监听 OP_WRITE 事件，在可读时唤醒 Worker 线程，由 Worker 线程进行读取</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.tomcat.util.net.NioBlockingSelector.BlockPoller#run</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = keyCount &gt; <span class="hljs-number">0</span> ? selector.selectedKeys().iterator() : <span class="hljs-keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Walk through the collection of ready keys and dispatch</span></span><br><span class="line"><span class="hljs-comment">// any active event.</span></span><br><span class="line"><span class="hljs-keyword">while</span> (run &amp;&amp; iterator != <span class="hljs-keyword">null</span> &amp;&amp; iterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey sk = iterator.next();</span><br><span class="line">    NioSocketWrapper attachment = (NioSocketWrapper)sk.attachment();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">        sk.interestOps(sk.interestOps() &amp; (~sk.readyOps()));</span><br><span class="line">        <span class="hljs-keyword">if</span> ( sk.isReadable() ) &#123;</span><br><span class="line">            countDown(attachment.getReadLatch());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (sk.isWritable()) &#123;</span><br><span class="line">            countDown(attachment.getWriteLatch());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="hljs-keyword">catch</span> (CancelledKeyException ckx) &#123;</span><br><span class="line">        sk.cancel();</span><br><span class="line">        countDown(attachment.getReadLatch());</span><br><span class="line">        countDown(attachment.getWriteLatch());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="hljs-comment">//while</span></span><br></pre></td></tr></table></figure></li></ul><p>所以写数据和读取 Request Body 是非常相似的过程</p><h2 id="Servlet-异步和非阻塞"><a href="#Servlet-异步和非阻塞" class="headerlink" title="Servlet 异步和非阻塞"></a>Servlet 异步和非阻塞</h2><p>上面提到了 Tomcat 的 I/O 读写和业务阻塞均在同个 Servlet 线程，这在业务阻塞时间较长时很容易出现 Tomcat 的 Worker 线程池任务堆积（默认最大 200 个线程），无法支撑高并发场景。而在 Servlet3.0 开始支持了 Servlet 异步接口：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext asyncContext = request.startAsync();</span><br><span class="line"></span><br><span class="line">asyncContext.start(() -&gt; &#123;</span><br><span class="line">    process();</span><br><span class="line">    asyncContext.complete();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过异步模式可以将 I/O 读写和业务阻塞分离以达到复用 Worker 线程的作用。但是此时 InputStream 和 OutputStream 的 I/O 操作仍然是阻塞的，因此无论将 I/O 操作放在 Servlet 线程还是自定义线程，这总是会导致对应线程无用的等待，因此在 Servlet3.1 开始支持非阻塞 I/O，通过非阻塞 I/O 才解决了读写时线程资源浪费的问题。</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/image-20200924185239968.png" alt="servlet-api" style="zoom:50%;"></p><p>结合异步模式和非阻塞 I/O，Tomcat 就真正<strong>既解决了“一个连接一个请求”的问题，又解决高并发下业务阻塞会影响到读写线程的问题</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext asyncContext = request.startAsync();</span><br><span class="line">ServletInputStream inputStream = request.getInputStream();</span><br><span class="line">inputStream.setReadListener(<span class="hljs-keyword">new</span> ReadListener() &#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDataAvailable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onAllDataRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            process();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                asyncContext.getResponse().getWriter().write(<span class="hljs-string">"xxx"</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            asyncContext.complete();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        asyncContext.complete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>根据 <a href="http://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">Apache Tomcat Versions</a> 的介绍，在 Tomcat8.x 中已经支持了 Servlet3.1</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/image-20200830112515693.png" alt="tomcat-version"></p><h2 id="Tomcat-or-Netty"><a href="#Tomcat-or-Netty" class="headerlink" title="Tomcat or Netty"></a>Tomcat or Netty</h2><p>Tomcat 属于 Servlet 容器，Netty 属于异步网络编程框架，但它们都能作为 web 容器。上面介绍了 Tomcat 的线程模型，那么和 Netty 相比，谁更适合做 Web 服务器呢？如果针对于 Http 协议，那么 Tomcat 是毫无疑问的，它对于 Http 有着更完善的支持，比如 Chunk 分块传输。而 Netty 是基于传输层的，所以可以支持更多的应用层协议。</p><p>那么 Tomcat 和 Netty 的线程模型谁更有优势呢？其实没有本质上的区别，Tomcat 的 NIO 模式和 Netty 的 Multi-Reactor 模式都解决了“一个连接一个线程”的问题，且默认模式下业务处理和 I/O 读写都是在同个线程</p><ul><li>Netty 的默认模型并不是 Multi-Reactor 模型，业务处理默认情况下是和 Sub Reactor 处于同个线程</li><li>Tomcat 的读写均在 Worker 线程</li></ul><p>所以容器可优化业务阻塞时间较长场景的方案是：采用业务阻塞和 I/O 阻塞分离的方式实现（异步 Servlet 或 Multi-Reactor 模式）。但这已经是容器优化的极限了，它仍然无法解决大量业务线程阻塞时间过长时仍然会导致大量的线程产生的问题。因此要想进一步提高性能，不能只看容器，而需要将业务阻塞（比如缓存，数据库，RPC 等）操作变为非阻塞操作以提高线程复用程度</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>Http Request Body 是由用户在 Servlet 线程进行阻塞读取的，假如用户不主动读取上传的问题会出现什么情况呢，比如上传一个 100M 的文件 Tomcat 会自动接收吗？</p><ul><li><p>从 TCP 层面来看，如果数据一直不被接收，那么 Recv Buffer 会很快被占满，根据流量控制机制发送方将不会再发送数据，所以是不会自动接收所有数据的</p></li><li><p>从 Tomcat 层面来看，我们可以观察 <code>IdentityInputFilter#end</code> 方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># org.apache.coyote.http11.filters.IdentityInputFilter#end</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> maxSwallowSizeExceeded = (maxSwallowSize &gt; -<span class="hljs-number">1</span> &amp;&amp; remaining &gt; maxSwallowSize);</span><br><span class="line">    <span class="hljs-keyword">long</span> swallowed = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Consume extra bytes.</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (remaining &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> nread = buffer.doRead(<span class="hljs-keyword">this</span>);</span><br><span class="line">        tempRead = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (nread &gt; <span class="hljs-number">0</span> ) &#123;</span><br><span class="line">            swallowed += nread;</span><br><span class="line">            remaining = remaining - nread;</span><br><span class="line">            <span class="hljs-keyword">if</span> (maxSwallowSizeExceeded &amp;&amp; swallowed &gt; maxSwallowSize) &#123;</span><br><span class="line">                <span class="hljs-comment">// Note: We do not fail early so the client has a chance to</span></span><br><span class="line">                <span class="hljs-comment">// read the response before the connection is closed. See:</span></span><br><span class="line">                <span class="hljs-comment">// https://httpd.apache.org/docs/2.0/misc/fin_wait_2.html#appendix</span></span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(sm.getString(<span class="hljs-string">"inputFilter.maxSwallow"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// errors are handled higher up.</span></span><br><span class="line">            remaining = <span class="hljs-number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// If too many bytes were read, return the amount.</span></span><br><span class="line">    <span class="hljs-keyword">return</span> -remaining;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在请求结束后 Tomcat 会自动调用该方法，其代码如果缓存中存在剩余的字节，Tomcat 会自动读取，但是会有限制，默认只读取 2M(由 maxSwallowSize 确定)，如果请求体数据大于 2M，Tomcat 会抛出异常并关闭连接。</p><blockquote><p>The maximum number of request body bytes (excluding transfer encoding overhead) that will be swallowed by Tomcat for an aborted upload. An aborted upload is when Tomcat knows that the request body is going to be ignored but the client still sends it. If Tomcat does not swallow the body the client is unlikely to see the response. If not specified the default of 2097152 (2 megabytes) will be used. A value of less than zero indicates that no limit should be enforced.</p><p>​                                                       <a href="https://tomcat.apache.org/tomcat-8.0-doc/config/http.html" target="_blank" rel="noopener">The HTTP Connector</a></p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Tomcat 作为最常见的 Servlet 容器，在 6.x 版本就支持了 NIO 模式的 Connector 和 Reactor 模式相比有什么特殊之处吗？首先来看下面的表格：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Java Nio Connector NIO&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Java Nio2 Connector NIO2&lt;/th&gt;
&lt;th&gt;APR/native Connector APR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Classname&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;Http11NioProtocol&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;Http11Nio2Protocol&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Http11AprProtocol&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Tomcat Version&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;since 6.0.x&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;since 8.0.x&lt;/td&gt;
&lt;td&gt;since 5.5.x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Support Polling&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;YES&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Polling Size&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;maxConnections&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;maxConnections&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;maxConnections&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Read Request Headers&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Non Blocking&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Non Blocking&lt;/td&gt;
&lt;td&gt;Non Blocking&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Read Request Body&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Blocking&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Blocking&lt;/td&gt;
&lt;td&gt;Blocking&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Write Response Headers and Body&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Blocking&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Blocking&lt;/td&gt;
&lt;td&gt;Blocking&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Wait for next Request&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Non Blocking&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Non Blocking&lt;/td&gt;
&lt;td&gt;Non Blocking&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;SSL Support&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Java SSL or OpenSSL&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Java SSL or OpenSSL&lt;/td&gt;
&lt;td&gt;OpenSSL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;SSL Handshake&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Non blocking&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Non blocking&lt;/td&gt;
&lt;td&gt;Blocking&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Max Connections&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;maxConnections&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;maxConnections&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;maxConnections&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Tomcat/"/>
    
    
      <category term="Reactor" scheme="http://yoursite.com/tags/Reactor/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Reactor模式</title>
    <link href="http://yoursite.com/2020/08/23/Reactor%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/08/23/Reactor模式/</id>
    <published>2020-08-23T08:41:25.000Z</published>
    <updated>2020-08-30T04:43:47.019Z</updated>
    
    <content type="html"><![CDATA[<p>标准 I/O 会存在两个阶段：（以 TCP Socket 举例）</p><ul><li>数据在内核态和用户态的复制：TCP 协议栈维护着 Send Buffer（发送缓冲区）和 Recv Buffer（接收缓冲区），因此 read/write 都只是将用户态数据复制到内核态的 Socket Buffer(Send/Recv Buffer)。而 Socket Buffer 和网卡之间会通过 DMA 进行数据传输（不占用 CPU）</li><li>等待数据就绪：对于 read 操作来说，就绪是指 Recv Buffer 没有可读的数据；而对于 write 操作来说，就绪是指 Send Buffer 已满无法写入</li></ul><p>BIO 称为同步阻塞 I/O，它在上述的两个阶段均会阻塞。因此 <strong>BIO 必须为每个 TCP 连接创建新线程</strong>并阻塞等待其可读或可写。服务端若想支持大量客户端连接，在 BIO 的前提下使用多线程来解决是必然的事情，下面用一个简单的例子展示：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="hljs-number">100</span>);</span><br><span class="line"><span class="hljs-keyword">try</span>(ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">8080</span>)) &#123;</span><br><span class="line">    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span>(BufferedReader reader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(socket.getInputStream()))) &#123;</span><br><span class="line">                decode();</span><br><span class="line">                process();</span><br><span class="line">                encode();</span><br><span class="line">                write();</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在连接数不多的情况下，上述例子并无不妥。但是在高并发下呢？关键点在于线程</p><ul><li>每个线程占用 256K～1M 的空间，高并发下存在大量的连接会占用大量的内存</li><li>过多的线程会使得 CPU 调度成本很高，CPU 将会疲于调度导致 CPU sy 使用率特别高</li></ul><p>因此我们回过头来考虑一个很重要的问题，<strong>有必要为每个连接创建一个线程吗，这些阻塞等待I/O 的线程有意义吗</strong>？假如大部分连接都不会同时处于活跃状态（即此时连接并无读写事件发生），那么线程实际上在做无用的等待；而假如并发活跃连接数非常大，那么会存在大量的线程执行 write/read，此时会存在大量用户态数据和内核态的 Socket Buffer 互相复制的操作，该操作需要消耗 CPU。既然是依赖于 CPU，那么创建大量线程并没有正向作用，反而应该选择和 CPU 核心数类似的线程数。因此<strong>不管从哪个角度来说，为每个新连接都创建一个线程去阻塞等待读写都不是一个好选择</strong>。</p><p>那么理想的处理模型是怎么样的呢？关键的点是将本该由线程去阻塞等待可读可写变成异步以及回调处理，这就依赖于两个技术点：</p><ul><li><p><code>NIO</code>：作为同步非阻塞 I/O，它在等待就绪阶段是非阻塞的，在内核态和用户态的复制阶段是同步阻塞的。通过 NIO 能保证线程不会做无用的等待</p></li><li><p><code>I/O 多路复用</code>：只要应用通过系统调用通知内核所需监听的连接以及事件，内核能够在监听连接可读写时回调通知应用程序</p><blockquote><p>注意，这里提到的 I/O 多路复用和 HTTP2 中的 Multiplexing 并不是一个概念，HTTP2 中的 Multiplexing 代表同个 TCP 连接可以复用来支持多个 HTTP 请求并发请求，而 I/O 多路复用(也可以理解为 I/O 多路传输) 代表使用单循环来处理多个连接，比如 select, epoll</p></blockquote></li></ul><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>Linux 为 I/O 多路复用提供了多个系统调用，如 select，poll，epoll。以 Linux 提供的 select 系统调用举例：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>构建 <code>select</code> 需要传入三个 fd(文件描述符) 数组分别指向内核需要对可读、可写和异常等事件进行监听的对应的描述符集合。调用 select 函数后，就会阻塞的等待事件到来。当 select 返回时应用需要遍历所有的 fd 来寻找发生事件的 socket。</p><p>select 有一些比较明显的缺点：</p><ul><li>应用每次调用 select 都需要传入所有的 fd（<strong>最大个数不能超过1024个</strong>），这会导致这三个数组<strong>频繁的从用户态复制到内核态</strong></li><li>内核每次都需要遍历所有的 fd 去检查就绪的事件</li><li><strong>select 返回后应用程序需要遍历 fd 数组获取真正发生事件的 fd</strong></li></ul><p>而后续出现的 <code>epoll</code> 解决了上面几个痛点，它会在<strong>内核中维护一个数据表以避免每次都需要传入 fd 数组</strong>（减少了数据复制），同时也<strong>去除了 fd 个数的限制</strong>，并且 <strong>epoll 只会返回被触发的事件对应的 fd</strong> 从而避免应用程序去做额外的扫描和过滤。</p><p>但是不管是哪种实现方式，I/O 多路复用的基本使用方式都是：<strong>注册 -&gt; 监听事件 -&gt; 回调处理</strong>，因为只有应用先向内核注册感兴趣的事件以及 socket，内核才会在事件发生时回调应用。</p><h2 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h2><p>Reactor 模式是基于事件驱动的网络编程模式，能用少量的线程支持大量的连接，它也可以理解为 NIO 和 I/O 多路复用的最佳实践，在诸如 Netty 等网络编程框架已支持了 Reactor 的多种模式。单线程 Reactor 基本原理如下：</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/SingleThreadReactor.png" alt="SingleThreadReactor"></p><p>上图存在几个角色：</p><ul><li>Reactor：可以理解为事件分派器，维护多路复用器，监听并分派事件到对应的 Handler</li><li>Acceptor：处理连接事件，负责向多路复用器注册感兴趣事件</li><li>Handler：处理读写就绪事件，包含 read, decode，process，encode, send 等处理，也可以向多路复用器注册感兴趣事件（比如写就绪）</li></ul><p>通过单线程版 Reactor 模式可以使用单个线程就完成 Server 端的所有处理逻辑，而不再需要为每个连接创建一个新线程。但在实际应用中还需要做更多的优化：</p><ul><li>Handler 中的 read/write 这些操作由于是在接收到就绪事件后调用的，所以 I/O 操作大部分时间会使用 CPU 的，因此实际上可以构建和 CPU 核心数相同的线程数来提高 CPU 利用率</li><li>Handler 中的 process 业务处理操作可能存在其他阻塞 I/O 操作，比如 DB，RPC 等，因此可以创建 Worker 线程池进行处理，其线程数可大于 CPU 核心数</li></ul><p>因此优化后的 Reactor 模式将 read/write 操作交由其线程数等于 CPU 核心数的线程池处理，而业务处理逻辑交由单独的 Worker 线程池处理。而这就是多线程 Reactor 模式（有些地方也称为主从 Reactor 模式）的原理</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/MultipleReactor模式.png" alt="MultipleReactor"></p><ul><li>Main Reactor 仍然使用单线程处理，只不过这次它只需要处理新连接就绪事件</li><li>Sub Reactor 使用和 CPU 核心数相等的线程池负责读写事件的监听以及分配</li><li>Handler 的 I/O 部分（实际上 decode/encode 也可以放在这里）和 Sub Reactor 处于同一线程</li><li>Handler 的业务处理部分交由 Worker 线程池处理（线程数可大于 CPU 核心数）</li></ul><p>其实还可以考虑一下，Handler 的业务处理所在的 Worker 线程池实际上会为每个请求分配一个线程，那么它和最初的 BIO + 多线程的模式看起来结果是一样的，所以多线程 Reactor 模式还有意义吗？答案是肯定的，Reactor 模式能承载更高的并发连接，因为大部分情况下并不是所有的连接都会产生读写事件的，可能 10K 的连接只有 1K 的连接并发产生了读写，那么处理线程数就从 10K 降到了 1K，因此 Reactor 模式才能称得上高性能 I/O 模型</p><h2 id="Netty-中的线程模型"><a href="#Netty-中的线程模型" class="headerlink" title="Netty 中的线程模型"></a>Netty 中的线程模型</h2><p>Netty 支持上述的两种 Reactor 模式。首先是单线程 Reactor 模式</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup mainReactor = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);</span><br><span class="line">ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();</span><br><span class="line">bootstrap.group(mainReactor)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .localAddress(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>))</span><br><span class="line">    .childHandler(<span class="hljs-keyword">new</span> ServerHandlerInitializer());</span><br></pre></td></tr></table></figure><p>NioEventLoopGroup 实现了 ExecutorService，本身是一个线程池，所以设置 NioEventLoopGroup 线程数为 1，当 <code>bootstrap.group</code> 仅传入一个 group 时 Main Reactor 和 Sub Reactor 就会使用同个线程</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> ServerBootstrap <span class="hljs-title">group</span><span class="hljs-params">(EventLoopGroup group)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> group(group, group);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Sub Reactor 收到请求后会通过 ChannelHandler 链处理，默认情况下整个责任链传递过程都是同步的。而在多线程 Reactor 中的 Main Reactor 和 Sub Reactor 将会使用不同的 group</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoopGroup mainReactor = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);</span><br><span class="line">NioEventLoopGroup subReactor = new NioEventLoopGroup(); # 默认创建一个 CPU * 2 线程数的线程池</span><br><span class="line">ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();</span><br><span class="line">bootstrap.group(mainReactor, subReactor)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .localAddress(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8080</span>))</span><br><span class="line">    .childHandler(<span class="hljs-keyword">new</span> ServerHandlerInitializer());</span><br></pre></td></tr></table></figure><p>此时其实不算真正的多线程 Reactor，因为 ChannelHandler 此时是和 Sub Reactor 使用同个线程的。因此需要用户在实现 ChannelHandler 时使用业务线程池进行处理或使用 Netty 提供的 EventExecutorGroup 来支持</p><blockquote><p>Netty 提供的 EventExecutorGroup 会将不同的 Channel 绑定到固定的线程，后续该连接的所有请求都会在同一线程处理，因此若是为了提供并发连接的响应速度使用该线程池是可以的，但若是同个连接并发的请求（比如 HTTP2 的多路复用）是无法解决的，这时候应使用自定义线程池解决</p></blockquote><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>从 Reactor 模式对线程资源的复用也给我们了启示，在连接数比较大时应利用非阻塞 API 以及事件回调的方式来实现高性能，比如爬虫程序会产生大量的请求，可以实现基于 NIO 的异步 HttpClient 来复用线程，再比如类似 Dubbo 的 RPC 框架会维护大量的 TCP 长连接，因此这也可以通过 NIO 来复用线程。在使用 NIO 作为客户端的实践中过程中需要考虑的问题是如何找到响应对应的请求，比如 Dubbo 的实现：</p><ol><li><p>每个请求都会生成一个唯一的请求 ID（RID），然后将 Channel 保存在 DefaultFuture 中，并放入 Map 维护</p></li><li><p>通过 NIO 非阻塞接口发送请求后，根据调用模式（同步/异步）来确定是否需要阻塞当前线程</p><blockquote><p>同步调用模式下，在获取到 ResponseFuture 后由<strong>框架会自动调用 get 阻塞当前线程</strong>；异步调用模式下 Dubbo 会将 ResponseFuture 放入 RpcContext（线程上下文）交由<strong>用户自行调用</strong></p></blockquote></li><li><p>请求响应后将响应结果放入 DefaultFuture，然后唤醒阻塞线程（同步调用时）</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标准 I/O 会存在两个阶段：（以 TCP Socket 举例）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据在内核态和用户态的复制：TCP 协议栈维护着 Send Buffer（发送缓冲区）和 Recv Buffer（接收缓冲区），因此 read/write 都只是将用户态数据复制到内核态的 Socket Buffer(Send/Recv Buffer)。而 Socket Buffer 和网卡之间会通过 DMA 进行数据传输（不占用 CPU）&lt;/li&gt;
&lt;li&gt;等待数据就绪：对于 read 操作来说，就绪是指 Recv Buffer 没有可读的数据；而对于 write 操作来说，就绪是指 Send Buffer 已满无法写入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;BIO 称为同步阻塞 I/O，它在上述的两个阶段均会阻塞。因此 &lt;strong&gt;BIO 必须为每个 TCP 连接创建新线程&lt;/strong&gt;并阻塞等待其可读或可写。服务端若想支持大量客户端连接，在 BIO 的前提下使用多线程来解决是必然的事情，下面用一个简单的例子展示：&lt;/p&gt;
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Reactor" scheme="http://yoursite.com/tags/Reactor/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>DNS是如何解析主机名的</title>
    <link href="http://yoursite.com/2020/07/12/DNS%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%9A%84/"/>
    <id>http://yoursite.com/2020/07/12/DNS是如何解析主机名的/</id>
    <published>2020-07-12T13:17:29.000Z</published>
    <updated>2020-07-13T15:45:27.621Z</updated>
    
    <content type="html"><![CDATA[<p>DNS 解析的作用就是将主机名转换为 IP 地址，那么 DNS 解析过程是怎么样的，DNS 服务器又是如何快速响应全球用户的请求的呢？</p><h2 id="DNS-解析原理"><a href="#DNS-解析原理" class="headerlink" title="DNS 解析原理"></a>DNS 解析原理</h2><p>在解释 DNS 解析原理前首先需要知道的是，DNS 服务器只是一种统称，实际上 DNS 服务器的不同类型负责完全不同的功能，这对于后续理解整个原理具有非常关键的作用。下面根据 DNS 服务器功能不同主要分为 4 种类型：</p><ul><li><p><strong>根域名服务器</strong>：根域名服务器负责维护顶级域名（如 <code>.com</code>, <code>.net</code>, <code>.org</code> 等）对应的 TLD 域名服务器地址，即当客户端向其发送 DNS 解析请求时，根域名服务器会返回其顶级域名对应的 TLD 域名服务器地址。目前全球的根域名服务器的任播（Anycast）地址共有 13 个</p></li><li><p><strong>TLD 域名服务器(顶级域名服务器)</strong>：不同顶级域名由不同的托管商负责，在根域名服务器响应了 TLD 域名服务器后的域名后，用户可以在 TLD 域名服务器获取到定向到权威服务器的信息，比如返回 <code>zzcoder.cn</code> 所在的权威服务器域名</p></li><li><p><strong>权威服务器</strong>：权威服务器维护了特定顶级域名下的所有子域名（比如 <code>zzcoder.cn</code>）的 DNS 记录。比如用户在域名注册商(如 <code>DNSPod</code>)下注册 <code>zzcoder.cn</code> 实际上就是在权威服务器添加各类 DNS 记录（A 记录，CNAME 记录等等）</p></li><li><p><strong>递归解析器</strong>：递归解析器也称为 DNS 解析器。递归解析器作为客户端与 DNS 域名服务器的中间人，是面向客户端最近的一站，它负责接收客户端的 DNS 查询，并分别向<strong>根域名服务器，TLD 域名服务器，权威服务器</strong>发送解析请求，然后将最终的响应返回给客户端。常见的公开的 DNS 解析器有 Google 的 8.8.8.8, Cloudflare 的 1.1.1.1</p><blockquote><p>每个递归解析器都会内置 DNS 根域名服务器的 13 个 任播地址</p></blockquote></li></ul><a id="more"></a><p>假设我们的设备配置了 Google 的 8.8.8.8 DNS 解析器，当我们通过浏览器访问域名时，是怎么完成解析的呢？</p><ol><li>用户在浏览器中输入 <code>zzcoder.cn</code>，将向 8.8.8.8 DNS 递归解析器发送解析请求</li><li>DNS 解析器首先将顶级域名 <code>.cn</code> 向 DNS 根域名服务器请求解析返回其 TLD 域名服务器地址</li><li>DNS 解析器继续向 <code>.cn</code> 的 TLD 域名服务器请求二级域名 <code>zzcoder.cn</code> 对应的权威服务器地址</li><li>最后 DNS 解析器根据权威服务器返回的 DNS 记录响应给浏览器完成解析</li></ol><p>上面的过程可以用下面的图比较清晰的解释，1，8 是 DNS 解析器和浏览器的交互，2-7是 DNS 解析器和域名服务器交互，9-10是 浏览器和目标网站的交互</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/recursive-resolver.jpg" alt="recursive-resolver"></p><p>如果对于图观察的比较细的话可以发现 DNS 解析器和客户端的交互（1，8）与 DNS 解析器和域名服务器的交互（2-7）箭头颜色不相同，这是因为它们分别对应两种不同类型的查询：</p><ul><li><strong>递归查询</strong>：在递归查询中，DNS 客户端要求 DNS 服务器（一般为 DNS 递归解析器）将使用所请求的 DNS 记录响应客户端，即 DNS 解析器不能返回低级别域名服务器的地址，必须返回其对应的 DNS 记录</li><li><strong>迭代查询</strong>：在迭代查询中，DNS 客户端只需要 DNS 服务器返回其能够给出的最佳应答。比如 DNS 客户端向根域名服务器查询 <code>zzcoder.cn</code>，由于根域名服务器不知道权威服务器地址，因此它只需返回 <code>.cn</code> 对应的 TLD 服务器给客户端即可，后续的请求将由 DNS 客户端迭代发起</li></ul><p>在上面这个图中，浏览器（客户端）向 DNS 解析器（8.8.8.8）发起的就是递归查询，而 DNS 解析器（8.8.8.8）向域名服务器发起的就是迭代查询。因此这里要注意理解，<strong>DNS 递归解析器本身做的实际上是迭代查询</strong>。</p><blockquote><p>本地域名服务器（LDNS）也是经常被人提到的一个名词，实际上它是我们本地搭建的一个 DNS 解析器，然后在路由器或本机指向该 DNS 解析器替代 ISP 提供的 DNS 解析器或者公共 DNS 解析器。当然本地域名服务器不一定使用迭代查询，比如开源项目 smartdns 只是对 DNS 解析请求做了转发</p></blockquote><h2 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h2><p>在上面已经把 DNS 解析的核心流程描述完了，实际上在 DNS 解析过程中会存在许多缓存来进一步提高解析速度：</p><ul><li>浏览器缓存：浏览器缓存会对是 DNS 解析结果做一定的缓存，其作为 DNS 解析查询的第一步</li><li>操作系统级缓存：操作系统缓存作为是 DNS 解析的第二步，也是本地解析的最后一步。这个过程通常称为 “存根解析器”或 DNS 客户端。当存根解析器获取来自某个应用程序的请求时，其首先检查自己的缓存，以便查看是否有此记录。如果没有，则将本地网络外部的 DNS 查询（设置了递归标记）发送到 DNS 递归解析器。</li><li>路由器缓存：默认一般路由器的 DNS 常见设置是 192.168.0.1，所以 DNS 客户端实际上会往路由器发送解析请求，路由器本身并没有解析能力，它只会做一个转发以及缓存。当然这一层缓存不一定会走，比如我们可以在本机设备直接设置 DNS 服务器到 8.8.8.8 就不会走路由器了。</li></ul><p>上面的几种缓存可以说是“客户端”的缓存，此时都不涉及 DNS 服务器。实际上 DNS 递归解析器也会缓存解析信息。当路由器接收到解析请求时默认会想 ISP 提供 DNS 递归解析器发送递归查询的请求，当 ISP 内的递归解析器收到 DNS 查询时，其还将查看所请求的主机到 IP 地址转换是否已经存储在其本地持久性层中，根据其缓存中具有的记录类型，递归解析器的解析过程会有所不同，比如：</p><ul><li>如果此时解析器已存在其对应的权威域名服务器的 NS 记录（比如已经知道了 <code>zzcoder.cn</code> 所在权威服务器的地址 f1g1ns2.dnspod.net），那么此时解析器只需要向 f1g1ns2.dnspod.net 请求解析即可</li><li>如果此时解析器已存在对应的 TLD 服务器（比如 <code>.cn</code>）的地址，那么只需要请求 TLD 服务器和权威服务器即可</li><li>如果此时解析器没有对应 TLD 服务器的记录，才会额外查询根域名服务器</li></ul><h2 id="DNS-记录"><a href="#DNS-记录" class="headerlink" title="DNS 记录"></a>DNS 记录</h2><p>上面说的权威服务器保存了 DNS 记录，那么 DNS 记录是什么呢？常见的是 A 记录，CNAME 记录等，如下表所示：</p><table><thead><tr><th style="text-align:left">记录类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>A</code></td><td style="text-align:left">地址记录，用于将主机名映射到其 IPv4 地址。</td></tr><tr><td style="text-align:left"><code>AAAA</code></td><td style="text-align:left">IPv6 地址记录，用于将主机名映射到其 IPv6 地址。</td></tr><tr><td style="text-align:left"><code>MX</code></td><td style="text-align:left">邮件交换记录，用于将请求路由到邮件服务器。</td></tr><tr><td style="text-align:left"><code>NS</code></td><td style="text-align:left">域名服务器记录，用于将 DNS 委托给权威服务器。</td></tr><tr><td style="text-align:left"><code>CNAME</code></td><td style="text-align:left">规范名称记录，用于指定别名。</td></tr></tbody></table><p>还有一种比较特殊的记录叫做胶水记录，胶水记录也是在域名注册商处创建的 DNS 记录。一般为域名服务器对应的 IP 地址</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">λ zhang [~] → dig zzcoder.cn @<span class="hljs-number">198.41</span>.0.4</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG <span class="hljs-number">9.10</span>.6 &lt;&lt;&gt;&gt; zzcoder.cn @<span class="hljs-number">198.41</span>.0.4</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: <span class="hljs-number">57204</span></span><br><span class="line">;; flags: qr rd; QUERY: <span class="hljs-number">1</span>, ANSWER: <span class="hljs-number">0</span>, AUTHORITY: <span class="hljs-number">8</span>, ADDITIONAL: <span class="hljs-number">11</span></span><br><span class="line">;; WARNING: recursion requested but not available</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: <span class="hljs-number">0</span>, flags:; udp: <span class="hljs-number">4096</span></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;zzcoder.cn.INA</span><br><span class="line"></span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">cn.<span class="hljs-number">172800</span>INNSc.dns.cn.</span><br><span class="line">cn.<span class="hljs-number">172800</span>INNSg.dns.cn.</span><br><span class="line">cn.<span class="hljs-number">172800</span>INNSb.dns.cn.</span><br><span class="line">cn.<span class="hljs-number">172800</span>INNSns.cernet.net.</span><br><span class="line">cn.<span class="hljs-number">172800</span>INNSe.dns.cn.</span><br><span class="line">cn.<span class="hljs-number">172800</span>INNSf.dns.cn.</span><br><span class="line">cn.<span class="hljs-number">172800</span>INNSa.dns.cn.</span><br><span class="line">cn.<span class="hljs-number">172800</span>INNSd.dns.cn.</span><br><span class="line"></span><br><span class="line">;; ADDITIONAL SECTION:</span><br><span class="line">c.dns.cn.<span class="hljs-number">172800</span>INA<span class="hljs-number">203.119</span>.27.1</span><br><span class="line">g.dns.cn.<span class="hljs-number">172800</span>INA<span class="hljs-number">66.198</span>.183.65</span><br><span class="line">b.dns.cn.<span class="hljs-number">172800</span>INA<span class="hljs-number">203.119</span>.26.1</span><br><span class="line">ns.cernet.net.<span class="hljs-number">172800</span>INA<span class="hljs-number">202.112</span>.0.44</span><br><span class="line">e.dns.cn.<span class="hljs-number">172800</span>INA<span class="hljs-number">203.119</span>.29.1</span><br><span class="line">f.dns.cn.<span class="hljs-number">172800</span>INA<span class="hljs-number">195.219</span>.8.90</span><br><span class="line">a.dns.cn.<span class="hljs-number">172800</span>INA<span class="hljs-number">203.119</span>.25.1</span><br><span class="line">a.dns.cn.<span class="hljs-number">172800</span>INAAAA<span class="hljs-number">2001</span>:dc7::<span class="hljs-number">1</span></span><br><span class="line">d.dns.cn.<span class="hljs-number">172800</span>INA<span class="hljs-number">203.119</span>.28.1</span><br><span class="line">d.dns.cn.<span class="hljs-number">172800</span>INAAAA<span class="hljs-number">2001</span>:dc7:<span class="hljs-number">1000</span>::<span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line">;; Query time: <span class="hljs-number">220</span> msec</span><br><span class="line">;; SERVER: 198.41.0.4#53(198.41.0.4)</span><br><span class="line">;; WHEN: Sun Jul <span class="hljs-number">12</span> <span class="hljs-number">22</span>:<span class="hljs-number">45</span>:<span class="hljs-number">20</span> CST <span class="hljs-number">2020</span></span><br><span class="line">;; MSG SIZE  rcvd: <span class="hljs-number">366</span></span><br></pre></td></tr></table></figure><p>上述是对根域名服务器发起 DNS 解析请求，其中返回的 ADDITIONAL SECTION 会包含每个 TLD 服务器域名对应的 A 记录或 AAAA 记录，这些就是胶水记录。为什么需要它们呢？因为 DNS 解析过程中，无法通过域名来访问域名服务器，如果没有胶水记录，就需要额外根据域名服务器的域名先获取到域名服务器的 IP，这样才能进一步获取目标域名的 IP，因此域名服务器在向更高级别的域名服务器提供本地的域名的时候还会提供对应 IP 地址，以便在后续的 DNS 解析时防止出现循环。</p><h2 id="DNS-的常见攻击"><a href="#DNS-的常见攻击" class="headerlink" title="DNS 的常见攻击"></a>DNS 的常见攻击</h2><p>DNS 是一种基于 UDP 的应用层协议，容易出现伪造，放大等攻击，以下是 DNS 比较常见的攻击：</p><ul><li><p>DNS 缓存投毒（污染）：这是将伪造的 DNS 数据引入 DNS 解析器缓存中的攻击，其将导致解析器返回域的错误 IP 地址。本质上攻击者只需要监听域名查询请求，一旦发现目标域名即可将自己伪装成目标域名的权威域名服务器返回虚假的查询结果，而 DNS 解析器一般都会有缓存机制，因此这个域名在 DNS 解析器缓存中就被污染了。</p><blockquote><p>UDP 其中的一个特点是没有验证机制，非常容易伪装，当系统将 DNS 查询请求发出后，系统会接受第一个返回的结果作为使用，其后的将会被抛弃。因此投毒服务器只要快于真正的权威域名服务器返回即可</p></blockquote></li><li><p>DNS 劫持：DNS 劫持的结果和 DNS 污染的结果类似，会返回虚假的解析结果，但是攻击手段不同，<strong>其目标是域名服务器上网站的 DNS 记录，而不是解析器的缓存</strong>。比如篡改 hosts 文件，ISP 对修改某些 DNS 解析记录，篡改DNS权威记录指向自己的恶意服务器以实现DNS劫持等等</p></li><li><p>DNS放大攻击：攻击者通常使用僵尸网络向公用的 DNS 解析器发送大量 DNS 查询请求，并伪造 IP 地址来源设置为受害者，再利用放大效果（比如发送者给 DNS 解析器 10 个字节，DNS 解析器返回 100 个字节），这样受害者的服务将收到大量且并不需要的 DNS 响应从而导致其崩溃，这也是 DDos 攻击的一种类型</p></li></ul><p>DNS 污染问题不是不可避免的，比如现在流行的 DNSSEC 协议，DNSSEC 通过基于<strong>公共密钥加密</strong>的<strong>数字签名</strong>在 DNS 协议中新增了两项重要功能：</p><ul><li><strong>数据来源验证</strong> - 解析器可以通过加密的方式验证收到的数据是否确实来自其认定的数据传送区域。</li><li><strong>数据完整性保护</strong> - 解析器可以确信，自区域所有者使用区域私钥初次进行数据签名以来，数据在传输过程中并未遭到修改。</li></ul><p>篇幅原因这里不对该协议深入，有兴趣的人可以去研究更详细的原理</p><h2 id="Anycast-DNS"><a href="#Anycast-DNS" class="headerlink" title="Anycast DNS"></a>Anycast DNS</h2><p>之前提到目前全球的根域名服务器的任播（Anycast）地址共有 13 个，那么任播代表什么呢，又为什么需要任播呢？其实很简单，一般来说一个 IP 地址对应一个服务器，如果全世界只有 13 台服务器如果高性能的处理全世界的请求以及各种恶意攻击呢？再比如，公开的 DNS 解析器如 1.1.1.1 只需要一个 IP 却用来响应全球的所有请求，如果只有一台服务器如何支持这么高的并发呢？在 Anycast 中，一个 IP 地址可以应用于许多服务器。Anycast DNS 意味着一组 DNS 服务器中的任何一台都可以响应 DNS 查询，通常由地理位置最接近的一台提供响应。</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/anycast-dns.svg" alt="anycast-dns"></p><p>这样的好处有几个：</p><ul><li>Anycast 网络对一个 IP 地址的请求可以由许多服务器答复，可以解决单台服务器的单点问题</li><li>Anycast 具有负载均衡能力，根据网络情况选择地理位置最接近的一台提供响应，有效减少响应延迟</li><li>Anycast 网络可以提供 DDoS 防护，因为流量可以分散到整个集群</li></ul><h2 id="DNS-智能解析"><a href="#DNS-智能解析" class="headerlink" title="DNS 智能解析"></a>DNS 智能解析</h2><p>如果使用 DNSPod（国内比较流行的域名解析厂商）就会发现它允许我们为同个域名设置多个 IP，并且允许设置在不同网络返回不同的 IP（比如国内/国外），那么它是怎么做到的呢？其实本质上 DNSPod 作为权威域名服务器它只需要知道请求解析的来源 IP 就可以根据地区来返回不同的 IP。因此类似 8.8.8.8 这样的 DNS 解析器在请求权威服务器的时候需要传入请求者 IP 这样就能完成智能解析，而这就是 EDNS 协议（edns-client-subnet）。它是一个  DNS 扩展协议，允许 DNS 解析器传递用户的 IP 地址给 Authoritative DNS server。DNSPod 支持了这种协议因此能够完成智能解析。比如我将 <code>auto.zzcoder.cn</code> 的境内解析到 <code>6.4.7.8</code>，境外解析到 <code>9.8.3.4</code>，此时分别通过国外/国内客户端 IP 来访问，并使用阿里 DNS 服务器 <code>223.6.6.6</code> 进行解析就会返回不同的结果</p><figure class="highlight shell hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">λ zhang [~] → dig auto.zzcoder.cn +subnet=199.193.127.121 @223.6.6.6</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; auto.zzcoder.cn +subnet=199.193.127.121 @223.6.6.6</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 49896</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 1408</span><br><span class="line">; CLIENT-SUBNET: 199.193.127.121/32/24</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;auto.zzcoder.cn.INA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">auto.zzcoder.cn.600INA9.8.3.4</span><br><span class="line"></span><br><span class="line">;; Query time: 40 msec</span><br><span class="line">;; SERVER: 223.6.6.6#53(223.6.6.6)</span><br><span class="line">;; WHEN: Mon Jul 13 23:33:30 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 72</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">λ zhang [~] → dig auto.zzcoder.cn +subnet=122.231.108.109 @223.6.6.6</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; auto.zzcoder.cn +subnet=122.231.108.109 @223.6.6.6</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 20362</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 1408</span><br><span class="line">; CLIENT-SUBNET: 122.231.108.109/32/24</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;auto.zzcoder.cn.INA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">auto.zzcoder.cn.600INA6.4.7.8</span><br><span class="line"></span><br><span class="line">;; Query time: 52 msec</span><br><span class="line">;; SERVER: 223.6.6.6#53(223.6.6.6)</span><br><span class="line">;; WHEN: Mon Jul 13 23:33:41 CST 2020</span><br><span class="line">;; MSG SIZE  rcvd: 72</span><br></pre></td></tr></table></figure><blockquote><p>不是所有的 DNS 解析器和权威服务器都支持 EDNS</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DNS 解析的作用就是将主机名转换为 IP 地址，那么 DNS 解析过程是怎么样的，DNS 服务器又是如何快速响应全球用户的请求的呢？&lt;/p&gt;
&lt;h2 id=&quot;DNS-解析原理&quot;&gt;&lt;a href=&quot;#DNS-解析原理&quot; class=&quot;headerlink&quot; title=&quot;DNS 解析原理&quot;&gt;&lt;/a&gt;DNS 解析原理&lt;/h2&gt;&lt;p&gt;在解释 DNS 解析原理前首先需要知道的是，DNS 服务器只是一种统称，实际上 DNS 服务器的不同类型负责完全不同的功能，这对于后续理解整个原理具有非常关键的作用。下面根据 DNS 服务器功能不同主要分为 4 种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;根域名服务器&lt;/strong&gt;：根域名服务器负责维护顶级域名（如 &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.net&lt;/code&gt;, &lt;code&gt;.org&lt;/code&gt; 等）对应的 TLD 域名服务器地址，即当客户端向其发送 DNS 解析请求时，根域名服务器会返回其顶级域名对应的 TLD 域名服务器地址。目前全球的根域名服务器的任播（Anycast）地址共有 13 个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;TLD 域名服务器(顶级域名服务器)&lt;/strong&gt;：不同顶级域名由不同的托管商负责，在根域名服务器响应了 TLD 域名服务器后的域名后，用户可以在 TLD 域名服务器获取到定向到权威服务器的信息，比如返回 &lt;code&gt;zzcoder.cn&lt;/code&gt; 所在的权威服务器域名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;权威服务器&lt;/strong&gt;：权威服务器维护了特定顶级域名下的所有子域名（比如 &lt;code&gt;zzcoder.cn&lt;/code&gt;）的 DNS 记录。比如用户在域名注册商(如 &lt;code&gt;DNSPod&lt;/code&gt;)下注册 &lt;code&gt;zzcoder.cn&lt;/code&gt; 实际上就是在权威服务器添加各类 DNS 记录（A 记录，CNAME 记录等等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;递归解析器&lt;/strong&gt;：递归解析器也称为 DNS 解析器。递归解析器作为客户端与 DNS 域名服务器的中间人，是面向客户端最近的一站，它负责接收客户端的 DNS 查询，并分别向&lt;strong&gt;根域名服务器，TLD 域名服务器，权威服务器&lt;/strong&gt;发送解析请求，然后将最终的响应返回给客户端。常见的公开的 DNS 解析器有 Google 的 8.8.8.8, Cloudflare 的 1.1.1.1&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个递归解析器都会内置 DNS 根域名服务器的 13 个 任播地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机通信" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
      <category term="UDP" scheme="http://yoursite.com/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议与无状态</title>
    <link href="http://yoursite.com/2020/05/31/HTTP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%97%A0%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2020/05/31/HTTP协议与无状态/</id>
    <published>2020-05-31T12:51:47.000Z</published>
    <updated>2020-06-07T08:14:20.779Z</updated>
    
    <content type="html"><![CDATA[<p>大家常提起 HTTP 协议是无状态的，其指代的“无状态”是什么？常见的观点有：</p><ul><li>无状态代表相同的请求参数总是能返回相同的结果</li><li>HTTP 本身的设计是无状态的，增加了有状态协议头（Cookie/Session）后变成了有状态协议</li></ul><p>对于第一个观点显而易见是错误的，它的表示更倾向于“幂等性”，这往往无法由协议本身保证，还需要服务器进行“有状态”的响应（若服务器不进行状态的持久化，当然无法做到幂等）；而第二个观点听起来就靠谱很多，通过 Cookie/Session 进行状态维护从而保证了有状态。但我们可以考虑下 Cookie 或 Session 保证的是谁的状态？一般情况下，它们保证了后端服务器的状态，而非 HTTP 协议的状态。因此对于最初的问题 <em>HTTP 协议的”无状态“</em>，我们是不是应该从协议的本身出发呢？</p><a id="more"></a><h1 id="什么是”无状态“协议"><a href="#什么是”无状态“协议" class="headerlink" title="什么是”无状态“协议"></a>什么是”无状态“协议</h1><p>对于”有状态“协议来说，多次请求间往往包含关联，就比如之前提到的服务端依赖 Cookie/Session 进行状态维护来保证关联，但区别在于有状态协议的状态维护应由协议本身来保证，换句话说，<code>“有状态”协议本身存在会话（Session），一般和连接绑定的</code>。比如 TCP 连接，传输双方是需要进行”有状态“交互（双方在三次握手后均进行状态信息的保存），且会话会随着连接断开而结束。反过来说，<code>“无状态”协议本身不存在会话概念，其每个请求无论在哪个连接都是完全独立且正确的（即不会和先前的请求产生关联）</code>。</p><blockquote><p>Cookie/Session 所带来的会话不属于协议本身的状态，协议本身也无法应用这些状态。这种状态可以理解为应用程序基于协议实现的”有状态“应用</p></blockquote><p>众所周知 HTTP 协议是利用 TCP 进行数据传输的，那么是否利用 TCP 进行数据传输的协议都是”有状态“协议呢？当然不是，因为它们本身并没有强关联，HTTP 并不是基于 TCP 的协议，它们处于 OSI 的不同层次（HTTP 协议属于应用层协议，TCP 协议属于传输层协议），如果你想的话，也通过命名管道提供 HTTP 服务，因此<code>即使 TCP 协议是“有状态”的，也不能以此判断 HTTP 协议也是“有状态”的</code>。</p><blockquote><p>HTTPS 协议本质上是在应用层和传输层中间加入了 SSL 协议（严格来说，HTTPS 协议不算单独的协议），SSL 协议本身也需要通过握手（身份验证）来保持会话，因此 SSL 协议也是”有状态“协议</p></blockquote><h1 id="HTTP-协议是”无状态“协议吗？"><a href="#HTTP-协议是”无状态“协议吗？" class="headerlink" title="HTTP 协议是”无状态“协议吗？"></a>HTTP 协议是”无状态“协议吗？</h1><p>分清楚”有状态“/”无状态“协议后，我们可以分析一下 HTTP 协议是否为”无状态“协议：</p><ul><li><p>HTTP/1.0 时代每个 TCP 连接只能发送一个请求，因此无法在连接中产生会话的概念，显而易见 <code>HTTP/1.0 协议属于“无状态”协议</code>。</p></li><li><p>HTTP/1.1 时代引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用。但此时的连接复用仅仅是为了提高传输效率，keep-alive 的默认情况下，它的若干个请求会排队串行化单线程处理，即后面的请求等待前面请求的返回才能获得执行机会，除此之外没有任何优化，因此 <code>HTTP/1.1 协议也属于“无状态”协议</code>。</p><blockquote><p>HTTP/1.1 实际上还支持 pipeline，即连续发送一组没有相互依赖的请求而不必等到上一个请求先结束，但它仍然存在线头阻塞的问题（响应仍然得串行化），使用这项特性需要浏览器支持，且仍然没有对会话的支持</p></blockquote></li><li><p>HTTP/2.0 时代的报头压缩（HPACK，即客户端和服务器都维护之前看见的标头字段的列表），GOAWAY 帧或流控的特性都标志着会话的诞生，因此 <code>HTTP/2.0 协议属于“有状态”协议</code>。</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://en.wikipedia.org/wiki/Stateless_protocol" target="_blank" rel="noopener">Stateless protocol</a></li><li><a href="https://tools.ietf.org/html/rfc7540#section-5.1" target="_blank" rel="noopener">HTTP/2.0 Stream States</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家常提起 HTTP 协议是无状态的，其指代的“无状态”是什么？常见的观点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无状态代表相同的请求参数总是能返回相同的结果&lt;/li&gt;
&lt;li&gt;HTTP 本身的设计是无状态的，增加了有状态协议头（Cookie/Session）后变成了有状态协议&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于第一个观点显而易见是错误的，它的表示更倾向于“幂等性”，这往往无法由协议本身保证，还需要服务器进行“有状态”的响应（若服务器不进行状态的持久化，当然无法做到幂等）；而第二个观点听起来就靠谱很多，通过 Cookie/Session 进行状态维护从而保证了有状态。但我们可以考虑下 Cookie 或 Session 保证的是谁的状态？一般情况下，它们保证了后端服务器的状态，而非 HTTP 协议的状态。因此对于最初的问题 &lt;em&gt;HTTP 协议的”无状态“&lt;/em&gt;，我们是不是应该从协议的本身出发呢？&lt;/p&gt;
    
    </summary>
    
      <category term="计算机通信" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>揭开try-catch-finally的神秘面纱</title>
    <link href="http://yoursite.com/2020/05/17/%E6%8F%AD%E5%BC%80try-catch-finally%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1/"/>
    <id>http://yoursite.com/2020/05/17/揭开try-catch-finally的神秘面纱/</id>
    <published>2020-05-17T14:53:17.000Z</published>
    <updated>2020-05-18T14:32:17.092Z</updated>
    
    <content type="html"><![CDATA[<p>根据 <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html" target="_blank" rel="noopener">JDK Tutorial</a> 的描述，除非在执行 try 或 catch 代码时线程被中断或 JVM 退出，finally 中的逻辑始终会执行。因此 finally 关键字常被用于释放资源，防止程序出现异常时出现资源泄露。本文主要探讨其在 JVM 层面的实现原理，以及 synchronized 关键字在类似场景的处理手段。首先来看一段简单的 try-finally 代码</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWithTryFinally</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"try"</span>);</span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"finally"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其对应字节码如下</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stack=2, locals=2, args_size=1</span><br><span class="line">    0: getstatic      #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    3: ldc            #6                  // String try</span><br><span class="line">    5: invokevirtual  #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    8: getstatic      #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    11: ldc           #8                  // String finally</span><br><span class="line">    13: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    16: goto          30</span><br><span class="line">    19: astore_1</span><br><span class="line">    20: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    23: ldc           #8                  // String finally</span><br><span class="line">    25: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    28: aload_1</span><br><span class="line">    29: athrow</span><br><span class="line">    30: return</span><br><span class="line">Exception table:</span><br><span class="line">    from    to  target type</span><br><span class="line">       0     8    19   any</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>0 - 8 行是 try 中的语句</li><li>8 - 13，20 - 25 行是 finally 中的语句</li></ul><p>那么为什么 finally 语句会出现两遍呢？其实这两次分别对应程序正常执行和异常执行的情况，8 - 13 行是在正常执行时会执行的 finally 语句，执行完成后通过 16 行的 <code>goto</code> 指令跳转到 <code>return</code> 指令返回；而 20 - 25 行则是由异常表（Exception table）进行触发，可以看到异常表会捕捉 0 - 8 行（不包含第8行）的字节码出现的任意异常，并且跳转至 19 行开始执行 finally 语句，最后通过 29 行 <code>athrow</code> 指令向上抛出异常。</p><p>那么如果增加 catch 呢，会有什么区别吗？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWithTryCatchFinally</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">      System.out.println(<span class="hljs-string">"try"</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      System.out.println(<span class="hljs-string">"catch"</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(<span class="hljs-string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其字节码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">stack=2, locals=3, args_size=1</span><br><span class="line">    0: getstatic      #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    3: ldc            #6                  // String try</span><br><span class="line">    5: invokevirtual  #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    8: getstatic      #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    11: ldc           #8                  // String finally</span><br><span class="line">    13: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    16: goto          50</span><br><span class="line">    19: astore_1</span><br><span class="line">    20: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    23: ldc           #10                 // String catch</span><br><span class="line">    25: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    28: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    31: ldc           #8                  // String finally</span><br><span class="line">    33: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    36: goto          50</span><br><span class="line">    39: astore_2</span><br><span class="line">    40: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    43: ldc           #8                  // String finally</span><br><span class="line">    45: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    48: aload_2</span><br><span class="line">    49: athrow</span><br><span class="line">    50: return</span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            0     8    19   Class java/lang/Exception</span><br><span class="line">            0     8    39   any</span><br><span class="line">            19    28   39   any</span><br></pre></td></tr></table></figure><ul><li>0 - 5 行是 try 中的语句</li><li>20 - 25 行是 catch 中的语句</li><li>8 - 13,   28 - 33, 40 - 45 行是 finally 中的语句</li></ul><p>大体上和之前逻辑相同，只不过这里 finally 中的语句又赋予了 catch 一遍，所以被 catch 后也能执行 finally 语句。根据上面两个例子，我们也验证了 <a href="https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html" target="_blank" rel="noopener">JDK Tutorial</a> 的描述，即<strong>除非在执行 try 或 catch 代码时线程被中断或 JVM 退出，finally 中的逻辑始终会执行。</strong></p><h1 id="包含控制语句的-try-finally"><a href="#包含控制语句的-try-finally" class="headerlink" title="包含控制语句的 try-finally"></a>包含控制语句的 try-finally</h1><p>不知道大家有没有注意到，finally 语句的字节码前后总会出现 <code>astore</code>/<code>aload</code> 这样成对的指令，它们的作用是什么呢？根据指令本身的含义，我们可以知道</p><ul><li><code>astore</code> 是将操作数栈顶存储到局部变量表</li><li><code>aload</code> 是将局部变量加载到操作数栈，以便后续 <code>ireturn</code> 指令将栈顶的值返回给方法调用者</li></ul><p>它在我们分析包含控制转移语句（比如 return）的 try-catch-finally 有着至关重要的作用。举一个包含控制语句的 try-finally 的例子</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">testWithTryReturnFinally</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># output: 0</span><br></pre></td></tr></table></figure><p>其字节码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stack=1, locals=4, args_size=1</span><br><span class="line">    0: iconst_0</span><br><span class="line">    1: istore_1</span><br><span class="line">    2: iload_1</span><br><span class="line">    3: istore_2</span><br><span class="line">    4: iinc           1, 1</span><br><span class="line">    7: iload_2</span><br><span class="line">    8: ireturn</span><br><span class="line">    9: astore_3</span><br><span class="line">    10: iinc          1, 1</span><br><span class="line">    13: aload_3</span><br><span class="line">    14: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     4     9   any</span><br></pre></td></tr></table></figure><ul><li>0：将常量 0 加载到操作数栈</li><li>1：将栈顶 int 数值存入第 2 局部变量（其中由于这里是方法调用，第 1 局部变量被调用方执行 <code>invokevirtual</code> 指令将对象的引用隐式的传进来了），此时第 2 局部变量的值为 0</li><li>2：将第 2 局部变量（0）的值加载到操作数栈</li><li>3：<strong>将栈顶的值存入第 3 局部变量（这里开始了 finally 的逻辑），这里相当于对 try 中的结果做了一次备份</strong>，此时第 3 局部变量的值为 0</li><li>4：将第 2 局部变量（0）的值加 1</li><li>7：<strong>加载第 3 局部变量的值到操作数栈（finally 语句结束），这里取出的是之前备份的值</strong></li><li>8：返回栈顶元素，此时由于栈顶是执行 finally 前备份的值，所以值为 0 </li><li>9：将栈顶的异常对象存入第 4 局部变量（进入到该阶段的指令一般由异常表触发，所以此时栈顶是异常对象）</li><li>10：将第 2 局部变量（0）的值加 1</li><li>13：将第 4 局部变量（异常对象）加载到操作数栈</li><li>14：将栈顶（异常对象）抛出</li></ul><p>上述解释将对于最终返回结果比较重要的 3 和 7 指令进行了加粗，它展示了<strong>虽然 finally 语句会执行，但是它的计算结果不一定会影响到返回值</strong>，所以这里是容易被误解的地方，平常要避免这样使用。</p><p>那么是不是说放在 finally 中的计算都不会影响到 return 的结果呢？那当然不是，比如 return 不在 try 中，那么自然是会影响的，而如果 return 如果在 finally 中，又是什么样一种结果呢？比如：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">testWithTryReturnFinally</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># output: 1</span><br></pre></td></tr></table></figure><p>其字节码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stack=1, locals=4, args_size=1</span><br><span class="line">    0: iconst_0</span><br><span class="line">    1: istore_1</span><br><span class="line">    2: iload_1</span><br><span class="line">    3: istore_2</span><br><span class="line">    4: iinc           1, 1</span><br><span class="line">    7: iload_1</span><br><span class="line">    8: ireturn</span><br><span class="line">    9: astore_3</span><br><span class="line">    10: iinc          1, 1</span><br><span class="line">    13: iload_1</span><br><span class="line">    14: ireturn</span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            2     4     9   any</span><br></pre></td></tr></table></figure><p>看 7 和 13 指令，这里和刚才的有比较大的区别，它们用于返回的 iload_1 是原本的值（非备份），因此返回的结果是 1。当然还有一个更重要的区别是：<strong>在 finally 中使用了 return 后丢失了 <code>athrow</code>，这意味着 try 中抛出的异常会丢失</strong>（finally 中抛出的异常仍然会继续抛出），这是一个比较严重的问题。这里使用一个例子演示一下：</p><figure class="highlight hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">testWithTryReturnFinallyException</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line">  <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">true</span>) &#123;</span><br><span class="line">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="hljs-keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># output: 1</span><br></pre></td></tr></table></figure><p>上述代码并不会抛出异常，而是返回 1。所以 finally 中要避免使用 return，否则会得到意想不到的结果。经过上述几个例子，现在对 try-catch-finally 做了一个总结：</p><ol><li>除非在执行 try 或 catch 代码时线程被中断或 JVM 退出，否则 finally 中的逻辑始终会执行</li><li>finally 语句块会在 try block 的控制转移语句（如 return）之前执行，但不会影响最终返回的结果，除非 finally 抛出了异常或使用了 return 等控制转移语句</li><li>避免在 finally 中使用 return，这会导致 try block 中的异常被丢失</li></ol><h1 id="synchronized-如何保证始终执行-monitorexit"><a href="#synchronized-如何保证始终执行-monitorexit" class="headerlink" title="synchronized 如何保证始终执行 monitorexit"></a>synchronized 如何保证始终执行 monitorexit</h1><p>我们都知道 synchronized 对于同步语句块会使用 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令，那么它们如何保证退出时始终执行 <code>monitorexit</code> 呢？答案其实和 finally 类似，我们举个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWithSync</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"sync"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其字节码如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">stack=2, locals=3, args_size=1</span><br><span class="line">    0: aload_0</span><br><span class="line">    1: dup</span><br><span class="line">    2: astore_1</span><br><span class="line">    3: monitorenter</span><br><span class="line">    4: getstatic     #5                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">    7: ldc           #6                  // String sync</span><br><span class="line">    9: invokevirtual #7                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">    12: aload_1</span><br><span class="line">    13: monitorexit</span><br><span class="line">    14: goto          22</span><br><span class="line">    17: astore_2</span><br><span class="line">    18: aload_1</span><br><span class="line">    19: monitorexit</span><br><span class="line">    20: aload_2</span><br><span class="line">    21: athrow</span><br><span class="line">    22: return</span><br><span class="line">    Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            4    14    17   any</span><br><span class="line">            17   20    17   any</span><br></pre></td></tr></table></figure><p>根据异常表可知即使同步块内容出现异常（4 - 14），仍然会跳转至 17 完成 <code>monitorexit</code> 的执行，这不就是 finally 的执行过程吗。但是这里相对 finally 有一个特殊的地方就是异常表对 17 - 20 行出现异常的情况进行了无限循环，而 17 - 20 行实际上就是执行 <code>monitorexit</code> 的过程，也就是说一旦 <code>monitorexit</code> 抛出异常，那么线程就会进入无限循环。根据 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit" target="_blank" rel="noopener">The Java Virtual Machine Instruction Set</a> 介绍，<code>monitorexit</code> 会存在抛出 NullPointerException 和 IllegalMonitorStateException 两种异常，这就证明确实会存在无限循环的可能性。</p><blockquote><p>If <em>objectref</em> is <code>null</code>, <em>monitorexit</em> throws a <code>NullPointerException</code>.</p><p>Otherwise, if the thread that executes <em>monitorexit</em> is not the owner of the monitor associated with the instance referenced by <em>objectref</em>, <em>monitorexit</em> throws an <code>IllegalMonitorStateException</code>.</p><p>Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10" target="_blank" rel="noopener">§2.11.10</a> and if the second of those rules is violated by the execution of this <em>monitorexit</em> instruction, then <em>monitorexit</em> throws an <code>IllegalMonitorStateException</code>.</p></blockquote><p>那么这合理吗？在 2002 年就有一个 Bug 描述 <a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4414101" target="_blank" rel="noopener">JDK-4414101 : synchronized statement generates catch around the monitorexit</a> 被提交，但最终被标记为非 bug。回答者认为无限循环是一个正确的行为，因为同步代码块的退出始终需要伴随着 monitor 的释放，一旦做不到这一点那么将线程放入无限循环中比执行其他操作更正确</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据 &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JDK Tutorial&lt;/a&gt; 的描述，除非在执行 try 或 catch 代码时线程被中断或 JVM 退出，finally 中的逻辑始终会执行。因此 finally 关键字常被用于释放资源，防止程序出现异常时出现资源泄露。本文主要探讨其在 JVM 层面的实现原理，以及 synchronized 关键字在类似场景的处理手段。首先来看一段简单的 try-finally 代码&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testWithTryFinally&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;try&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;finally&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的避免空指针</title>
    <link href="http://yoursite.com/2020/02/05/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2020/02/05/如何优雅的避免空指针/</id>
    <published>2020-02-05T14:07:27.000Z</published>
    <updated>2020-02-06T05:30:57.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NPESolution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withIf</span><span class="hljs-params">(Person person)</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(person != <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">            <span class="hljs-comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withSpringAssert</span><span class="hljs-params">(Person person)</span></span>&#123;</span><br><span class="line">        Assert.isTrue(person != <span class="hljs-keyword">null</span>, <span class="hljs-string">"person must be not null."</span>);</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withOptional</span><span class="hljs-params">(Person person)</span></span>&#123;</span><br><span class="line">        Optional&lt;Person&gt; personOptional = Optional.ofNullable(person);</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withJsr305Annotation</span><span class="hljs-params">(@Nonnull Person person)</span></span>&#123;</span><br><span class="line">        Optional&lt;Person&gt; personOptional = Optional.of(person);</span><br><span class="line">        <span class="hljs-comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码是我在日常用于避免空指针（<code>NPE</code>）的常用方式，很长时间内我都热衷于断言（<code>Assert</code>）这类防御性编程方式，防御性编程可以有效的保证方法的输入条件，并在毫无意义的边界情况能够给出有效的提示，何乐而不为呢？事实上防御性编程也确实是一种非常推荐的方式，并且其在 Spring 源码中随处可见。而 JDK8 的 <code>Optional</code> 是否会是一种更优雅的方式呢？亦或许，另有它人？</p><a id="more"></a><p>if 语句是初学者最常使用的处理空指针的方式，直至今日它也在大多数场景被推荐使用。即使是如此简单的方式，其实也可以略微优化。下面是一个使用 if 语句的例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(person == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> ...;</span><br></pre></td></tr></table></figure><p>在现实业务中我们难以避免地会需要解决分支，<code>if-else</code> 是大多数人常用的方式。但是如果分支内部又产生了分支，我们的代码可读性就会大大的降低，因此这里提到的技巧就是“及时终止”。何谓“及时终止”，简单来说就是通过提前终止代码逻辑来减少嵌套 <code>if-else</code> 的复杂度。优化后的代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span>(person == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">  <span class="hljs-comment">// ...</span></span><br><span class="line">  <span class="hljs-keyword">return</span> ...;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ...</span></span><br><span class="line"><span class="hljs-keyword">return</span> ...;</span><br></pre></td></tr></table></figure><p>既然 if 语句已经能够解决空指针问题，那么为什么 Spring 这类开源项目要使用 <code>Assert</code> 呢？原因在于真实业务场景中，空指针这类的边界条件非常多，并且它很有可能对业务方法的毫无意义，因此使用 <code>Assert</code> 的方式会显得清晰明了，如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// org.springframework.validation.beanvalidation.SpringValidatorAdapter</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringValidatorAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartValidator</span>, <span class="hljs-title">javax</span>.<span class="hljs-title">validation</span>.<span class="hljs-title">Validator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * Create a new SpringValidatorAdapter for the given JSR-303 Validator.</span></span><br><span class="line"><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> targetValidator the JSR-303 Validator to wrap</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringValidatorAdapter</span><span class="hljs-params">(javax.validation.Validator targetValidator)</span> </span>&#123;</span><br><span class="line">Assert.notNull(targetValidator, <span class="hljs-string">"Target Validator must not be null"</span>);</span><br><span class="line"><span class="hljs-keyword">this</span>.targetValidator = targetValidator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T object, Class&lt;?&gt;... groups) &#123;</span><br><span class="line">Assert.state(<span class="hljs-keyword">this</span>.targetValidator != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No target Validator set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.targetValidator.validate(object, groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateProperty(T object, String propertyName, Class&lt;?&gt;... groups) &#123;</span><br><span class="line">Assert.state(<span class="hljs-keyword">this</span>.targetValidator != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No target Validator set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.targetValidator.validateProperty(object, propertyName, groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-keyword">public</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(</span><br><span class="line">Class&lt;T&gt; beanType, String propertyName, Object value, Class&lt;?&gt;... groups) &#123;</span><br><span class="line"></span><br><span class="line">Assert.state(<span class="hljs-keyword">this</span>.targetValidator != <span class="hljs-keyword">null</span>, <span class="hljs-string">"No target Validator set"</span>);</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.targetValidator.validateValue(beanType, propertyName, value, groups);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 <code>Assert</code> 这类防御性编程方式的缺陷也非常明显，业务逻辑中会存在大量的判空逻辑，通过 <code>Assert</code> 代替 if 语句的方式会使得方法内部存在大量的防御性代码，这并不能提高代码质量，因此 <strong>防御性代码常用于输入参数校验</strong>。而<strong>业务逻辑中的 <code>NPE</code> 解决方案应该是 <code>Optional</code> 类</strong>，构建 <code>Optional</code> 对象的方式通常为 <code>ofNullable</code> 方法或 <code>of</code> 方法，它们的区别在于传入对象是否允许为空</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Person&gt; personOptional = Optional.ofNullable(person);</span><br><span class="line">Optional&lt;Person&gt; personOptional = Optional.of(person); <span class="hljs-comment">// null is not allowed</span></span><br></pre></td></tr></table></figure><p>我们可以在 <code>Optional</code> 实现类中找到大量 防御性代码 + <code>Optional.of()</code> 组合使用的应用场景，如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// java.util.Optional#filter</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate); <span class="hljs-comment">// Assert 类似的效果</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!isPresent())</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        <span class="hljs-keyword">return</span> predicate.test(value) ? <span class="hljs-keyword">this</span> : empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于上述的方式，我们可以基本完成一个比较优雅的避免空指针的模式了，并且当我们错误的传入空指针时，编译器（如 idea）会在运行期前及时的提醒我们方法不允许为空。那么这就够了么？还不够。在很多时候，我们会遇到遗留代码或提供三方<code>jar</code> 包，调用方往往会苦于无法确定传入参数是否允许为空，从而不得不研究方法实现。因此更优雅的方式是，我们对外提供的接口（<code>public</code>）可以通过标记注解来对接口进行说明，而此类注解同样能触发编译器的警告。<code>JSR 305</code> 规范已经提供了此类注解，我们只需引入 <code>com.google.code.findbugs:jsr305</code> 的 <code>jar</code> 包，就可以使用 <code>@Nullable，@Nonnull，@CheckForNull</code> 等标记注解了。</p><p>到此我们就实现了优雅避免空指针的方式：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withSmart</span><span class="hljs-params">(@Nonnull Person person)</span></span>&#123;</span><br><span class="line">    Objects.requireNonNull(person, <span class="hljs-string">"person must be not null."</span>);</span><br><span class="line">    Optional&lt;Person&gt; personOptional = Optional.of(person);</span><br><span class="line">    <span class="hljs-comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它能够为我们带来：</p><ul><li><code>@Nonnull</code>（标志注解）：清晰的对外接口签名，并且能够触发 findBugs 或 idea 对代码运行期前的检查</li><li><code>Objects.requireNonNull</code>（防御性代码）：在触发边界条件时提供有意义的异常警告</li><li><code>Optional</code>：提供优雅的业务逻辑判空实现</li></ul><blockquote><p>由于私有方法不会对外暴露，所以私有方法可以只使用 <code>Optional</code>类来避免 <code>NPE</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NPESolution&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;withIf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Person person)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(person != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;withSpringAssert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Person person)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Assert.isTrue(person != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;person must be not null.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;withOptional&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Person person)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Optional&amp;lt;Person&amp;gt; personOptional = Optional.ofNullable(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;withJsr305Annotation&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(@Nonnull Person person)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Optional&amp;lt;Person&amp;gt; personOptional = Optional.of(person);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述的代码是我在日常用于避免空指针（&lt;code&gt;NPE&lt;/code&gt;）的常用方式，很长时间内我都热衷于断言（&lt;code&gt;Assert&lt;/code&gt;）这类防御性编程方式，防御性编程可以有效的保证方法的输入条件，并在毫无意义的边界情况能够给出有效的提示，何乐而不为呢？事实上防御性编程也确实是一种非常推荐的方式，并且其在 Spring 源码中随处可见。而 JDK8 的 &lt;code&gt;Optional&lt;/code&gt; 是否会是一种更优雅的方式呢？亦或许，另有它人？&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="最佳实践" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>HSDB从入门到实战</title>
    <link href="http://yoursite.com/2019/12/06/HSDB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2019/12/06/HSDB从入门到实战/</id>
    <published>2019-12-06T15:17:42.000Z</published>
    <updated>2020-02-06T05:37:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>HSDB（Hotspot Debugger)</code>，是一款内置于 SA 中的 GUI 调试工具，可用于调试 JVM 运行时数据，从而进行故障排除</p><h2 id="启动HSDB"><a href="#启动HSDB" class="headerlink" title="启动HSDB"></a>启动HSDB</h2><p>检测不同 JDK 版本需要使用不同的 <code>HSDB</code> 版本，否则容易出现无法扫描到对象等莫名其妙的问题</p><ul><li><p><strong>Mac</strong>：JDK7 和 JDK8 均可以采用以下的方式</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo java -cp ,:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure><blockquote><p>事实上经过测试，即使通过 JDK8 自带的 <code>sa-jdi.jar</code> 去扫描对象（<code>scanoops</code>）的时候也会发生扫不到的情况，但可以通过其他手段代替</p></blockquote><p>而 JDK11 的启动方式有些区别</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /Library/Java/JavaVirtualMachines/jdk-11.0.1.jdk/Contents/Home/bin/jhsdb hsdb</span><br></pre></td></tr></table></figure><blockquote><p>事实上经过测试，该版本启动的 <code>HSDB</code> 会少支持一些指令（比如 <code>mem, whatis</code>），<strong>因此目前不推荐使用该版本</strong></p></blockquote></li><li><p><strong>Windows</strong>: </p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -classpath <span class="hljs-string">"%JAVA_HOME%/lib/sa-jdi.jar"</span> sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure></li></ul><p>其中启动版本可以使用 <code>/usr/libexec/java_home -V</code> 获取</p><blockquote><p>若遇到 Unable to locate an executable at “/Users/xx/.jenv/versions/1.7/bin/jhsdb” (-1) 可通过 <code>Jenv</code> 切换到当前 Jdk 版本即可解决</p></blockquote><a id="more"></a><h2 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a>JVM参数设置</h2><p><code>HSDB</code> 对 <code>Serial GC</code> 支持的较好，因此 Debug 时增加参数 <code>-XX:+UseSerialGC</code>，Debug 工具可以使用 IDE 或 JDB</p><h2 id="获取应用进程id"><a href="#获取应用进程id" class="headerlink" title="获取应用进程id"></a>获取应用进程id</h2><p>jps 仅查找当前用户的 Java 进程，而不是当前系统中的所有进程</p><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br></pre></td></tr></table></figure><ul><li>默认<strong>显示 pid </strong>以及 <strong>main 方法对应的 class 名称</strong></li><li>-v：<strong>输出传递给 JVM 的参数</strong></li><li>-l： <strong>输出 main 方法对应的 class 的完整 package 名</strong></li></ul><h2 id="CLHSDB常用指令"><a href="#CLHSDB常用指令" class="headerlink" title="CLHSDB常用指令"></a>CLHSDB常用指令</h2><ul><li><p><code>universe</code>：查看堆空间信息</p></li><li><p><code>scanoops start end [type]</code>：扫描指定空间中的 type 类型及其子类的实例</p><blockquote><p>JDK8 版本的 <code>HSDB</code> 的 <code>scanoops</code> 会无法扫描到对象，但可以通过 GUI 界面的 <code>Tools -&gt; Object Histogram</code>，输入想要查询的对象，之后双击来获取对象的地址，也可以继续在里面点击 <code>inspect</code> 来查看对象信息</p></blockquote></li><li><p><code>inspect</code>：查看对象（<code>OOP</code>）信息【使用 <code>tools-&gt;inspect</code>，输入对象地址有更详细的信息哦】</p></li><li><p><code>revptrs</code>：反向指针，查找引用该对象的指针</p></li></ul><h2 id="HSDB-GUI界面"><a href="#HSDB-GUI界面" class="headerlink" title="HSDB GUI界面"></a>HSDB GUI界面</h2><h3 id="可视化线程栈"><a href="#可视化线程栈" class="headerlink" title="可视化线程栈"></a>可视化线程栈</h3><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-01.png" style="zoom: 50%;"></p><h3 id="对象直方图"><a href="#对象直方图" class="headerlink" title="对象直方图"></a>对象直方图</h3><p><code>Tools -&gt; Object Histogram</code>，我们可以通过对象直方图快速定位某个类型的对象的地址以供我们进一步分析</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-02.png" style="zoom:50%;"></p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSBD-03.png" style="zoom:50%;"></p><h3 id="OOP信息"><a href="#OOP信息" class="headerlink" title="OOP信息"></a>OOP信息</h3><p>我们可以根据对象地址在 <code>Tools -&gt; Inspector</code> 获取对象的在 JVM 层的实例 <code>instanceOopDesc</code> 对象，它包括对象头 <code>_mark</code> 和 <code>_metadata</code> 以及实例信息</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-04.png" style="zoom:50%;"></p><h3 id="堆信息"><a href="#堆信息" class="headerlink" title="堆信息"></a>堆信息</h3><p>我们可以通过 <code>Tools -&gt; Heap Parameters</code> 获取堆信息，可以结合对象地址判断对象位置</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-05.png" style="zoom:50%;"></p><h3 id="加载类列表"><a href="#加载类列表" class="headerlink" title="加载类列表"></a>加载类列表</h3><p>我们可以通过 <code>Tools -&gt; Class Browser</code> 来获取所有加载类列表</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-06.png" style="zoom:50%;"></p><h4 id="元数据区"><a href="#元数据区" class="headerlink" title="元数据区"></a>元数据区</h4><p>HotSpot VM 里有一套对象专门用来存放元数据，它们包括： </p><ul><li><p><code>Klass</code> 系对象，用于描述类型的总体信息【<strong>通过 <code>OOP</code> 信息（<code>inspect</code>）可以看到 <code>instanceKlass</code> 对象</strong>】</p></li><li><p><code>ConstantPool/ConstantPoolCache</code> 对象：每个 <code>InstanceKlass</code> 关联着一个 <code>ConstantPool</code>，作为该类型的运行时常量池。这个常量池的结构跟 Class 文件里的常量池基本上是对应的</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-07.png" style="zoom:50%;"></p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-08.png" style="zoom:50%;"></p></li><li><p><code>Method</code> 对象，用来描述 Java 方法的总体信息，如方法入口地址、调用/循环计数器等等</p><ul><li><code>ConstMethod</code> 对象，记录着 Java 方法的不变的描述信息，包括方法名、方法的访问修饰符、<strong>字节码</strong>、行号表、局部变量表等等。<strong>注意，字节码指令被分配在 <code>constMethodOop</code> 对象的内存区域的末尾</strong></li><li><code>MethodData</code> 对象，记录着 Java 方法执行时的 profile 信息，例如某方法里的某个字节码之类是否从来没遇到过 null，某个条件跳转是否总是走同一个分支，等等。这些信息在解释器（多层编译模式下也在低层的编译生成的代码里）收集，然后供给 HotSpot Server Compiler 用于做激进优化。</li></ul><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-09.png" style="zoom:50%;"></p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-10.png" style="zoom:50%;"></p></li><li><p><code>Symbol</code> 对象，对应 Class 文件常量池里的 <code>JVM_CONSTANT_Utf8</code> 类型的常量。有一个 VM 全局的 <code>SymbolTable</code> 管理着所有 <code>Symbol</code>。<code>Symbol</code> 由所有 Java 类所共享。</p></li></ul><h4 id="生成class文件"><a href="#生成class文件" class="headerlink" title="生成class文件"></a>生成class文件</h4><p>到对应类下点击 create .class 后就可以在执行 HSDB 的目录下看到生成的 class文件，适合查看动态代理生成的字节码</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="分析对象存储区域"><a href="#分析对象存储区域" class="headerlink" title="分析对象存储区域"></a>分析对象存储区域</h3><p>下面代码中的静态变量，成员变量分别存储在什么地方呢？</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> VMShow StaticVmShow = <span class="hljs-keyword">new</span> VMShow();</span><br><span class="line">    <span class="hljs-keyword">private</span> VMShow objVmShow = <span class="hljs-keyword">new</span> VMShow();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        fn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> VMShow <span class="hljs-title">fn</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> VMShow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VMShow</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> basicInt = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer objInt = <span class="hljs-number">2</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer staticInt = <span class="hljs-number">3</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> String basicString = <span class="hljs-string">"basicString"</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String staticString = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"staticString"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看对象直方图可以找到三个 VMShow 对象</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-11.png" style="zoom:50%;"></p><p>那么如何确定这三个地址分别属于哪些变量呢？首先找静态变量，它在 JDK8 中是在 Class 对象中的，因此我们可以找它们的反向指针，如果是<code>java.lang.Class</code> 的那么就是静态变量</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-12.png" style="zoom:50%;"></p><p>我们可以从 ObjTest 的 <code>instanceKlass</code> 中的镜像找到 class 对象来验证是否是该对象的 class</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-13.png" style="zoom:50%;"></p><p>那么成员变量和局部变量如何区分呢？成员变量会被类实例引用，而局部变量地址则在会被被放在栈区</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-14.png" style="zoom:50%;"></p><p>那么局部变量的反向指针都是 null，怎么确定它就被栈区所引用呢？我们可以看可视化线程栈</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-15.png" style="zoom:50%;"></p><h3 id="分析字符串字面量存储区域"><a href="#分析字符串字面量存储区域" class="headerlink" title="分析字符串字面量存储区域"></a>分析字符串字面量存储区域</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="hljs-string">"a"</span>;</span><br><span class="line">        String s2 = <span class="hljs-string">"b"</span>;</span><br><span class="line">        String s3 = s1 + s2;</span><br><span class="line">        String s4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"ab"</span>);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面一共涉及的字符串字面量和实例分别存储在什么地方呢？</p><ol><li><p>首先在 s2 处打上断点，启动 <code>HSDB</code> 监控该进程</p></li><li><p>打开对象直方图发现只有 1 个 <code>a</code> 的字符串对象</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-16.png" style="zoom:50%;"></p></li><li><p>查找 StringTable 中 <code>a</code> 的对象地址</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jseval &quot;st = sa.vm.stringTable;st.stringsDo(function (s) &#123; if (sapkg.oops.OopUtilities.stringOopToString(s).matches(&apos;^(a)&apos;)) &#123;print(s + &apos;: &apos;);s.printValueOn(java.lang.System.out); println(&apos;&apos;)&#125;&#125;)&quot;</span><br></pre></td></tr></table></figure><p>可以根据需要改变 <code>matches</code> 中的值来匹配</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-17.png" style="zoom:50%;"></p><p>可以看到这个对象地址就是 StringTable 中引用的地址</p></li><li><p>然后打断点在 sout 上，重新开始监控进程</p></li><li><p>重新使用对象直方图查看 String 值</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-18.png" style="zoom:50%;"></p><p>这里有5个值，<code>ab</code> 有3个：</p><ul><li><code>ab</code> 字面量</li><li>其中 s3 相当于 <code>new StringBuild().append(&quot;a&quot;).append(&quot;b&quot;).toString()</code>，会创建一个 <code>ab</code> 的实例</li><li>s4会创建一个 <code>ab</code> 的实例</li></ul></li><li><p>我们重新打印 StringTable 相应的值来验证</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jseval &quot;st = sa.vm.stringTable;st.stringsDo(function (s) &#123; if (sapkg.oops.OopUtilities.stringOopToString(s).matches(&apos;^(a|b).?&apos;)) &#123;print(s + &apos;: &apos;);s.printValueOn(java.lang.System.out); println(&apos;&apos;)&#125;&#125;)&quot;</span><br></pre></td></tr></table></figure><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-19.png" style="zoom:50%;"></p></li></ol><p>那么运行时常量池中存放的是哪些呢？实际上它和 StringTable 一样是这些对象的引用，只不过 StringTable 是全局共享的，而运行时常量池只有该类的一些字面量。我们通过加载类列表可以查看</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-20.png" alt="image-20190806204906357" style="zoom:50%;"></p><h3 id="分析String-intern"><a href="#分析String-intern" class="headerlink" title="分析String.intern"></a>分析String.intern</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringInternTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"he"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"llo"</span>); <span class="hljs-comment">//  1</span></span><br><span class="line">        s1.intern(); <span class="hljs-comment">// 2</span></span><br><span class="line">        String s2=<span class="hljs-string">"hello"</span>; <span class="hljs-comment">// 3</span></span><br><span class="line">        System.out.println(s1==s2); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line">        String s3 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"1"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"2"</span>); <span class="hljs-comment">// 4</span></span><br><span class="line">        String s4 = <span class="hljs-string">"12"</span>; <span class="hljs-comment">// 5</span></span><br><span class="line">        s3.intern(); <span class="hljs-comment">// 6</span></span><br><span class="line">        System.out.println(s3 == s4);  <span class="hljs-comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述在编译器确定的字面量有 <code>he</code>, <code>llo</code>, <code>hello</code>, <code>1</code>,  <code>2</code>, <code>12</code>，但在真正执行到语句前，符号引用不一定解析成直接引用，即字面量对应的对象会在执行到语句时（<code>idc</code> 指令）才会创建</p><p>首先看通过加载类列表查看字节码指令： </p><table><thead><tr><th>line</th><th>bci</th><th>bytecode</th></tr></thead><tbody><tr><td>7</td><td>0</td><td>new #2 [Class java.lang.StringBuilder]</td></tr><tr><td>7</td><td>3</td><td>dup</td></tr><tr><td>7</td><td>4</td><td>invokespecial #3 [Method void <init>()]</init></td></tr><tr><td>7</td><td>7</td><td>new #4 [Class java.lang.String]</td></tr><tr><td>7</td><td>10</td><td>dup</td></tr><tr><td>7</td><td>11</td><td>ldc #5(0) <string "he"=""> [fast_aldc]</string></td></tr><tr><td>7</td><td>13</td><td>invokespecial #6 [Method void <init>(java.lang.String)]</init></td></tr><tr><td>7</td><td>16</td><td>invokevirtual #7 [Method java.lang.StringBuilder            append(java.lang.String)]</td></tr><tr><td>7</td><td>19</td><td>new #4 [Class java.lang.String]</td></tr><tr><td>7</td><td>22</td><td>dup</td></tr><tr><td>7</td><td>23</td><td>ldc #8(1) <string "llo"=""> [fast_aldc]</string></td></tr><tr><td>7</td><td>25</td><td>invokespecial #6 [Method void <init>(java.lang.String)]</init></td></tr><tr><td>7</td><td>28</td><td>invokevirtual #7 [Method java.lang.StringBuilder            append(java.lang.String)]</td></tr><tr><td>7</td><td>31</td><td>invokevirtual #9 [Method java.lang.String toString()]</td></tr><tr><td>7</td><td>34</td><td>astore_1</td></tr><tr><td>8</td><td>35</td><td>aload_1</td></tr><tr><td>8</td><td>36</td><td>invokevirtual #10 [Method java.lang.String intern()]</td></tr><tr><td>8</td><td>39</td><td>pop</td></tr><tr><td>9</td><td>40</td><td>ldc #11(2) <string "hello"=""> [fast_aldc]</string></td></tr><tr><td>9</td><td>42</td><td>astore_2</td></tr><tr><td>10</td><td>43</td><td>getstatic #12 [Field java.io.PrintStream out]</td></tr><tr><td>10</td><td>46</td><td>aload_1</td></tr><tr><td>10</td><td>47</td><td>aload_2</td></tr><tr><td>10</td><td>48</td><td>if_acmpne 55</td></tr><tr><td>10</td><td>51</td><td>iconst_1</td></tr><tr><td>10</td><td>52</td><td>goto 56</td></tr><tr><td>10</td><td>55</td><td>iconst_0</td></tr><tr><td>10</td><td>56</td><td>invokevirtual #13 [Method void println(boolean)]</td></tr><tr><td>12</td><td>59</td><td>new #2 [Class java.lang.StringBuilder]</td></tr><tr><td>12</td><td>62</td><td>dup</td></tr><tr><td>12</td><td>63</td><td>invokespecial #3 [Method void <init>()]</init></td></tr><tr><td>12</td><td>66</td><td>new #4 [Class java.lang.String]</td></tr><tr><td>12</td><td>69</td><td>dup</td></tr><tr><td>12</td><td>70</td><td>ldc #14(3) <string "1"=""> [fast_aldc]</string></td></tr><tr><td>12</td><td>72</td><td>invokespecial #6 [Method void <init>(java.lang.String)]</init></td></tr><tr><td>12</td><td>75</td><td>invokevirtual #7 [Method java.lang.StringBuilder            append(java.lang.String)]</td></tr><tr><td>12</td><td>78</td><td>new #4 [Class java.lang.String]</td></tr><tr><td>12</td><td>81</td><td>dup</td></tr><tr><td>12</td><td>82</td><td>ldc #15(4) <string "2"=""> [fast_aldc]</string></td></tr><tr><td>12</td><td>84</td><td>invokespecial #6 [Method void <init>(java.lang.String)]</init></td></tr><tr><td>12</td><td>87</td><td>invokevirtual #7 [Method java.lang.StringBuilder            append(java.lang.String)]</td></tr><tr><td>12</td><td>90</td><td>invokevirtual #9 [Method java.lang.String toString()]</td></tr><tr><td>12</td><td>93</td><td>astore_3</td></tr><tr><td>13</td><td>94</td><td>ldc #16(5) <string "12"=""> [fast_aldc]</string></td></tr><tr><td>13</td><td>96</td><td>astore #4</td></tr><tr><td>14</td><td>98</td><td>aload_3</td></tr><tr><td>14</td><td>99</td><td>invokevirtual #10 [Method java.lang.String intern()]</td></tr><tr><td>14</td><td>102</td><td>pop</td></tr><tr><td>15</td><td>103</td><td>getstatic #12 [Field java.io.PrintStream out]</td></tr><tr><td>15</td><td>106</td><td>aload_3</td></tr><tr><td>15</td><td>107</td><td>aload #4</td></tr><tr><td>15</td><td>109</td><td>if_acmpne 116</td></tr><tr><td>15</td><td>112</td><td>iconst_1</td></tr><tr><td>15</td><td>113</td><td>goto 117</td></tr><tr><td>15</td><td>116</td><td>iconst_0</td></tr><tr><td>15</td><td>117</td><td>invokevirtual #13 [Method void println(boolean)]</td></tr><tr><td>16</td><td>120</td><td>return</td></tr></tbody></table><p>可以看到确实有 6 个<code>idc</code>，但如果我们在第一行语句打上断点，会发现它们都不在 StringTable（但这里的 <code>he</code> 在，它可能被其他类用到了），然后执行第一行，会发现 <code>he</code> 和 <code>llo</code> 在了，但 <code>hello</code> 不在</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jseval &quot;st = sa.vm.stringTable;st.stringsDo(function (s) &#123; if (sapkg.oops.OopUtilities.stringOopToString(s).matches(&apos;^(he|llo|hello|1|2|12)&apos;)) &#123;print(s + &apos;: &apos;);s.printValueOn(java.lang.System.out); println(&apos;&apos;)&#125;&#125;)&quot;</span><br></pre></td></tr></table></figure><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-21.png" style="zoom:50%;"></p><p>但是 <code>hello</code> 对象还是存在的（new）</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-22.png" style="zoom:50%;"></p><p>接着执行 s1.intern 会将 <code>hello</code> 对象的地址放入 StringTable</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-23.png" style="zoom:50%;"></p><p>再执行 <code>String s2=&quot;hello&quot;;</code> 会发现 <code>hello</code> 对象仍然只有一个，都指向同一个。</p><p>而继续在 6 打断点，即执行完 <code>String s4 = &quot;12&quot;;</code>，因为 <code>12</code> 不在字符串常量池，那么会新建一个 <code>12</code> 的实例，并让字符串常量池引用它，这样会发现就有两个 <code>12</code> 了</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/jvm/HSDB-24.png" style="zoom:50%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;HSDB（Hotspot Debugger)&lt;/code&gt;，是一款内置于 SA 中的 GUI 调试工具，可用于调试 JVM 运行时数据，从而进行故障排除&lt;/p&gt;
&lt;h2 id=&quot;启动HSDB&quot;&gt;&lt;a href=&quot;#启动HSDB&quot; class=&quot;headerlink&quot; title=&quot;启动HSDB&quot;&gt;&lt;/a&gt;启动HSDB&lt;/h2&gt;&lt;p&gt;检测不同 JDK 版本需要使用不同的 &lt;code&gt;HSDB&lt;/code&gt; 版本，否则容易出现无法扫描到对象等莫名其妙的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mac&lt;/strong&gt;：JDK7 和 JDK8 均可以采用以下的方式&lt;/p&gt;
&lt;figure class=&quot;highlight bash hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo java -cp ,:/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/lib/sa-jdi.jar sun.jvm.hotspot.HSDB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;事实上经过测试，即使通过 JDK8 自带的 &lt;code&gt;sa-jdi.jar&lt;/code&gt; 去扫描对象（&lt;code&gt;scanoops&lt;/code&gt;）的时候也会发生扫不到的情况，但可以通过其他手段代替&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而 JDK11 的启动方式有些区别&lt;/p&gt;
&lt;figure class=&quot;highlight bash hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ /Library/Java/JavaVirtualMachines/jdk-11.0.1.jdk/Contents/Home/bin/jhsdb hsdb&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;事实上经过测试，该版本启动的 &lt;code&gt;HSDB&lt;/code&gt; 会少支持一些指令（比如 &lt;code&gt;mem, whatis&lt;/code&gt;），&lt;strong&gt;因此目前不推荐使用该版本&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;: &lt;/p&gt;
&lt;figure class=&quot;highlight bash hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ java -classpath &lt;span class=&quot;hljs-string&quot;&gt;&quot;%JAVA_HOME%/lib/sa-jdi.jar&quot;&lt;/span&gt; sun.jvm.hotspot.HSDB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中启动版本可以使用 &lt;code&gt;/usr/libexec/java_home -V&lt;/code&gt; 获取&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若遇到 Unable to locate an executable at “/Users/xx/.jenv/versions/1.7/bin/jhsdb” (-1) 可通过 &lt;code&gt;Jenv&lt;/code&gt; 切换到当前 Jdk 版本即可解决&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="故障排查" scheme="http://yoursite.com/tags/%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Static Nested Or Inner Classes</title>
    <link href="http://yoursite.com/2019/12/06/Static-Nested-Or-Inner-Classes/"/>
    <id>http://yoursite.com/2019/12/06/Static-Nested-Or-Inner-Classes/</id>
    <published>2019-12-06T07:35:59.000Z</published>
    <updated>2020-02-06T06:00:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 中，在一个类中声明另一个类则称为嵌套类，被声明为 <code>static</code> 的嵌套类称为静态嵌套类（<code>static nested classes</code> ），与之相对的非静态嵌套类被称为内部类(（<code>inner classes</code> ）</p><ul><li><p>非静态嵌套类每个实例都包含一个额外指向外围对象的引用，换句话说，要实例化一个非静态嵌套类必须首先实例化外部类</p></li><li><p>静态嵌套类独立于外部类实例，可以看作嵌套在一个顶级类中的顶级类。因此，如果嵌套类不要求访问外部类的实例变量或方法，就要始终把 <code>static</code> 修饰符放在它的声明中，使它成为静态嵌套类。（如果该嵌套类不作为基类，那么更适合同时加上 <code>final</code> 修饰符）。JDK1.8 源码可见各种这样的设计，如 ReentrantLock 中</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>我们从四个方面来更详细的讨论它们的区别：</p><ul><li><p>嵌套类访问外部类的范围</p></li><li><p>嵌套类本身定义变量的范围</p></li><li><p>实例化</p></li><li><p>同名覆盖</p></li></ul><a id="more"></a><h1 id="非静态嵌套类"><a href="#非静态嵌套类" class="headerlink" title="非静态嵌套类"></a>非静态嵌套类</h1><ul><li><p>非静态嵌套类和外部类的实例关联，可以直接访问外部类的所有方法和字段</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"OuterClass..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            System.out.println(j);</span><br><span class="line">            display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同样由于非静态嵌套类和外部类的实例相关联，所以它不能自己定义任何静态成员</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> failedField = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 编译错误</span></span><br><span class="line">      </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failedMethod</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">// 编译错误</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要先实例化外部类，再实例化非静态嵌套类</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass outerClass = <span class="hljs-keyword">new</span> OuterClass();</span><br><span class="line">OuterClass.InnerClass innerClass = outerClass.new InnerClass();</span><br></pre></td></tr></table></figure></li><li><p>同名覆盖问题，非静态嵌套类仅会出现在实例变量或方法中，非静态嵌套类中声明的实例同名变量或方法会覆盖外部类的声明，访问外部类的实例变量或方法需要加上 <code>外部类名.this</code>，如 <code>OuterClass.this.x</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="hljs-string">"OuterClass..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-keyword">this</span>.j);  <span class="hljs-comment">// 3</span></span><br><span class="line">            System.out.println(OuterClass.<span class="hljs-keyword">this</span>.j); <span class="hljs-comment">// 2</span></span><br><span class="line">            <span class="hljs-keyword">this</span>.display();  <span class="hljs-comment">// InnerClass..</span></span><br><span class="line">            OuterClass.<span class="hljs-keyword">this</span>.display();  <span class="hljs-comment">// OuterClass...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="hljs-string">"InnerClass..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="静态嵌套类"><a href="#静态嵌套类" class="headerlink" title="静态嵌套类"></a>静态嵌套类</h1><ul><li><p>静态嵌套类和外部类（非实例）相关联，因此仅能访问外部类的静态变量和方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticField = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> normalField = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticMethod</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">normalMethod</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(staticField);  <span class="hljs-comment">// 编译通过</span></span><br><span class="line">          System.out.println(normalField);  <span class="hljs-comment">// 编译错误</span></span><br><span class="line">          staticMethod();  <span class="hljs-comment">// 编译通过</span></span><br><span class="line">          normalMethod();  <span class="hljs-comment">// 编译错误</span></span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于静态嵌套类不依赖于外部类实例，所以它可以定义任意变量和方法（和普通类相同）</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">          </span><br><span class="line">          <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;</span><br><span class="line">          <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">normalDisplay</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">              System.out.println(i);</span><br><span class="line">              System.out.println(j);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">staticDisplay</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">              System.out.println(j);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>可以直接实例化静态嵌套类，且不会实例化外部类</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.StaticNestedClass staticNestedClass = <span class="hljs-keyword">new</span> OuterClass.StaticNestedClass();</span><br></pre></td></tr></table></figure></li><li><p>同名覆盖问题，静态嵌套类仅会出现静态变量或方法重名，静态嵌套类中声明的静态同名变量或方法会覆盖外部类的声明，访问外部类的静态变量或方法需要加上外部类名，如 <code>OuterClass.x</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticNestedClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(i);  <span class="hljs-comment">// 1</span></span><br><span class="line">            System.out.println(j);  <span class="hljs-comment">// 2</span></span><br><span class="line">          System.out.println(OuterClass.j);  <span class="hljs-comment">// 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>最后关于序列化，根据 Oracle 官方建议，强烈不推荐序列化非静态嵌套类，原因参考 <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html" target="_blank" rel="noopener">Nested Classes</a></p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>当一个类的构造函数需要传入多个参数，且很多参数是可选的，传统做法是重载构造函数。这将导致几个问题</p><ul><li>由于可选参数多，因此会有大量重载构造函数，也就是说会存在大量重复代码</li><li>客户端调用比较困难，使用者需要选择合适的构造函数，以及了解每个参数的含义和顺序</li></ul><p>因此比较合适的方式是使用 <code>Builder</code> 模式代替重载构造函数，它隐藏了内部的具体构建细节，允许多个可选参数，具有很强的可读性。而 <code>Builder</code> 模式就是使用静态嵌套类实现的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Getter</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseVideoParseBo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 电影</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String movie;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 搜索链接</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String searchUrl;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 电影标题</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 时长</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String time;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 清晰度</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String bagde;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 封面</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String imgUrl;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 视频链接</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> List&lt;String&gt; videoUrls = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 渠道</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> String channel;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">BaseVideoParseBo</span><span class="hljs-params">(Builder&lt;?&gt; builder)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.movie = builder.movie;</span><br><span class="line">        <span class="hljs-keyword">this</span>.bagde = builder.bagde;</span><br><span class="line">        <span class="hljs-keyword">this</span>.searchUrl = builder.searchUrl;</span><br><span class="line">        <span class="hljs-keyword">this</span>.time = builder.time;</span><br><span class="line">        <span class="hljs-keyword">this</span>.title = builder.title;</span><br><span class="line">        <span class="hljs-keyword">this</span>.imgUrl = builder.imgUrl;</span><br><span class="line">        <span class="hljs-keyword">this</span>.channel = builder.channel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">private</span> Class&lt;T&gt; subBuilder;</span><br><span class="line">        <span class="hljs-keyword">private</span> String movie;</span><br><span class="line">        <span class="hljs-keyword">private</span> String searchUrl;</span><br><span class="line">        <span class="hljs-keyword">private</span> String title;</span><br><span class="line">        <span class="hljs-keyword">private</span> String time;</span><br><span class="line">        <span class="hljs-keyword">private</span> String bagde;</span><br><span class="line">        <span class="hljs-keyword">private</span> String imgUrl;</span><br><span class="line">        <span class="hljs-keyword">private</span> String channel;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">(Class&lt;T&gt; subBuilder)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.subBuilder = subBuilder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">movie</span><span class="hljs-params">(String movie)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.movie = movie;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">searchUrl</span><span class="hljs-params">(String searchUrl)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.searchUrl = searchUrl;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">title</span><span class="hljs-params">(String title)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.title = title;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">time</span><span class="hljs-params">(String time)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.time = time;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">bagde</span><span class="hljs-params">(String bagde)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.bagde = bagde;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">imgUrl</span><span class="hljs-params">(String imgUrl)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.imgUrl = imgUrl;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">channel</span><span class="hljs-params">(String channel)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.channel = channel;</span><br><span class="line">            <span class="hljs-keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">self</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> subBuilder.cast(<span class="hljs-keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> BaseVideoParseBo <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BaseVideoParseBo(<span class="hljs-keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addVideoUrls</span><span class="hljs-params">(List&lt;String&gt; videoUrls)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.videoUrls.addAll(videoUrls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addVideoUrl</span><span class="hljs-params">(String videoUrl)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.videoUrls.add(videoUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建该类对象代码如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 仅使用基类时</span></span><br><span class="line">BaseVideoParseBo baseVideoParseBo = <span class="hljs-keyword">new</span> BaseVideoParseBo.Builder&lt;&gt;(BaseVideoParseBo.Builder.class)</span><br><span class="line">.xxx()</span><br><span class="line">.build();</span><br></pre></td></tr></table></figure><p>这里再做一些拓展，可以看到上述类大量使用了泛型，其主要用于解决 <code>Builder</code> 继承时的返回类型问题，因此结合了 <code>Builder</code> 模式和协变返回类型，其子类可以如下实现：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@Getter</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubParseBo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseVideoParseBo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 是否获取所有清晰度的视频</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> allVideos;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> String dataId;</span><br><span class="line">    <span class="hljs-keyword">private</span> String dataInfo;</span><br><span class="line">    <span class="hljs-keyword">private</span> String videoId;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">SubParseBo</span><span class="hljs-params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(builder);</span><br><span class="line">        <span class="hljs-keyword">this</span>.dataId = builder.dataId;</span><br><span class="line">        <span class="hljs-keyword">this</span>.allVideos = builder.allVideos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseVideoParseBo</span>.<span class="hljs-title">Builder</span>&lt;<span class="hljs-title">Builder</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> allVideos;</span><br><span class="line">        <span class="hljs-keyword">private</span> String dataId;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">super</span>(Builder.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">dataId</span><span class="hljs-params">(String dataId)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.dataId = dataId;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">allVideos</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> allVideos)</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">this</span>.allVideos = allVideos;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> SubParseBo <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SubParseBo(<span class="hljs-keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDataInfo</span><span class="hljs-params">(String dataInfo)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.dataInfo = dataInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVideoId</span><span class="hljs-params">(String videoId)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.videoId = videoId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么构建子类对象如下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubParseBo parseBo = <span class="hljs-keyword">new</span> SubParseBo.Builder()</span><br><span class="line">                .xxx</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Java 中，在一个类中声明另一个类则称为嵌套类，被声明为 &lt;code&gt;static&lt;/code&gt; 的嵌套类称为静态嵌套类（&lt;code&gt;static nested classes&lt;/code&gt; ），与之相对的非静态嵌套类被称为内部类(（&lt;code&gt;inner classes&lt;/code&gt; ）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;非静态嵌套类每个实例都包含一个额外指向外围对象的引用，换句话说，要实例化一个非静态嵌套类必须首先实例化外部类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;静态嵌套类独立于外部类实例，可以看作嵌套在一个顶级类中的顶级类。因此，如果嵌套类不要求访问外部类的实例变量或方法，就要始终把 &lt;code&gt;static&lt;/code&gt; 修饰符放在它的声明中，使它成为静态嵌套类。（如果该嵌套类不作为基类，那么更适合同时加上 &lt;code&gt;final&lt;/code&gt; 修饰符）。JDK1.8 源码可见各种这样的设计，如 ReentrantLock 中&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NonfairSync&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Sync&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们从四个方面来更详细的讨论它们的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;嵌套类访问外部类的范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;嵌套类本身定义变量的范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同名覆盖&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="最佳实践" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>泛型进阶</title>
    <link href="http://yoursite.com/2019/12/06/%E6%B3%9B%E5%9E%8B%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2019/12/06/泛型进阶/</id>
    <published>2019-12-06T07:19:10.000Z</published>
    <updated>2020-02-06T05:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="无限制通配符"><a href="#无限制通配符" class="headerlink" title="无限制通配符"></a>无限制通配符</h2><p>无限通配符即： <code>&lt;?&gt;</code>，主要在不确定或不关心实际参数类型时使用，如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于它不确定具体类型，所以不能将任何元素（<code>Null</code> 除外）放入，即它是只读的，但在很多情况下需要放入对象，因此一种比较常见的方法是使用 <strong>类型参数</strong> 作为辅助函数</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List&lt;?&gt; list, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;</span><br><span class="line">swapHelper(list, i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swapHelper</span><span class="hljs-params">(List&lt;E&gt; list, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>&#123;</span><br><span class="line">list.set(i, list.get(j));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>List&lt;?&gt;</code> 和 <code>List&lt;Object&gt;</code> 有什么区别呢？</p><a id="more"></a><ol><li><p><code>List&lt;Object&gt;</code> 已经指定了类型的参数，而泛型具有不变性，所以它只能传入参数类型为 <code>Object</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;());  <span class="hljs-comment">// 正确</span></span><br><span class="line">test(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());  <span class="hljs-comment">// 错误</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;Object&gt; list)</span></span>&#123;</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>List&lt;?&gt;</code> 是无限制通配符类型，它可以表示为任意的实际的类型参数</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;()); <span class="hljs-comment">// 正确</span></span><br><span class="line">test(<span class="hljs-keyword">new</span> ArrayList&lt;String&gt;());  <span class="hljs-comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>List&lt;Object&gt;</code> 的类型参数已经确定，所以可以对其中的元素进行诸如 <code>get</code> , <code>add</code> 、<code>remove</code> 等操作</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;Object&gt; list)</span></span>&#123;</span><br><span class="line">list.add(<span class="hljs-string">"str"</span>);</span><br><span class="line">list.add(<span class="hljs-number">1</span>);</span><br><span class="line">list.remove(<span class="hljs-string">"str"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>List&lt;?&gt;</code> 是只读的，不能 <code>add</code> ，只能 <code>get</code> <code>,</code> <code>remove</code> 操作（当然可以使用上述的辅助函数实现 <code>add</code>），且返回元素都是 <code>Object</code> 类型的</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">list.get(<span class="hljs-number">0</span>);</span><br><span class="line">list.remove(<span class="hljs-string">"str"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>所以一般情况下，使用无限制通配符的优先级大于 <code>Object</code> 作为类型参数</p><h2 id="有限制通配符"><a href="#有限制通配符" class="headerlink" title="有限制通配符"></a>有限制通配符</h2><p><code>java</code> 泛型有两种有限制通配符，<code>&lt;? extends E&gt;</code> 和 <code>&lt;? super E&gt;</code>，那么它们的作用是什么呢？这要从协变和逆变说起。</p><h3 id="协变（Covariance）和逆变（Contravariance）"><a href="#协变（Covariance）和逆变（Contravariance）" class="headerlink" title="协变（Covariance）和逆变（Contravariance）"></a>协变（Covariance）和逆变（Contravariance）</h3><p>逆变与协变用来描述类型转换（<em>type transformation</em>）后的继承关系</p><ul><li><strong>协变：具有子类型关系之间的类型经过“类型转换”后，所构造出更复杂的类型之间仍保持着子类型关系。</strong></li><li><strong>逆变：具有子类型关系之间的类型经过“类型转换”后，所构造的更复杂的类型之间建立了逆向子类型关系。</strong></li><li><strong>不变：具有子类型关系之间的类型经过“类型转换”后，所构造的更复杂的类型之间没有任何关系</strong></li></ul><p>这里指的类型转换代表指的是从一种类型构造为另一种新的类型，如 <code>String</code> 到 <code>String[]</code>，<code>String</code> 到 <code>List&lt;String&gt;</code>。在 <code>java</code> 中，泛型具有不变性，如</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number number = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">0</span>);  <span class="hljs-comment">// True</span></span><br><span class="line">ArrayList&lt;Number&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();  <span class="hljs-comment">// True</span></span><br><span class="line">ArrayList&lt;Number&gt; arrayList1 = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();  <span class="hljs-comment">// 编译错误</span></span><br><span class="line">ArrayList&lt;Number&gt; arrayList1 = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();  <span class="hljs-comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>那么问题的答案就出现了：有限制通配符是为了实现泛型的协变与逆变</p><ul><li><p><code>&lt;? extends E&gt;</code> 实现了泛型的协变：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? extends Number&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;? super E&gt;</code> 实现了泛型的逆变：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? <span class="hljs-keyword">super</span> Number&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure></li></ul><h3 id="extends-与-super"><a href="#extends-与-super" class="headerlink" title="extends 与 super"></a>extends 与 super</h3><p>有限制通配符有它的局限性，看一个例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>));</span><br></pre></td></tr></table></figure><p>我们通过 <code>extends</code> 通配符构建了对象，但是却不能插入 <code>Integer</code> 类型的元素，这看起来很不合理。其实这是可以理解的，首先看一些 <code>List</code> 类的 <code>add</code> 方法接口</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 <code>add</code> 方法时，泛型 <code>E</code> 自动变成了 <code>&lt;? extends Number&gt;</code>，也就是说其类型是 <code>Number</code> 的子类中的一个（不含 <code>Number</code>），因此 <code>add</code> 一个  <code>Integer</code> 类型对象是错误的。如果要实现 <code>add</code> 一个 <code>Interger</code> 对象，可以使用 <code>super</code> 关键字</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="hljs-keyword">super</span> Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>));</span><br></pre></td></tr></table></figure><p><code>&lt;? super Number&gt;</code> 代表其持有的类型是 <code>Number</code> 的父类，那么 <code>add</code> 一个  <code>Integer</code> 类型对象是正确的。所以我们又可以总结出：</p><ul><li><code>&lt;? extends Number&gt;</code>  是只读的</li></ul><ul><li><code>&lt;? super Number&gt;</code>  是只写的</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>那么究竟什么时候用 <code>extends</code>，什么时候用 <code>super</code> 呢？其实很简单，遵循 <code>PECS</code> 原则</p><blockquote><p><em>PECS: producer-extends, consumer-super</em>. 换句话说：</p><ul><li>如果要从泛型类取数据时，用 <code>extends</code></li><li>如果要往泛型类写数据时，用 <code>super</code></li></ul></blockquote><p>举几个例子，首先看 <code>java.util.AbstractList</code> 的 <code>addAll</code> 方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">rangeCheckForAdd(index);</span><br><span class="line"><span class="hljs-keyword">boolean</span> modified = <span class="hljs-keyword">false</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (E e : c) &#123;  <span class="hljs-comment">// 注意这里，从泛型类中获取对象!!</span></span><br><span class="line">add(index++, e);</span><br><span class="line">modified = <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addAll</code> 方法需要将传入的泛型类中的所有元素保存到当前集合中，因此将从泛型类读取所有元素，所以使用 <code>extends</code>。又如 <code>java.util.Collections</code> 的 <code>copy</code> 方法</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">copy</span><span class="hljs-params">(List&lt;? <span class="hljs-keyword">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> </span>&#123;</span><br><span class="line"><span class="hljs-keyword">int</span> srcSize = src.size();</span><br><span class="line"><span class="hljs-keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Source does not fit in dest"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||</span><br><span class="line">(src <span class="hljs-keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="hljs-keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;srcSize; i++)</span><br><span class="line">dest.set(i, src.get(i));  <span class="hljs-comment">// 从src泛型类读取数据，写入dest泛型类！！！</span></span><br><span class="line">&#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">ListIterator&lt;? <span class="hljs-keyword">super</span> T&gt; di=dest.listIterator();</span><br><span class="line">ListIterator&lt;? extends T&gt; si=src.listIterator();</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;srcSize; i++) &#123;</span><br><span class="line">di.next();</span><br><span class="line">di.set(si.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>copy</code> 方法将一个集合中的元素拷贝到另一个集合，完美的诠释了有限制通配符的使用。</p><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>考虑以下代码：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span>&#123;</span><br><span class="line">T max = coll.iterator().next();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (T elm : coll) &#123;</span><br><span class="line"><span class="hljs-keyword">if</span> (max.compareTo(elm) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">max = elm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是对集合中的元素进行排序，那么我们需要对传入的集合中的元素进行限定，它需要能够进行比较，即实现 <code>Comparable</code> 接口，<code>&lt;T extends Comparable&lt;T&gt;&gt;</code> 的作用就是如此。但在继承关系中，上述声明会出现错误，考虑以下情况：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fruit</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String name;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fruit</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name = name;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Fruit that)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (size &lt; that.size)</span><br><span class="line">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size == that.size)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Apple</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(<span class="hljs-string">"Apple"</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Apple</code> 类继承了 <code>Fruit</code> 类，但是它没有实现 <code>Comparable&lt;Apple&gt;</code>，而是实现了 <code>Comparable&lt;Fruit&gt;</code>，因此它不符合 <code>&lt;T extends Comparable&lt;T&gt;&gt;</code> 要求，因此不能对 <code>Apple</code> 集合使用</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-number">10</span>));</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-number">20</span>));</span><br><span class="line"></span><br><span class="line">Algorithm.&lt;Apple&gt;max(list);  <span class="hljs-comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p> 因此，为了能够对这种情况予以支持，需要使用如下声明：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;T&gt; coll)</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;T extends Comparable&lt;? super T&gt;&gt;</code>的限定含义是：</p><ul><li><code>T implements Comparable&lt;T&gt;</code></li><li><code>T implements Comparable&lt;X&gt;</code>，其中 <code>X</code> 是 <code>T</code> 的父类</li></ul><blockquote><p>其实以之前的 <code>PECS</code> 原则也能很好的解释，无论是 <code>Comparable</code> 还是 <code>Comparator</code>，它们的方法都需要写数据，即向泛型类写数据，所以需要使用  <code>&lt;? super T&gt;</code> ，所以使用  <code>Comparator</code> 的声明为：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;T&gt; coll, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure></blockquote><p>其实到这里为止，这个 <code>API</code> 已经能够支持大部分情况了。但是假设我们需要传入的泛型集合是 <code>T</code> 的子类，将会仍然编译错误</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Algorithm.&lt;Fruit&gt;max(list);  <span class="hljs-comment">// T为Fruit，传入的是List&lt;Apple&gt;，编译错误</span></span><br></pre></td></tr></table></figure><p>这就是之前说的泛型的不变性问题，因此，最灵活的声明是：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span></span></span><br></pre></td></tr></table></figure><p>也许你不太明白我们这样使用它的意义，为什么一定要强制加一个 <code>&lt;Fruit&gt;</code> 呢？看起来没什么必要，其实这是在模拟一种情况，上述的声明等同于如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Algorithm</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;? <span class="hljs-title">super</span> <span class="hljs-title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span> </span>&#123;</span><br><span class="line">        T max = coll.iterator().next();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (T elm : coll) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (max.compareTo(elm) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">                max = elm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的调用是不是就比较常见了</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-number">10</span>));</span><br><span class="line">list.add(<span class="hljs-keyword">new</span> Apple(<span class="hljs-number">20</span>));</span><br><span class="line"></span><br><span class="line">Algorithm&lt;Fruit&gt; fruitAlgorithm = <span class="hljs-keyword">new</span> Algorithm&lt;&gt;();</span><br><span class="line">fruitAlgorithm.max(list);</span><br></pre></td></tr></table></figure><p>其实 <code>java.util.Collections</code> 的 <code>max</code> 方法可以看到类似的声明：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T extends Object &amp; Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(Collection&lt;? extends T&gt; coll)</span> </span>&#123;</span><br><span class="line">Iterator&lt;? extends T&gt; i = coll.iterator();</span><br><span class="line">T candidate = i.next();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">T next = i.next();</span><br><span class="line"><span class="hljs-keyword">if</span> (next.compareTo(candidate) &gt; <span class="hljs-number">0</span>)</span><br><span class="line">candidate = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中使用 <code>Object &amp;</code> 主要是因为泛型擦除，编译生成的 <code>Java</code> 字节码中是不包含泛型中的类型信息，泛型类型会被 <code>Object</code> 所代替（无限制通配符也用 <code>Object</code>），而有限制通配符则会被第一个边界的类型变量来替换，如上面的声明会被 <code>Comparable</code> 所代替，使用了 <code>Object &amp;</code> 后将被 <code>Object</code> 所代替，参看 <a href="https://stackoverflow.com/questions/19488357/why-is-t-bounded-by-object-in-the-collections-max-signature" target="_blank" rel="noopener"><em>Why is T bounded by Object in the Collections.max() signature?</em></a></p><h2 id="泛型单例类"><a href="#泛型单例类" class="headerlink" title="泛型单例类"></a>泛型单例类</h2><p>实现一个泛型单例类，使得它能够对于传入任意类型的 <code>Class</code> 对象都创建一个单例对象</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; INSTANCE_MAP = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getInstance</span><span class="hljs-params">(Class&lt;T&gt; tClass)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Object instance = INSTANCE_MAP.get(tClass);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">synchronized</span> (INSTANCE_MAP)&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;</span><br><span class="line">                    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                        instance = tClass.newInstance();</span><br><span class="line">                        INSTANCE_MAP.put(tClass, instance);</span><br><span class="line">                    &#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// Class的cast方法能够动态的将Object类型转换为Class对象所表示的类型，如果能转就返回，不能转就抛出类型转换失败异常</span></span><br><span class="line">        <span class="hljs-comment">// 这样就不需要借助于未受检警告（(T)instance）</span></span><br><span class="line">        <span class="hljs-keyword">return</span> tClass.cast(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 <code>Persion</code> 类</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 姓名</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 身份证</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    String idcard;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 年龄</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * 电子邮件</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将它传入泛型单例类，每次 <code>getInstance</code> 可以得到相同的对象</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Singleton.getInstance(Person.class) == Singleton.getInstance(Person.class));  <span class="hljs-comment">// True</span></span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-不应使用原生态类型"><a href="#1-不应使用原生态类型" class="headerlink" title="1. 不应使用原生态类型"></a>1. 不应使用原生态类型</h3><p>原生态类型即不带实际类型参数的泛型名称，如 <code>List&lt;E&gt;</code> 的原生态类型为 <code>List</code>。它<strong>逃避了泛型检查</strong>，当你不小心插入了类型错误的对象，在运行时转换对象会出现 <code>ClassCastException</code> 。因此应该摈弃这样的做法，取而代之使用泛型，优点有以下两点：</p><ol><li>在编译期间进行类型检查</li><li>获取对象不需要手动转换类型</li></ol><p>例子如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 原生态类型，不推荐</span></span><br><span class="line">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="hljs-string">"str"</span>);</span><br><span class="line">list.add(<span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (Object o : list) &#123;</span><br><span class="line">String s = (String)o;  <span class="hljs-comment">// 抛出ClassCastException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 泛型，推荐</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="hljs-string">"str"</span>);</span><br><span class="line">list.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 1. 编译期检查错误，不允许添加整形</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">for</span> (String o : list) &#123;</span><br><span class="line">String s = o;  <span class="hljs-comment">// 2. 不需手动转换类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-不要使用通配符类型作为返回类型"><a href="#2-不要使用通配符类型作为返回类型" class="headerlink" title="2. 不要使用通配符类型作为返回类型"></a>2. 不要使用通配符类型作为返回类型</h3><p>使用通配符类型作为返回类型将会强制在客户端代码中使用通配符类型，如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 使用通配符类型作为返回类型，不推荐</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">List&lt;?&gt; list = returnGenericsType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> List&lt;?&gt; returnGenericsType()&#123;</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-泛型无法使用instanceof"><a href="#3-泛型无法使用instanceof" class="headerlink" title="3. 泛型无法使用instanceof"></a>3. 泛型无法使用instanceof</h3><p>由于泛型擦除，编译期间会擦除类型参数，所以不能使用 <code>instanceof</code></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Apple&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span>(list <span class="hljs-keyword">instanceof</span> List&lt;Apple&gt;)&#123;  <span class="hljs-comment">// 错误</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于无限制通配符是可以使用 <code>instanceof</code> 的</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">if</span>(list <span class="hljs-keyword">instanceof</span> List&lt;?&gt;)&#123;  <span class="hljs-comment">// 错误</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然尖括号和 <code>?</code> 有些多余，可以直接判断</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list <span class="hljs-keyword">instanceof</span> List</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;无限制通配符&quot;&gt;&lt;a href=&quot;#无限制通配符&quot; class=&quot;headerlink&quot; title=&quot;无限制通配符&quot;&gt;&lt;/a&gt;无限制通配符&lt;/h2&gt;&lt;p&gt;无限通配符即： &lt;code&gt;&amp;lt;?&amp;gt;&lt;/code&gt;，主要在不确定或不关心实际参数类型时使用，如：&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;removeAll&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Collection&amp;lt;?&amp;gt; c)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;由于它不确定具体类型，所以不能将任何元素（&lt;code&gt;Null&lt;/code&gt; 除外）放入，即它是只读的，但在很多情况下需要放入对象，因此一种比较常见的方法是使用 &lt;strong&gt;类型参数&lt;/strong&gt; 作为辅助函数&lt;/p&gt;
&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(List&amp;lt;?&amp;gt; list, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	swapHelper(list, i, j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;E&amp;gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;swapHelper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(List&amp;lt;E&amp;gt; list, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; j)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	list.set(i, list.get(j));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;那么 &lt;code&gt;List&amp;lt;?&amp;gt;&lt;/code&gt; 和 &lt;code&gt;List&amp;lt;Object&amp;gt;&lt;/code&gt; 有什么区别呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="最佳实践" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>SELECT FOR UPDATE语句深度解析</title>
    <link href="http://yoursite.com/2019/06/18/SELECT-FOR-UPDATE%E8%AF%AD%E5%8F%A5%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/06/18/SELECT-FOR-UPDATE语句深度解析/</id>
    <published>2019-06-18T14:19:04.000Z</published>
    <updated>2020-02-06T05:25:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;<code>Mysql</code> 的 <code>SELECT ... FOR UPDATE</code> 语句是日常使用较多的用于锁定资源，确保在多个事务读取数据时始终能够读取到最新版本的数据的有效语句。那么它是怎么实现呢？在经过官网文档以及大量实践的验证之后发现网上存在大量不严谨甚至错误的信息，因此通过本文对 <code>SELECT FOR UPDATE</code> 语句作出以下总结。在具体介绍之前，先对目前网上教程或博客中会提到的几个<strong>常见误区</strong>进行纠正：</p><ul><li><p><del><code>SELECT FOR UPDATE</code> 在xx情况下会添加表级锁。</del> </p><p>请注意，<strong>在任何情况下 <code>SELECT FOR UPDATE</code> 都不会添加表级锁。</strong>事实上，在大部分情况下（DQL 语句，DML 语句，DDL 语句）都不会添加表锁，取而代之的是各种类型的行锁。</p><blockquote><p><i class="far fa-bell"></i> </p><p>&emsp;&emsp;那么我们如何获取表锁呢？语句如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLES</span> xx <span class="hljs-keyword">READ</span>; <span class="hljs-comment"># 为 xx 表添加表级 S 锁</span></span><br><span class="line"><span class="hljs-keyword">LOCK</span> <span class="hljs-keyword">TABLES</span> xx WRITE;  <span class="hljs-comment"># 为 xx 表添加表级 X 锁</span></span><br></pre></td></tr></table></figure><p>然后我们可以通过以下语句来检测当前 Mysql 有哪些表获取了表级锁</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">OPEN</span> <span class="hljs-keyword">TABLES</span> <span class="hljs-keyword">WHERE</span> In_use &gt; <span class="hljs-number">0</span></span><br></pre></td></tr></table></figure><p>更多的表级锁相关知识请参考<a href="https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html#table-lock-release" target="_blank" rel="noopener">官网介绍</a></p></blockquote></li><li><p><del><code>SELECT FOR UPDATE</code> 在未使用索引时会”锁表”。</del></p><p><code>SELECT FOR UPDATE</code> 确实可以通过 <code>Next-key lock</code> 锁住所有记录和间隙来实现和表锁类似的效果。但未使用索引并非充分条件，我们判断 <code>SELECT FOR UPDATE</code> 是否锁住了所有数据和间隙还需要看它的隔离级别。</p></li></ul><a id="more"></a><p>那么影响我们判断 <code>SELECT FOR UPDATE</code> 语句持有什么锁的因素有哪些呢？在这里列出以下几点：</p><ul><li>隔离级别（RC/RR）</li><li>执行计划（聚簇索引/唯一索引/二级索引/无索引）</li><li>过滤条件（等值条件/范围条件）</li></ul><p><strong>以下分析内容均建立在已经了解 Mysql 的行级锁的类型和作用范围的基础上，同时列出几点必要的前提论据：</strong></p><ul><li><p>一般情况下，RC 级别是无法使用 <code>Gap Lock</code> 的，但在检查外键约束或者 duplicate key 检查时还是会用到的</p><blockquote><p>Gap locking can be disabled explicitly. This occurs if you change the transaction isolation level to READ COMMITTED. Under these circumstances, gap locking is disabled for searches and index scans and is used only for foreign-key constraint checking and duplicate-key checking.</p><footer><strong>MySQL 8.0 Reference Manual</strong><cite><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html" target="_blank" rel="noopener">15.7.1 InnoDB Locking</a></cite></footer></blockquote></li><li><p>一般情况下，执行计划根据某个索引查询后，会将过滤完的记录加锁后返回给 MySQL Server 进行过滤。在 RC 隔离级别下，当记录不满足条件时 MySQL Server 会调用 <code>handler::unlock_row()</code> 告诉存储引擎释放锁（破坏了 2PL 规则），RR 隔离级别下则会保持到事务提交</p><blockquote><p><i class="far fa-bell"></i> </p><ul><li>2PL（<a href="https://en.wikipedia.org/wiki/Two-phase_locking" target="_blank" rel="noopener">两阶段加锁协议</a>）是数据库中保证事务并发的控制方法，即保证多个事务在并发的情况下等同于串行的执行。它将加锁和解锁分为两个阶段。而为了在事务中能够明确的判断什么是加锁阶段，什么是解锁阶段，引入了 S2PL（Strict-2PL），即<strong>在事务中只有提交（commit）或者回滚（rollback）时才是解锁阶段，其余时间为加锁阶段。</strong></li><li><p>ICP（索引条件下推）：是一种减少 server 层和 engine 层之间交互的次数的优化方式。上面提到一般情况下对于根据索引查询返回的记录将交由 MySQL Server 进行过滤，而如果过滤条件是联合索引且无法走联合索引时，如：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 联合索引：(index1, index2, index3)</span></span><br><span class="line"><span class="hljs-comment"># 根据最左匹配原则无法走联合索引</span></span><br><span class="line"><span class="hljs-keyword">select</span> x <span class="hljs-keyword">from</span> xx <span class="hljs-keyword">where</span> index1 = <span class="hljs-string">‘xx’</span> <span class="hljs-keyword">and</span> index3 <span class="hljs-keyword">like</span> <span class="hljs-string">‘%xxxx%’</span></span><br></pre></td></tr></table></figure><p>正常情况下在对 index1 进行筛选后的记录就要返回。而经过 ICP 优化，由于 where 的查询列属于该联合索引，那么会将对该 where 条件记录过滤后才返回给 server 层</p></li></ul><p>参考：</p><ul><li><a href="http://hedengcheng.com/?p=771" target="_blank" rel="noopener">MySQL 加锁处理分析</a> </li><li><a href="http://mysql.taobao.org/monthly/2016/01/01/" target="_blank" rel="noopener">MySQL · 引擎特性 · InnoDB 事务锁系统简介</a> </li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual  8.2.1.5 Index Condition Pushdown Optimization</a> </li><li><a href="https://bugs.mysql.com/bug.php?id=20390" target="_blank" rel="noopener">SELECT FOR UPDATE does not release locks of untouched rows in full table scans</a></li></ul></blockquote></li></ul><h2 id="RC级别下的SELECT-FOR-UPDATE"><a href="#RC级别下的SELECT-FOR-UPDATE" class="headerlink" title="RC级别下的SELECT FOR UPDATE"></a>RC级别下的SELECT FOR UPDATE</h2><p>虽然 Mysql 默认的事务隔离级别是 RR，但是在大多数互联网应用中 Mysql 的隔离级别会设置为 RC，因此我们也首先讨论 RC 隔离级别下的 <code>SELECT FOR UPDATE</code>。</p><ul><li><p><strong>在执行计划不走索引时，将只会为满足条件的记录添加 <code>Record Lock</code> </strong></p><blockquote><p>执行计划不走索引代表 sql 会走聚簇索引的全扫描，对所有记录加锁后返回给 MySQL Server 进行过滤。过滤过程中不满足条件的记录的锁会被释放，因此最终只锁住了满足条件的记录</p></blockquote></li><li><p><strong>在执行计划走聚簇索引时，将只为满足条件的记录添加 <code>Record Lock</code> </strong></p></li><li><p><strong>在执行计划走唯一索引或二级索引时，将会为满足条件的记录所在的聚簇索引和二级索引添加 <code>Record Lock</code>  </strong></p><blockquote><p>为什么还需要在聚簇索引加锁呢？因为如果不锁聚簇索引意味着别的事务可以使用 <code>update/delete</code>，那么就失去了锁定资源的作用了</p></blockquote></li></ul><p>从上面的分析可以看出，在 RC 级别下任何情况下都不会出现”锁表”效果。但是<strong>请注意即使 <code>SELECT FOR UPDATE</code> 的目标记录没有被锁住，也是有可能造成阻塞的。</strong>原因在于 <em>Mysql 对非索引过滤（即是由 Mysql Server 过滤）的记录加锁返回的过程是不会省略的</em>，因此如果 <code>SELECT FOR UPDATE</code> 不走索引，那么 Mysql 会为聚簇索引的所有数据行尝试添加  <code>Record Lock</code> ，而一旦有任何一行已经被锁定，那么当前查询就会被阻塞。</p><h2 id="RR级别下的SELECT-FOR-UPDATE"><a href="#RR级别下的SELECT-FOR-UPDATE" class="headerlink" title="RR级别下的SELECT FOR UPDATE"></a>RR级别下的SELECT FOR UPDATE</h2><p>Mysql 的 RR 级别为了解决幻读引入了 <code>Gap Lock</code>，这也为 <code>SELECT FOR UPDATE</code> 的加锁增加了很多可能性</p><ul><li><p><strong>在执行计划不走索引时，将会聚簇索引中的所有记录添加 <code>Next-key Lock</code>，相当于”锁表”</strong></p><blockquote><p>RR 级别下非索引过滤的记录即使不符合过滤条件，锁也不会被释放。同时为了解决幻读，记录添加 <code>Next-key Lock</code> 来锁定间隙</p></blockquote></li><li><p><strong>在执行计划走聚簇索引时，若是能够命中的等值查询，将只为满足条件的记录添加 <code>Record Lock</code>；否则将覆盖范围包含过滤范围的记录添加 <code>Next-key Lock</code></strong>。</p><blockquote><p>为什么只有在等值查询是才有可能添加 <code>Record Lock</code> ？因为范围查询内的数据存在幻读问题</p></blockquote></li><li><p><strong>在执行计划走唯一索引时，锁住唯一索引的方式和聚簇索引相似，同时使用 <code>Record Lock</code> 锁住命中的聚簇索引</strong></p><blockquote><p>为什么只需要使用 <code>Record Lock</code> 锁住聚簇索引？因为通过唯一索引可以保证过滤范围间无法插入数据（与插入意向锁互斥），因此只需要 <code>Record Lock</code> 锁来确定目标记录不被 <code>update/delete</code> 即可</p></blockquote></li><li><p><strong>在执行计划走二级索引时，无论是否为等值查询都会为覆盖范围包含过滤范围的记录添加 <code>Next-key</code>，同时使用 <code>Record Lock</code> 锁住命中的聚簇索引</strong></p><blockquote><p>为什么二级索引不区分等值查询呢？因为即使是等值查询也不能唯一定位二级索引中的数据，在一棵二级索引的 B+ 树中，叶子结点由 二级索引列值 + 主键值 确定的，仅仅依靠二级索引列值还是相当于范围查询</p></blockquote></li></ul><h2 id="Serializable下的SELECT-FOR-UPDATE"><a href="#Serializable下的SELECT-FOR-UPDATE" class="headerlink" title="Serializable下的SELECT FOR UPDATE"></a>Serializable下的SELECT FOR UPDATE</h2><p>Serializable 级别下 <code>SELECT FOR UPDATE</code> 的加锁方式基本和RR级别相同。比较特殊的是，Serializable 下是不存在快照读的，即使查询语句不添加 <code>for update</code> 也会为记录添加共享锁</p><h2 id="锁分析工具"><a href="#锁分析工具" class="headerlink" title="锁分析工具"></a>锁分析工具</h2><p>Mysql 提供了语句来查询当前持有锁的状态和类型等等，是验证我们的判断的利器。语句如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> performance_schema.data_locks</span><br></pre></td></tr></table></figure><p>它提供几个关键信息：</p><ul><li>LOCK_TYPE：锁类型，<code>RECORD</code> 代表行锁，<code>TABLE</code> 代表表锁</li><li>LOCK_MODE：锁模式，<code>X,REC_NOT_GAP</code> 代表 <code>Record Lock</code> , <code>X, GAP</code> 代表 <code>Gap Lock</code> , <code>X</code> 代表 <code>Next-key Lock</code></li><li>INDEX_NAME：锁定索引的名称</li><li>LOCK_DATA：与锁相关的数据，比如锁在主键上就是主键值</li></ul><p>更多的字段解释参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/data-locks-table.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual 26.12.12.1 The data_locks Table</a></p><p>除此之外，Mysql 还提供了查询当前正在执行的每个事务（不包括只读事务）的信息，比如隔离级别，内存中此事务的锁结构占用的总大小等等。语句如下：</p><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.INNODB_TRX</span><br></pre></td></tr></table></figure><p>它提供几个关键信息：</p><ul><li>TRX_ID：如果是非锁定的只读事务是没有该 id 的</li><li>TRX_REQUESTED_LOCK_ID：当前事务正在等待的锁 id</li><li>TRX_TABLES_LOCKED：当前 SQL 语句具有行锁定的表的数量</li><li>TRX_LOCK_MEMORY_BYTES：内存中此事务的锁结构占用的总大小。</li><li>TRX_ISOLATION_LEVEL：当前事务的隔离级别</li></ul><p>更多的字段解释参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-trx-table.html" target="_blank" rel="noopener">MySQL 8.0 Reference Manual 25.39.29 The INFORMATION_SCHEMA INNODB_TRX Table</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;&lt;code&gt;Mysql&lt;/code&gt; 的 &lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt; 语句是日常使用较多的用于锁定资源，确保在多个事务读取数据时始终能够读取到最新版本的数据的有效语句。那么它是怎么实现呢？在经过官网文档以及大量实践的验证之后发现网上存在大量不严谨甚至错误的信息，因此通过本文对 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 语句作出以下总结。在具体介绍之前，先对目前网上教程或博客中会提到的几个&lt;strong&gt;常见误区&lt;/strong&gt;进行纠正：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 在xx情况下会添加表级锁。&lt;/del&gt; &lt;/p&gt;
&lt;p&gt;请注意，&lt;strong&gt;在任何情况下 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 都不会添加表级锁。&lt;/strong&gt;事实上，在大部分情况下（DQL 语句，DML 语句，DDL 语句）都不会添加表锁，取而代之的是各种类型的行锁。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;i class=&quot;far fa-bell&quot;&gt;&lt;/i&gt; &lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;那么我们如何获取表锁呢？语句如下：&lt;/p&gt;
&lt;figure class=&quot;highlight sql hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLES&lt;/span&gt; xx &lt;span class=&quot;hljs-keyword&quot;&gt;READ&lt;/span&gt;; &lt;span class=&quot;hljs-comment&quot;&gt;# 为 xx 表添加表级 S 锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;LOCK&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLES&lt;/span&gt; xx WRITE;  &lt;span class=&quot;hljs-comment&quot;&gt;# 为 xx 表添加表级 X 锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;然后我们可以通过以下语句来检测当前 Mysql 有哪些表获取了表级锁&lt;/p&gt;
&lt;figure class=&quot;highlight sql hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SHOW&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OPEN&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLES&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; In_use &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;更多的表级锁相关知识请参考&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/lock-tables.html#table-lock-release&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网介绍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;del&gt;&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 在未使用索引时会”锁表”。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 确实可以通过 &lt;code&gt;Next-key lock&lt;/code&gt; 锁住所有记录和间隙来实现和表锁类似的效果。但未使用索引并非充分条件，我们判断 &lt;code&gt;SELECT FOR UPDATE&lt;/code&gt; 是否锁住了所有数据和间隙还需要看它的隔离级别。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://yoursite.com/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://yoursite.com/tags/Mysql/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>基础同步工具类</title>
    <link href="http://yoursite.com/2019/02/11/%E5%9F%BA%E7%A1%80%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/11/基础同步工具类/</id>
    <published>2019-02-11T13:14:39.000Z</published>
    <updated>2020-02-06T03:58:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Semaphore，CountDownLatch，CyclicBarrier 均是 JDK1.5 提供的基础并发工具：</p><ul><li>Semaphore 是一个计数信号量，用于限制同时访问某个特定资源的数量</li><li>CountDownLatch 是一个闭锁，允许一个或多个线程等待一组其他线程执行完成后执行，但只能使用一次</li><li>CyclicBarrier 是一个循环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行，并且支持重复使用</li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">    </span><br><span class="line">    Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">10</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 方法本身控制同步</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Integer <span class="hljs-title">getNextAvailableItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 信号量控制访问次数</span></span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">return</span> random.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">markAsUnused</span><span class="hljs-params">(Integer item)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// do something</span></span><br><span class="line">        </span><br><span class="line">        semaphore.release();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Semaphore 的一个标准的使用方式，用于控制流量。上述程序创建了一个允许 10 个线程同时访问的信号量，并且使用公平锁（一般来说用于控制流量的使用需要使用公平模式，用于防止线程饥饿），然后在提供获取资源的接口 getNextAvailableItem 方法前先获取凭证，在释放资源后释放凭证。<strong>但是注意 Semaphore 不保证并发正确性，这需要接口自己保证，因此这里使用 synchronized 来提醒这一点。</strong></p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Semaphore 默认使用非公平锁，也可以显示的设置使用公平锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="hljs-keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Semaphore</span><span class="hljs-params">(<span class="hljs-keyword">int</span> permits, <span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="hljs-keyword">new</span> FairSync(permits) : <span class="hljs-keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁 FairSync 和非公平锁 NonfairSync 均继承于内部类 Sync，而 Sync 继承 AQS（AbstractQueuedSynchronizer）锁。获取锁和释放锁均在 Sycn 中实现</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>acquire 在获取非公平锁的实现底层核心方法为 nonfairTryAcquireShared</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> available = getState();</span><br><span class="line">        <span class="hljs-keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="hljs-keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semaphore 在初始化的时候会将 state 设为凭证数，在每次获取锁时 nonfairTryAcquireShared 会将 state - 1 直到 state 为 0，当 state 为 0 时则代表不可以再获取共享锁了。在具体实现上，这是一个标准的子类获取共享锁的实现模式。它本质是一个共享锁，会允许多个线程同时进入，因此在之前的使用介绍也提到了 Semaphore 不能确保并发正确性。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> available = getState();</span><br><span class="line">        <span class="hljs-keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="hljs-keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于公平模式的获取锁和 ReentrantLock 的实现相同，会先调用 hasQueuedPredecessors 来判断当前线程是否位于等待队列中的第一个，仅在处于队列的第一个时才会尝试获取锁，从而保证了获取锁的先后顺序。</p><p>还需要注意的是，无论是公平锁还是非公平锁，Semaphore 的acquire 是调用的 acquireSharedInterruptibly，因此它是可中断的</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用不支持中断的，可以使用 acquireUninterruptibly</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireUninterruptibly</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> current = getState();</span><br><span class="line">        <span class="hljs-keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span></span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是调用 AQS 的释放共享锁的方法，那么本质上尝试释放锁就是通过重载 tryReleaseShared 实现的。因为共享锁的释放锁是存在并发的，所以需要通过 CAS 自旋更新 state 状态，每次释放都会将 state + 1。这也是一个标准的子类释放共享锁的实现模式。因此我们也要警惕使用 release，因为它会导致当前 state 大于凭证数，意味着如果释放次数大于获取次数会导致同时允许的线程数大于凭证数。</p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;There is no requirement that a thread that releases a permit must have acquired that permit by calling acquire(). Correct usage of a semaphore is established by programming convention in the application.</p><p>&emsp;&emsp;没有要求释放许可证的线程必须先通过调用 acquire() 获得该许可证。通过应用程序中的编程约定来建立信号量的正确使用。</p></blockquote><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>了解了 Semaphore 原理后，这里通过 Semaphore 实现一个线程池只能同时执行两个任务的例子</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">final</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">2</span>, <span class="hljs-keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Task(semaphore, count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> AtomicInteger count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(Semaphore semaphore, AtomicInteger count)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        <span class="hljs-keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="hljs-string">"Semaphore 中断 "</span> + Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            doIt();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doIt</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": is running ["</span> + count.addAndGet(<span class="hljs-number">1</span>) + <span class="hljs-string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            Thread.sleep((<span class="hljs-keyword">int</span>)(<span class="hljs-number">1</span> + (Math.random() * <span class="hljs-number">3</span>)));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            count.decrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Task 任务会在执行前先获取信号量，并对同时在运行的任务进行计数，在执行完任务后会重置计数并释放信号量。在实现过程中需要注意两个重要的点，也是实际使用时需要注意的点：</p><ol><li>doIt 执行任务本身需要保证并发安全，所以 count 使用 Atomic 类。</li><li>Semaphore 的 acquire 和 release 不要在同一个 try 中，否则当 acquire 获取失败时仍然会执行 release，而 release并不控制凭证数，这会导致有可能产生比设置时更大的 state</li></ol><p>在这个案例中，正常结果打印出来的同时运行的线程数不会超过 2，比如：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2: is running [2]</span><br><span class="line">pool-1-thread-1: is running [1]</span><br><span class="line">pool-1-thread-3: is running [2]</span><br><span class="line">pool-1-thread-4: is running [2]</span><br><span class="line">pool-1-thread-2: is running [1]</span><br><span class="line">pool-1-thread-5: is running [2]</span><br><span class="line">pool-1-thread-1: is running [2]</span><br><span class="line">pool-1-thread-3: is running [1]</span><br><span class="line">pool-1-thread-4: is running [2]</span><br><span class="line">pool-1-thread-5: is running [2]</span><br></pre></td></tr></table></figure><blockquote><p><i class="far fa-bell"></i>   重点回顾</p><ul><li>Semaphore 底层通过 AQS 共享锁实现，支持公平/非公平模式</li><li>Semaphore 应用场景主要用于控制流量</li><li>Semaphore 并不保证并发正确性，需要接口本身保证</li><li>Semaphore 的 release 释放次数大于 acquire 获取次数时会导致并发数大于凭证数，因此这需要由调用者正确控制</li></ul></blockquote><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line"></span><br><span class="line">        CountDownLatch startSignle = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">        CountDownLatch doneSignle = <span class="hljs-keyword">new</span> CountDownLatch(threadCnt);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Task(startSignle, doneSignle));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"All task start."</span>);</span><br><span class="line"></span><br><span class="line">        startSignle.countDown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            doneSignle.await();</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"All task done."</span>);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> CountDownLatch startSignle;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> CountDownLatch doneSignle;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(CountDownLatch startSignle, CountDownLatch doneSignle)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.startSignle = startSignle;</span><br><span class="line">        <span class="hljs-keyword">this</span>.doneSignle = doneSignle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            startSignle.await();</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" is running"</span>);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            doneSignle.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序创建了两个分别用于启动和结束的 CountDownLatch，startSignle 用于所有子线程等待主线程发送执行的信号，doneSignle 用于主线程等待所有子线程完成的信号。正常结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">All task start.</span><br><span class="line">pool-1-thread-2 is running</span><br><span class="line">pool-1-thread-3 is running</span><br><span class="line">pool-1-thread-4 is running</span><br><span class="line">pool-1-thread-1 is running</span><br><span class="line">pool-1-thread-5 is running</span><br><span class="line">pool-1-thread-4 is running</span><br><span class="line">pool-1-thread-1 is running</span><br><span class="line">pool-1-thread-2 is running</span><br><span class="line">pool-1-thread-5 is running</span><br><span class="line">pool-1-thread-3 is running</span><br><span class="line">All task done.</span><br></pre></td></tr></table></figure><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>CountDownLatch 的构造函数只有一个参数，用于控制 await 线程被执行前必须先执行线程的个数</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sync 继承 AQS（AbstractQueuedSynchronizer）锁，因此 CountDownLatch 也是基于 AQS 的一个实现</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await 调用的 acquireSharedInterruptibly 意味着它支持中断</p><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>await 的获取共享锁的方式和之前所说的 Semaphore 的实现对 state 的处理是完全相反的：</p><ul><li>在 Semaphore 中是在 state 大于 0 时允许获取锁</li><li>在 CountDownLatch 中是在 state = 0 时允许获取锁</li></ul><p>这很好理解，await 的线程需要在 N 个线程执行 countDown 后才允许被唤醒，和 Semaphore 的逻辑正好相反。</p><h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown"></a>countDown</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> c = getState();</span><br><span class="line">        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> nextc = c-<span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>countDown 本质上就是释放共享锁，每次执行会将 state - 1 直到 0。在释放到 state = 0 后不会再释放。这就说明了两个问题：</p><ul><li>即使执行 countDown 的次数大于初始化时设置的 count 值也是不会有问题的，因为 releaseShared 会直接返回释放失败。</li><li>即使先执行 countDown，只要执行到足够的次数，再执行 await 也能成功获取到锁。</li></ul><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;为什么 await 方法获取锁成功是返回 1，而不是 0 呢？</p><p>&emsp;&emsp;这是因为在 AQS 中，释放共享锁后会唤醒后继结点，而后续的唤醒则依赖于获取锁的线程的传播式向后唤醒结点，而这依赖于 tryAcquireShared 的返回结果，当返回 0 时会被 AQS 认为无剩余共享资源导致无法唤醒后续结点。那么这就会导致最后一个 countDown 执行完后无法唤醒所有由 await 阻塞的线程</p></blockquote><p>最后那么我们来模拟多个线程等待多个线程执行完成后唤醒的过程：假设 A, B 两个线程等待 m, n 线程执行完成才能执行，而 A, B 先于 m, n 执行</p><ol><li>A 线程调用 await，因为 state 为 2 进入 AQS 等待队列，为头结点</li><li>B 线程调用 await，因为 state 为 2 进入 AQS 等待队列，插入队尾</li><li>m 线程调用 countDown，将 state 设为 1，释放锁成功，尝试唤醒 A，A 尝试获取锁但因为 state != 0，唤醒失败</li><li>n 线程调用 countDown，将 state 设为 0，释放锁成功，尝试唤醒 A，A 尝试获取锁因为 state = 0，A 唤醒成功</li><li>A 获取锁成功返回 1 允许传播式尝试唤醒 B，B 尝试获取锁因为 state = 0，B 唤醒成功</li></ol><blockquote><p><i class="far fa-bell"></i>   重点回顾</p><ul><li>CountDownLatch 底层通过 AQS 共享锁实现</li><li>CountDownLatch 的应用场景为一个或多个线程等待一组其他线程执行完成后执行</li><li>CountDownLatch 的 countDown 次数大于初始化时设置的 count 值时会抛出异常</li><li>CountDownLatch 的 countDown 方法可以先于 await 方法先执行</li></ul></blockquote><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">5</span>;</span><br><span class="line"></span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(threadCnt);</span><br><span class="line"></span><br><span class="line">        AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++) &#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Task(cyclicBarrier, threadCnt * <span class="hljs-number">2</span>, count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"All tasks done."</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> AtomicInteger count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Integer taskCnt;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(CyclicBarrier cyclicBarrier, Integer taskCnt, AtomicInteger count)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        <span class="hljs-keyword">this</span>.taskCnt = taskCnt;</span><br><span class="line">        <span class="hljs-keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">while</span> (!isDone())&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" starts."</span>);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line"></span><br><span class="line">                count.addAndGet(<span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" is waiting."</span>);</span><br><span class="line"></span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" quit."</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isDone</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> taskCnt.equals(count.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序创建了一个需要 5 个线程到达后每个线程才能执行后续流程的循环栅栏 CyclicBarrier。每个任务执行完毕后会将 count + 1 以及通过 await 等待其他线程完成。而每个线程完成所有任务的标志是 count = 10，因此在前 5 个执行完成后又会重复的执行一轮，最后全部线程退出。正常结果如下：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2 starts.</span><br><span class="line">pool-1-thread-5 starts.</span><br><span class="line">pool-1-thread-4 starts.</span><br><span class="line">pool-1-thread-3 starts.</span><br><span class="line">pool-1-thread-1 starts.</span><br><span class="line">pool-1-thread-5 is waiting.</span><br><span class="line">pool-1-thread-4 is waiting.</span><br><span class="line">pool-1-thread-3 is waiting.</span><br><span class="line">pool-1-thread-1 is waiting.</span><br><span class="line">pool-1-thread-2 is waiting.</span><br><span class="line">pool-1-thread-2 starts.</span><br><span class="line">pool-1-thread-5 starts.</span><br><span class="line">pool-1-thread-4 starts.</span><br><span class="line">pool-1-thread-3 starts.</span><br><span class="line">pool-1-thread-1 starts.</span><br><span class="line">pool-1-thread-4 is waiting.</span><br><span class="line">pool-1-thread-1 is waiting.</span><br><span class="line">pool-1-thread-5 is waiting.</span><br><span class="line">pool-1-thread-3 is waiting.</span><br><span class="line">pool-1-thread-2 is waiting.</span><br><span class="line">pool-1-thread-2 quit.</span><br><span class="line">pool-1-thread-4 quit.</span><br><span class="line">pool-1-thread-3 quit.</span><br><span class="line">pool-1-thread-1 quit.</span><br><span class="line">pool-1-thread-5 quit.</span><br><span class="line">All tasks done.</span><br></pre></td></tr></table></figure><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;CyclicBarrier 结合线程池使用需要注意死锁问题，当线程池可执行线程数小于 CyclicBarrier 触发栅栏的线程时会产生死锁</p></blockquote><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>CyclicBarrier 存在两个构造函数，parties 用于执行在触发栅栏之前需要执行的线程数，barrierAction 为触发栅栏的线程首先执行该任务后才会唤醒所有等待的线程</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="hljs-keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="hljs-keyword">this</span>.count = parties;</span><br><span class="line">    <span class="hljs-keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(parties, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await-1"><a href="#await-1" class="headerlink" title="await"></a>await</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> dowait(<span class="hljs-keyword">false</span>, <span class="hljs-number">0L</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(toe); <span class="hljs-comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dowait</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> timed, <span class="hljs-keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="hljs-function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 当前代</span></span><br><span class="line">        <span class="hljs-keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (g.broken)</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> index = --count;</span><br><span class="line">        <span class="hljs-comment">// 当index=0时代表触发栅栏</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span></span><br><span class="line">            <span class="hljs-keyword">boolean</span> ranAction = <span class="hljs-keyword">false</span>;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 首先执行传入的任务</span></span><br><span class="line">                <span class="hljs-keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="hljs-keyword">if</span> (command != <span class="hljs-keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="hljs-keyword">true</span>;</span><br><span class="line">                <span class="hljs-comment">// 然后更新代，唤醒所有等待线程</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">            &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 如果还没触发栅栏，则阻塞</span></span><br><span class="line">        <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-comment">// 如果未设置超时时间，则直接阻塞</span></span><br><span class="line">                <span class="hljs-keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="hljs-comment">// 否则对阻塞设置超时时间</span></span><br><span class="line">                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="hljs-keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">                    <span class="hljs-comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="hljs-comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="hljs-comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (g.broken)</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (g != generation)</span><br><span class="line">                <span class="hljs-keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CyclicBarrier 是一个可以循环使用的栅栏，因此它有一个“代”的概念，即每个在触发栅栏之前需要执行的线程数为一代，每执行一次任务则会将需要执行的线程数减一直到 0，这时候就进入了新的一代，即新的循环。 await 实际上通过 ReentrantLock + Condition 完成线程的阻塞和唤醒：</p><ol><li><p>判断当前线程在当前代中的位置，如果还不能触发栅栏，则调用 condition.await/awaitNanos 对当前线程进行阻塞</p></li><li><p>如果一个线程触发了栅栏，首先执行传入的 Runnable 任务，然后唤醒所有等待的任务，再更新代</p></li><li><p>每个被唤醒的线程检查当前代是否已经更新，如果已经更新，则返回在阻塞时还剩余需要执行的线程数。因此  <code>barrier.await() == 0</code>  时意味着当前代需要执行的最后一个线程已完成，可以做些一轮任务做完需要做的工作，比如整合，日志等</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (barrier.await() == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">// log the completion of this iteration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是它和 barrierAction 还是有些区别，barrierAction 中执行的内容会在唤醒其他线程前执行（新代执行前），而 <code>barrier.await() == 0</code> 内执行的内容则是在唤醒其他线程后执行的（有可能新代已经开始执行），因此在使用时需要多加考虑</p></li></ol><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;CountDownLatch 和 CyclicBarrier 比较相似，都是多个线程相互等待后执行，但它们还是有比较大的区别：</p><ol><li>从实现来看，CountDownLatch 使用的是共享锁，所以一次 countDown 能唤醒所有 await 等待的线程；而 CyclicBarrier 使用的互斥锁 + Condition 的方式，由调用 await 触发栅栏的线程来唤醒一个代中的所有线程（signAll）</li><li>从功能来看，CountDownLatch 只允许使用一次，而 CyclicBarrier 允许循环使用</li><li>从应用来看，CountDownLatch 适用于一个或多个线程等待一组线程执行完成后执行，比如初始化；而 CyclicBarrier 适合用于一组线程相互之间等待，达到一个共同点，再继续执行。比如并行计算，计算中涉及多个子任务阶段式完成任务</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Semaphore，CountDownLatch，CyclicBarrier 均是 JDK1.5 提供的基础并发工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Semaphore 是一个计数信号量，用于限制同时访问某个特定资源的数量&lt;/li&gt;
&lt;li&gt;CountDownLatch 是一个闭锁，允许一个或多个线程等待一组其他线程执行完成后执行，但只能使用一次&lt;/li&gt;
&lt;li&gt;CyclicBarrier 是一个循环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行，并且支持重复使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Semaphore&quot;&gt;&lt;a href=&quot;#Semaphore&quot; class=&quot;headerlink&quot; title=&quot;Semaphore&quot;&gt;&lt;/a&gt;Semaphore&lt;/h2&gt;&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;X&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Random random = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Random();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Semaphore semaphore = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Semaphore(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 方法本身控制同步&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; Integer &lt;span class=&quot;hljs-title&quot;&gt;getNextAvailableItem&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// 信号量控制访问次数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        semaphore.acquire();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; random.nextInt();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;markAsUnused&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Integer item)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;// do something&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        semaphore.release();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是 Semaphore 的一个标准的使用方式，用于控制流量。上述程序创建了一个允许 10 个线程同时访问的信号量，并且使用公平锁（一般来说用于控制流量的使用需要使用公平模式，用于防止线程饥饿），然后在提供获取资源的接口 getNextAvailableItem 方法前先获取凭证，在释放资源后释放凭证。&lt;strong&gt;但是注意 Semaphore 不保证并发正确性，这需要接口自己保证，因此这里使用 synchronized 来提醒这一点。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock</title>
    <link href="http://yoursite.com/2019/01/14/ReentrantLock/"/>
    <id>http://yoursite.com/2019/01/14/ReentrantLock/</id>
    <published>2019-01-14T11:53:12.000Z</published>
    <updated>2020-06-07T08:14:57.556Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;ReentrantLock 是基于 AQS 同步器实现的互斥锁，它支持设置公平锁/非公平锁模式，同时具有可重入性。在这里讨论 ReentrantLock 对这些特性的支持及应用。</p><h2 id="标准模式"><a href="#标准模式" class="headerlink" title="标准模式"></a>标准模式</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        lock.lock();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// ... method body</span></span><br><span class="line">        </span><br><span class="line">        &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">            </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ReentrantLock 默认使用非公平锁，也可以通过显式的使用公平锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="hljs-keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁 FairSync 和非公平锁 NonfairSync 均继承于内部类 Sync，而 Sync 继承 AQS（AbstractQueuedSynchronizer）锁。获取锁和释放锁均在 Sycn 中实现</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> sync.nonfairTryAcquire(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="hljs-number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            acquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5179523762034025860L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="hljs-comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="hljs-keyword">int</span> c = getState();</span><br><span class="line">        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span></span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的 <a href="http://zzcoder.cn/2019/01/10/AbstractQueuedSynchronizer%E5%90%8C%E6%AD%A5%E5%99%A8/" target="_blank" rel="noopener">AQS同步器</a> 提到过，AbstractQueuedSynchronizer 为子类提供了需要实现的 tryAcquire 模板方法，非公平锁获取锁调用的底层核心方法是 nonfairTryAcquire。首先基于 AQS 实现获取互斥锁的标准实现：<strong>当 state 为 0 时代表没有线程持有锁，因此尝试获取锁，如果获取锁成功则将当前线程设为持有锁的线程</strong>：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> c = getState();</span><br><span class="line"><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但和普通的互斥锁不同的是，ReentrantLock 还需要支持可重入性：<strong>当 state 不为 0（即存在线程持有锁），会继续判断持有锁的是否为当前线程，如果是则允许当前线程获取锁，并将 state + 1。</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> nextc = c + acquires;</span><br><span class="line">    <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span></span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么释放逻辑也需要对重入性额外处理</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        free = <span class="hljs-keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="hljs-keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>首先确保释放锁的线程为持有锁的线程，接下去确保重入次数和释放次数相同（即 state = 0）才认为释放锁完成，才会将持有锁的线程设为空。</strong></p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;ReentrantLock 的非公平锁模式意味着多个线程获取锁的顺序并不是按照申请锁的顺序，会存在“线程饥饿”的问题</p></blockquote><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="hljs-comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="hljs-keyword">int</span> c = getState();</span><br><span class="line">        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;</span><br><span class="line">            <span class="hljs-comment">// 先判断当前线程是否位于等待队列中的第一个</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁和非公平锁唯一的区别在于，它通过 hasQueuedPredecessors 确保当前线程是否位于等待队列中的第一个时才会尝试竞争锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasQueuedPredecessors</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="hljs-comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="hljs-comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="hljs-comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="hljs-keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="hljs-keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么也就是说<strong>公平模式的获取锁会先判断当前线程是否位于等待队列中的第一个，若不是则直接加入等待队列来确保多个线程按照申请锁的顺序来获取锁</strong></p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;公平模式可以解决线程饥饿问题，但相比非公平模式，也会使得更多的线程阻塞，产生更多 CPU 唤醒阻塞线程的开销而影响吞吐量</p></blockquote><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>Condition 是一个多线程间协调通信工具类，在 AQS 中实现，子类可以创建 Condition 实现类</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 添加到 Condition 队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 释放锁</span></span><br><span class="line">    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 判断是否在 AQS 队列，如果不在则阻塞</span></span><br><span class="line">    <span class="hljs-comment">// 唤醒时会将当前线程重新插入 AQS 队列尾</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="hljs-keyword">this</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)</span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 自旋获取锁直到重新阻塞</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Condition 存在自己的队列，在 Condition 队列就意味着线程需要 signal 方法唤醒。await 方法主要做以下几步：</p><ol><li>将当前线程加入 Condition 队列尾</li><li>释放锁，即从 AQS 队列中退出（因此线程不会同时存在于 AQS 队列和 Condition 队列）</li><li>阻塞当前线程等待唤醒（唤醒时会将当前线程重新插入 AQS 队列尾，然后当它的前驱结点释放锁后 unpark 唤醒，唤醒后自旋/阻塞获取锁）</li></ol><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 确保当前线程持有锁</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 将 Condition 队列中的首结点加入 AQS 队列</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal 方法用于唤醒处于 Condition 队列中的首结点，但注意它并不是立刻唤醒</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignal</span><span class="hljs-params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 移除头结点</span></span><br><span class="line">        <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="hljs-keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transferForSignal</span><span class="hljs-params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="hljs-keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 仅在前驱节点的状态处于取消状态或设置前驱节点状态为 SIGNAL 失败时才会直接唤醒</span></span><br><span class="line">    <span class="hljs-comment">// 大部分情况都不会在这里唤醒</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal 方法的主要逻辑如下：</p><ol><li>首先它会将头结点从 Condition 队列取出</li><li>然后通过 enq 将当前线程加入 AQS 队列尾</li><li>仅在前驱节点的状态处于取消状态或设置前驱节点状态为 SIGNAL 失败时才会直接唤醒，否则是等待它在 AQS 队列的前驱结点释放锁后唤醒（这样它的前驱结点为头结点，它才有资格获取锁，唤醒才有意义）</li></ol><h3 id="signalAll"><a href="#signalAll" class="headerlink" title="signalAll"></a>signalAll</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">signalAll</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="hljs-keyword">if</span> (first != <span class="hljs-keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSignalAll</span><span class="hljs-params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="hljs-keyword">null</span>;</span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="hljs-keyword">while</span> (first != <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signalAll 和 signal 的区别就在于它会遍历 Condition 队列，把所有 Condition 队列中的结点放入 AQS 队列等待唤醒。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>一个经典的应用：生产者/消费者模式</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Random;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="hljs-keyword">private</span> Integer max;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition empty = lock.newCondition();</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition full = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ProducerConsumer</span><span class="hljs-params">(Queue&lt;Integer&gt; queue, Integer max)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="hljs-keyword">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Random random = <span class="hljs-keyword">new</span> Random();</span><br><span class="line">            <span class="hljs-keyword">for</span>(;;)&#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">while</span> (queue.size() &gt;= max) &#123;</span><br><span class="line">                        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                            full.await();</span><br><span class="line">                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">int</span> num = random.nextInt();</span><br><span class="line">                    <span class="hljs-keyword">if</span>(queue.size() &gt;= max) &#123;</span><br><span class="line">                        <span class="hljs-keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(num);</span><br><span class="line">                    empty.signalAll();</span><br><span class="line">                &#125;<span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="hljs-string">"Not safe"</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consume</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line">        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span>(;;) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                    <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                        <span class="hljs-keyword">try</span> &#123;                </span><br><span class="line">                            empty.await();</span><br><span class="line">                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    full.signalAll();</span><br><span class="line">                &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="hljs-keyword">int</span> max = <span class="hljs-number">10</span>;</span><br><span class="line">      </span><br><span class="line">        ProducerConsumer producerConsumer = <span class="hljs-keyword">new</span> ProducerConsumer(queue, max);</span><br><span class="line">        producerConsumer.produce();</span><br><span class="line">        producerConsumer.produce();</span><br><span class="line">        producerConsumer.consume();</span><br><span class="line">        producerConsumer.consume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况，不会出现 <code>Not safe</code></p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;Synchronized + wait/notify 的组合和 Lock + Condition 组合具有类似的功能，性能上的差别也不是很大，但它们仍然有许多区别。这里举几个典型的例子：</p><ul><li>Lock + Condition 可以选择公平/非公平模式，而 Synchronized + wait/notify 只能是非公平的</li><li>Lock + Condition 可以唤醒指定 Condition，而 Synchronized + wait/notify 不能指定</li><li>Lock + Condition 可以设置超时时间，而 Synchronized + wait/notify 只能等待唤醒或中断</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;ReentrantLock 是基于 AQS 同步器实现的互斥锁，它支持设置公平锁/非公平锁模式，同时具有可重入性。在这里讨论 ReentrantLock 对这些特性的支持及应用。&lt;/p&gt;
&lt;h2 id=&quot;标准模式&quot;&gt;&lt;a href=&quot;#标准模式&quot; class=&quot;headerlink&quot; title=&quot;标准模式&quot;&gt;&lt;/a&gt;标准模式&lt;/h2&gt;&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;X&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ReentrantLock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        lock.lock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;// ... method body&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            lock.unlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS同步器</title>
    <link href="http://yoursite.com/2019/01/10/AbstractQueuedSynchronizer%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <id>http://yoursite.com/2019/01/10/AbstractQueuedSynchronizer同步器/</id>
    <published>2019-01-10T11:53:57.000Z</published>
    <updated>2020-11-03T09:24:35.790Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在 java.util.concurrent (JUC) 并发包中，如 ReentrantLock，Semaphore，CountDownLatch 等并发类的同步控制都是基于 AbstractQueuedSynchronizer (简称 AQS) 这个同步器抽象类来实现的。在这里较为深入的讨论同步器抽象类的实现原理与应用。</p><h2 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h2><p>AbstractQueuedSynchronizer 内部维护着一个 FIFO 的 CLH 队列，队列中的每个 Node 代表着一个需要获取锁的线程</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/aqs01.png" alt=""></p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;自旋锁：自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是立刻进入线程挂起或睡眠状态。</p><ul><li>CLH 锁（Craig, Landin, and Hagersten  locks）：基于链表的可扩展、高性能、公平的自旋锁，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋</li><li>MCS 锁：在当前结点自旋，但由前驱结点通知其结束自旋</li></ul></blockquote><p>AQS 采用的是一种变种的 CLH 队列锁：原始 CLH 是在前驱结点自旋，通过判断 pred.locked 来自旋，而 <strong>AQS 的 CLH 则是根据前驱结点的状态来控制阻塞，不会一直自旋。同时当前驱结点释放锁时会去唤醒该结点使其参与竞争锁。</strong> AQS 的结点的定义如下：</p><a id="more"></a><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 指向 Condition 队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 结点中分别有指向前驱，后继的结点，入队时的线程以及结点状态（Condition 队列本文不涉及）。结点状态会存在以下几种：</p><ul><li>CANCELLED：线程取消</li><li>SIGNAL：当前线程的后继线程被阻塞或者即将被阻塞，当前线程释放锁或者取消后需要唤醒后继线程</li><li>CONDITION：在等待 Condition ，也就是在 Condition 队列中</li><li>PROPAGATE：当头结点处于 PROPAGATE，需要唤醒后继线程，为了保证共享模式下唤醒机制正常</li><li>0：初始状态</li></ul><p>基于上述 Node 的定义，AQS 基本属性如下：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 队列的头结点</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 队列的尾节点</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 同步状态</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;</span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>AbstractQueuedSynchronizer 的提供的接口主要有两种类型</p><h3 id="控制同步状态"><a href="#控制同步状态" class="headerlink" title="控制同步状态"></a>控制同步状态</h3><p>AbstractQueuedSynchronizer 并不实现同步接口，所有对同步状态的控制都交由子类同步组件控制。比如 tryAcquire 代表由子类控制当前线程是否能独占式获取同步状态成功</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean tryAcquire(int arg)</td><td>独占式获取同步状态</td></tr><tr><td>boolean tryRelease(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>int tryAcquireShared(int arg)</td><td>共享式获取同步状态</td></tr><tr><td>boolean tryReleaseShared(int arg)</td><td>共享式释放同步状态</td></tr><tr><td>boolean isHeldExclusively()</td><td>检测当前线程是否获取独占锁</td></tr></tbody></table><p>而在多线程环境中对状态的操纵必须确保原子性，因此它还提供了对状态控制的三组 API：</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>int getState()</td><td>获取同步状态</td></tr><tr><td>void setState()</td><td>设置同步状态</td></tr><tr><td>boolean compareAndSetState(int expect, int update)</td><td>通过 CAS 设置同步状态</td></tr></tbody></table><p>通过这三组 API，子类可以线程安全的控制同步状态（同时子类需要确保实现是非阻塞的）</p><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>模板方法封装了获取同步状态成功或失败后的在队列中的一系列操作，子类可以直接调用</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>独占式获取同步状态，该方法将会调用 tryAcquire 尝试获取同步状态。获取成功则返回，获取失败，线程进入同步队列等待。</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>响应中断版的 acquire</td></tr><tr><td>boolean tryAcquireNanos(int arg,long nanos)</td><td>超时 + 响应中断版的 acquire</td></tr><tr><td>void acquireShared(int arg)</td><td>共享式获取同步状态，同一时刻可能会有多个线程获得同步状态。比如读写锁的读锁就是就是调用这个方法获取同步状态的。</td></tr><tr><td>void acquireSharedInterruptibly(int arg)</td><td>响应中断版的 acquireShared</td></tr><tr><td>boolean tryAcquireSharedNanos(int arg,long nanos)</td><td>超时 + 响应中断版的 acquireShared</td></tr><tr><td>boolean release(int arg)</td><td>独占式释放同步状态</td></tr><tr><td>boolean releaseShared(int arg)</td><td>共享式释放同步状态</td></tr></tbody></table><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire 方法代表尝试获取一次互斥锁，需要子类根据需求去实现（比如 ReentrantLock 实现了公平锁和非公平锁），通过布尔变量来标志获取状态：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若获取失败，则通过 addWaiter 方法将当前线程添加至阻塞队列</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 将线程封装在Node节点中</span></span><br><span class="line">    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// CAS 尝试将该节点插在队列尾</span></span><br><span class="line">    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="hljs-keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 如果不成功则通过自旋的方式插到队尾，直到插入成功</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="hljs-keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="hljs-comment">// 设置头结点，初始情况下，头结点是一个空结点(这里不会直接返回，因此即使阻塞队列为空，当前节点仍然是插在空结点之后)</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// Must initialize</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        <span class="hljs-comment">// 插入该结点到队尾</span></span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="hljs-keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入完成后，则会调用 acquireQueued() 方法对该结点进行有限次自旋获取锁，并在到达边界条件后阻塞</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="hljs-comment">// 如果该节点的前一节点为头节点，那么它将有资格参与竞争锁</span></span><br><span class="line">            <span class="hljs-comment">// 如果获取锁成功，则将当前结点设为头结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span></span><br><span class="line">                failed = <span class="hljs-keyword">false</span>;</span><br><span class="line">                <span class="hljs-keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="hljs-comment">// 判断线程需不需要阻塞，和 CLH 不同，线程并不总是参与竞争锁，而是仅当线程被唤醒时竞争锁</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="hljs-comment">// 如果前驱节点为 SIGNAL 状态，那么在释放锁时会唤醒后继结点</span></span><br><span class="line">    <span class="hljs-comment">// 因此这种情况当前结点会阻塞自己</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 如果前驱节点为 CANCELLED 状态，那么从后向前找到第一个非取消状态的节点</span></span><br><span class="line">    <span class="hljs-comment">// 并更新当前结点的前驱为该结点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 如果前驱节点为 0 或 PROPAGATE，那么设置前驱结点的状态为 SIGNAL（可以说这一步才是标志会将每一个节点阻塞的一步）</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// LockSupport.park(this) 来挂起线程，然后就停在这里了，等待被唤醒</span></span><br><span class="line"><span class="hljs-comment">// 返回的时候会先判断是否由线程中断造成的，如果由线程中断造成，在这里会接下去置中断标记</span></span><br><span class="line"><span class="hljs-comment">// 而 lockInterruptibly 方法则是抛出异常</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span>  <span class="hljs-title">parkAndCheckInterrupt</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="hljs-keyword">this</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么总结下 acquire 方法的逻辑：</p><ol><li>尝试获取互斥锁，若获取成功则直接返回</li><li>若获取失败，则将当前线程添加到阻塞队列尾（CAS 操作插入，自旋直到插入成功为止）</li><li>自旋/阻塞获取锁<ol><li>尝试获取互斥锁（前驱结点必须为头结点时，当前结点才有资格竞争锁），若获取成功则将当前结点设为头结点后退出</li><li>若前驱结点为 SIGNAL 状态，则阻塞当前结点（唤醒后继续循环 <em>自旋/阻塞获取锁</em> ）</li><li>若前驱结点为 CANCELLED 状态，则更新前驱到非取消结点</li><li>若前驱结点为 0 或 PROPAGATE，则设置前驱结点状态为 SIGNAL 状态</li></ol></li></ol><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// h == null 的情况就是阻塞队列为空（前面说过，第一个线程持有锁时不会放到头结点中）</span></span><br><span class="line">        <span class="hljs-comment">// h.waitStatus = 0，那么其后的结点必定没有阻塞（前面也说过，因为该值是由后继结点来赋值的，然后仅当该结点状态为阻塞状态，后继结点才会将自己阻塞，即 CLH 特性，根据前驱结点状态来控制自己）</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryRelease 方法代表尝试释放一次互斥锁，需要子类根据需求去实现，通过布尔变量来标志获取状态：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在释放锁成功后，会判断当前结点状态来唤醒后继结点，即当前结点状态为 SIGNAL 状态时会唤醒后继结点</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)</span><br><span class="line">    unparkSuccessor(h);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-comment">// 设置头结点状态为 0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 从队尾往前找，找到 waitStatus &lt;= 0 的所有节点中排在最前面的(&gt; 0 代表节点取消阻塞)</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        s = <span class="hljs-keyword">null</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 唤醒该节点，也就是头结点的下一个不为取消阻塞状态的节点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么总结下 release 方法的逻辑：</p><ol><li>尝试释放一次互斥锁，若释放失败，则直接返回失败</li><li>释放成功后，唤醒一个后继结点</li></ol><h2 id="互斥锁案例"><a href="#互斥锁案例" class="headerlink" title="互斥锁案例"></a>互斥锁案例</h2><p>通过以上的理解，可以实现一个简单的互斥锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutexLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MutexLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Sync</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            setState(<span class="hljs-number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))&#123;</span><br><span class="line"></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> release)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span>(getState() == <span class="hljs-number">0</span>)&#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);</span><br><span class="line">            setState(<span class="hljs-number">0</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquireInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.release(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类 Sync 继承 AbstractQueuedSynchronizer，并重载 tryAcquire 和 tryRelease 方法</p><ul><li>tryAcquire 通过 CAS 尝试获取一次同步状态（0 -&gt; 1），若获取成功则设置当前持有锁的线程为自己</li><li>tryRelease 判断同步状态是否为 1，若是则重置同步状态为 0，且设置当前获取锁的线程为 null，否则抛出异常（互斥锁的释放不会有并发）</li></ul><p>我们可以写个简单的并发计数测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 计数</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">final</span> Mutex mutex = <span class="hljs-keyword">new</span> Mutex();</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        count = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++)&#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">                        mutex.lock();</span><br><span class="line"></span><br><span class="line">                        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;<span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                            mutex.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="hljs-string">"assert "</span> + threadCnt * <span class="hljs-number">10000</span> + <span class="hljs-string">" = "</span> + count + <span class="hljs-string">" is true"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常输出为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert 100000 = 100000 is true</span><br></pre></td></tr></table></figure><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><h3 id="acquireShared"><a href="#acquireShared" class="headerlink" title="acquireShared"></a>acquireShared</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquireShared 方法尝试获取一次共享锁，需要子类根据需求去实现。但和互斥锁不同的是，它以整型作为状态标志，负数代表获取失败，非负数代表获取成功，0 代表成功但之后的竞争线程不会成功</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取共享锁失败时，会调用 doAcquireShared 将当前线程添加至阻塞队列并自旋获取共享锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 将当前线程添加至阻塞队列</span></span><br><span class="line">    <span class="hljs-keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="hljs-keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="hljs-comment">// 如果该节点的前一节点为头节点，那么它将有资格参与竞争锁</span></span><br><span class="line">            <span class="hljs-comment">// 如果获取锁成功，则将当前结点设为头结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                    <span class="hljs-comment">// 和互斥锁不同的点，共享锁会在获取锁成功后唤醒后继结点</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="hljs-keyword">false</span>;</span><br><span class="line">                    <span class="hljs-keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 判断线程需不需要阻塞</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的大体逻辑和互斥锁的自旋获取锁逻辑相同，但是它们之间有个很重要的不同点，即共享锁在获取锁成功后调用 setHeadAndPropagate 来唤醒后继结点</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="hljs-comment">// Record old head for check below</span></span><br><span class="line">    <span class="hljs-comment">// 设为头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 唤醒后继结点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-keyword">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReleaseShared</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="hljs-keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="hljs-comment">// 如果头结点处于 SIGNAL 状态，唤醒后继结点</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))</span><br><span class="line">                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-comment">// 如果头结点处于 0 的状态，设置头结点状态为 PROPAGATE</span></span><br><span class="line">            <span class="hljs-comment">// 这是为了解决共享锁的并发唤醒后继结点导致极端情况下存在线程永远无法唤醒的情况</span></span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))</span><br><span class="line">            <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span></span><br><span class="line">            <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在判断是否需要唤醒后继结点这步，它的判断逻辑是 propagate &gt; 0 || h.waitStatus &lt; 0：</p><ul><li>propagate &gt; 0 ：tryAcquireShared 方法的返回值，代表当前线程获取共享锁成功（按理说 propagate = 0 的情况也属于获取锁成功，为什么不加进去呢？这是因为当 propagate = 0 时代表当前已经没有共享资源了，所以唤醒也没有意义了）</li><li>h.waitStatus &lt; 0 ：头结点状态为 SIGNAL 或 PROPAGATE 时</li></ul><blockquote><p><i class="far fa-bell"></i> </p><p>&emsp;&emsp;在共享锁中会存在 PROPAGATE 状态：</p><ul><li><p>获取共享锁成功后，如果头结点状态为 0（unparkSuccessor 时会将头结点状态设为0），会将头结点状态设为 PROPAGATE</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="line">​    !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))</span><br><span class="line">​    <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span></span><br></pre></td></tr></table></figure></li><li><p>判断后继结点是否需要唤醒时会判断头结点的状态 propagate &gt; 0 || h.waitStatus &lt; 0</p></li></ul><p>之所以需要这个状态是因为共享锁的 <em>唤醒后继结点</em>  操作是并发操作，同时 propagate = 0 的情况不会唤醒后继结点，因此在一些极端情况下会存在阻塞结点无法被唤醒的情况</p></blockquote><p>那么我们总结下获取共享锁的逻辑：</p><ol><li>尝试获取共享锁，若获取成功则直接返回</li><li>若获取失败，则将当前线程添加到阻塞队列尾（CAS 操作插入，自旋直到插入成功为止）</li><li>自旋/阻塞获取锁<ol><li>尝试获取共享锁（前驱结点必须为头结点时，当前结点才有资格竞争锁），若获取成功则尝试唤醒一个<strong>后继结点</strong>（唤醒的结点如果获取锁成功又会继续唤醒接下去的结点）</li><li>前驱结点为 SIGNAL 状态，则阻塞当前结点（唤醒后继续循环 <em>自旋/阻塞获取锁</em> ）</li><li>前驱结点为 CANCELLED 状态，则更新前驱到非取消结点</li><li>前驱结点为 0 或 PROPAGATE，则设置前驱结点状态为 SIGNAL 状态</li></ol></li></ol><blockquote><p>不知道大家注意到了没有，在获取共享锁时，若新线程直接通过 tryAcquireShared 获取锁成功，它是不会入 Node 结点的，那么它也就不会去传播式的唤醒 CLH 队列中的后继节点了，这和上面的结论是否存在矛盾呢？其实这是正常的，我们可以考虑正在和新线程争抢共享锁的结点（头结点的后继结点），如果它抢到了共享锁，那么它会去唤醒后继节点；如果连它都抢不到锁，那么唤醒后继节点已经没有必要了。这个时候只需要等某个持有共享锁的线程释放锁来唤醒就可以了</p></blockquote><h3 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">releaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryReleaseShared 方法代表尝试释放一次共享锁，需要子类根据需求去实现，通过布尔变量来标志获取状态：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放成功后会调用 doReleaseShared 尝试唤醒一个后继结点，上面已经解释了。</p><h2 id="共享锁案例"><a href="#共享锁案例" class="headerlink" title="共享锁案例"></a>共享锁案例</h2><p>基于以上分析，我们也可以实现一个同时允许 N 个线程进入的共享锁</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShareLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ShareLock</span><span class="hljs-params">(Integer permit)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync(permit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="hljs-keyword">int</span> permit)&#123;</span><br><span class="line"></span><br><span class="line">            setState(permit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquire)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">int</span> expect = getState();</span><br><span class="line">                <span class="hljs-keyword">int</span> update = expect - acquire;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span>(update &lt; <span class="hljs-number">0</span> || compareAndSetState(expect, update))&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">return</span> update;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-meta">@Override</span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> release)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">int</span> expect = getState();</span><br><span class="line">                <span class="hljs-keyword">int</span> update = expect + release;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-keyword">if</span>(compareAndSetState(expect, update))&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquireShared(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquireShared(<span class="hljs-number">1</span>) &gt;= <span class="hljs-number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        sync.releaseShared(<span class="hljs-number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来对共享锁进行简单的测试：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">final</span> ShareLock shareLock = <span class="hljs-keyword">new</span> ShareLock(<span class="hljs-number">2</span>);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">100</span>),</span><br><span class="line">                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">int</span> threadCnt = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; threadCnt; i++)&#123;</span><br><span class="line"></span><br><span class="line">            executorService.execute(<span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="hljs-meta">@Override</span></span><br><span class="line">                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    shareLock.lock();</span><br><span class="line"></span><br><span class="line">                    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": is running"</span>);</span><br><span class="line"></span><br><span class="line">                        Thread.sleep(<span class="hljs-number">2000</span>);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                        shareLock.unlock();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            executorService.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.DAYS);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试程序创建了一个允许最多两个线程同时进入的共享锁。因此正常情况下，日志会成双打印。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><ul><li>thread.interrupt()：中断线程，将会设置该线程的中断状态位，即设置为 true（<strong>不会中断一个正在运行的线程，而是中断阻塞的线程</strong>）</li><li>thread.interrupted()：判断某个线程是否已被发送过中断请求，该方法调用后会将中断标示位清除，即重新设置为 false</li><li>Thread.currentThread().isInterrupted()：判断某个线程是否已被发送过中断请求，不会将中断标示位清除</li></ul><p>如果一个线程处于了阻塞状态（如线程调用了 thread.sleep、thread.join、thread.wait、1.5 中的 condition.await、以及可中断的通道上的 I/O 操作方法后可进入阻塞状态），线程在检查中断标示时如果发现中断标示为 true，则会在这些阻塞方法调用处抛出 InterruptedException 异常，并且在抛出异常后立即将线程的中断标示位清除，即重新设置为 false。而如果线程处于非阻塞状态，则需要通过判断 Thread.interrupted() 或者 Thread.isInterrupted() 来循环检测</p><blockquote><p><i class="far fa-bell"></i> </p><ol><li><p>Synchronized 在获锁的过程中是不能被中断的，意思是说如果产生了死锁，则不可能被中断</p></li><li><p>LockSupport 的 park 方法阻塞，能够响应中断，但是不会抛出 InterruptedException 异常</p></li><li><p>一个支持中断线程的程序的标准处理模式</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">​    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">​        <span class="hljs-comment">// do something</span></span><br><span class="line"></span><br><span class="line">​        <span class="hljs-comment">// 1. !Thread.currentThread().isInterrupted() 确保在非阻塞时能响应中断</span></span><br><span class="line">​        <span class="hljs-comment">// 2. try-catch 后对 InterruptedException 处理确保阻塞时对中断进行处理</span></span><br><span class="line">​        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="hljs-keyword">do</span>) &#123;</span><br><span class="line">​            <span class="hljs-keyword">do</span> more work </span><br><span class="line">​        &#125;</span><br><span class="line">​    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">​        <span class="hljs-comment">//线程在 wait 或 sleep 期间被中断了</span></span><br><span class="line">​    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">​        <span class="hljs-comment">//线程结束前做一些清理工作</span></span><br><span class="line">​    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>在之前所说的 acquire，ascquireShared 方法均不支持中断操作</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="hljs-keyword">true</span>;</span><br></pre></td></tr></table></figure><p>它们在 LockSupport.park 响应中断后只是置一个中断标记，但是并不会处理，仍然自旋获取锁直到获取成功或阻塞。而 acquireInterruptibly，acquireSharedInterruptibly 方法支持中断操作</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure><p>它们会在 LockSupport.park 响应中断后抛出 InterruptedException 异常结束线程</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://segmentfault.com/a/1190000014721183" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></li><li><a href="http://ifeve.com/introduce-abstractqueuedsynchronizer/" target="_blank" rel="noopener">AbstractQueuedSynchronizer的介绍和原理分析</a></li><li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;在 java.util.concurrent (JUC) 并发包中，如 ReentrantLock，Semaphore，CountDownLatch 等并发类的同步控制都是基于 AbstractQueuedSynchronizer (简称 AQS) 这个同步器抽象类来实现的。在这里较为深入的讨论同步器抽象类的实现原理与应用。&lt;/p&gt;
&lt;h2 id=&quot;AQS简介&quot;&gt;&lt;a href=&quot;#AQS简介&quot; class=&quot;headerlink&quot; title=&quot;AQS简介&quot;&gt;&lt;/a&gt;AQS简介&lt;/h2&gt;&lt;p&gt;AbstractQueuedSynchronizer 内部维护着一个 FIFO 的 CLH 队列，队列中的每个 Node 代表着一个需要获取锁的线程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/aqs01.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;i class=&quot;far fa-bell&quot;&gt;&lt;/i&gt; 
&lt;p&gt;&amp;emsp;&amp;emsp;自旋锁：自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是立刻进入线程挂起或睡眠状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CLH 锁（Craig, Landin, and Hagersten  locks）：基于链表的可扩展、高性能、公平的自旋锁，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋&lt;/li&gt;
&lt;li&gt;MCS 锁：在当前结点自旋，但由前驱结点通知其结束自旋&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;AQS 采用的是一种变种的 CLH 队列锁：原始 CLH 是在前驱结点自旋，通过判断 pred.locked 来自旋，而 &lt;strong&gt;AQS 的 CLH 则是根据前驱结点的状态来控制阻塞，不会一直自旋。同时当前驱结点释放锁时会去唤醒该结点使其参与竞争锁。&lt;/strong&gt; AQS 的结点的定义如下：&lt;/p&gt;
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>内存屏障</title>
    <link href="http://yoursite.com/2018/12/22/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    <id>http://yoursite.com/2018/12/22/内存屏障/</id>
    <published>2018-12-22T14:17:33.000Z</published>
    <updated>2020-02-06T04:22:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;现代计算机大多数采用多核处理器或多处理器以提高性能，同时每个处理器通常存在一层或多层高速缓存，这将会更进一步加快对数据的访问。但是这也带来了新的挑战，即同一数据在不同处理器之间并不保证一致。所以为了保证数据的可见性，内存屏障应运而生。它能够刷新或使本地处理器高速缓存失效，以便查看其他处理器进行的写入的最新值或使该处理器的写入对其他处理器可见。而 Java 内存模型用于屏蔽不同硬件所带来的内存访问差异，以实现程序在不同平台能保证一致的并发效果。那么在并发环境下如何正确的使用内存屏障成为了首要问题。</p><h2 id="硬件内存架构"><a href="#硬件内存架构" class="headerlink" title="硬件内存架构"></a>硬件内存架构</h2><p>Java 内存模型是对硬件内存模型的抽象，因此理解它需要一些硬件基础知识。这里主要介绍 <strong>处理器的存储器结构</strong> 和 <strong>处理器的高速缓存与缓存一致性</strong></p><h3 id="随机访问存储器（RAM）"><a href="#随机访问存储器（RAM）" class="headerlink" title="随机访问存储器（RAM）"></a>随机访问存储器（RAM）</h3><p>随机访问存储器（RAM），是用于和 CPU 交换数据的内部存储器。根据存储单元的工作原理不同可以分为两类：</p><ul><li>动态的存储器（DRAM）</li><li>静态的存储器（SRAM）</li></ul><p>SRAM 比 DRAM 更快，但也更贵，因此 SRAM 主要作为高速缓存存储器（Cache，如 CPU 的 L1，L2），而 DRAM 则作为计算机主存。而我们常说的内存指的就是是计算机的主内存 DRAM。</p><a id="more"></a><h3 id="总线（Bus）"><a href="#总线（Bus）" class="headerlink" title="总线（Bus）"></a>总线（Bus）</h3><p>总线是一组并行的导线，能携带地址，数据和控制信号，用于计算机各种功能部件（CPU，DRAM，I/O 设备等）之间传送信息。根据传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线。<strong>CPU 则是通过数据总线与内存交换数据的（即通信）</strong></p><blockquote><p>CPU 和主存（DRAM）之间的数据传送称为总线事务，读事务代表从主存传送数据到 CPU，写事务代表从 CPU 传送数据到主存。</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/bus.png" alt=""></p><p>它们同个两条总线连接起来，一条是系统总线（连接 CPU 和 I/O 桥接器），一条是内存总线（连接 I/O 桥接器和 DRAM），其中 I/O 桥接器会将系统总线的电子信号翻译成内存总线的电子信号。</p><ul><li><p>读事务（movq A, %rax）：</p><ul><li>首先 CPU 将地址 A 放到系统总线并通过 I/O 桥传递到内存总线</li><li>接着 DRAM 感受到内存总线的地址信号并读取地址，并将其对应的数据写回内存总线通过 I/O 桥传递到系统总线</li><li>最后 CPU 感觉到系统总线的数据并读取数据复制到寄存器中完成读事务。</li></ul><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/bus-read-trans.png" alt=""></p></li><li><p>写事务（movq %rax, A）：</p><ul><li>首先 CPU 将地址 A 放到系统总线，DRAM 从内存总线读出地址，并等到数据到达</li><li>接着，CPU 将寄存器中的 %rax 放到系统总线</li><li>最后，DRAM 从内存总线读出数据，并存储到 DRAM 中</li></ul><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/bus-write-trans.png" alt=""></p></li></ul></blockquote><h3 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h3><p>以一个经典的存储器层次结构举例，所有现代计算机系统都是采用这种结构</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/memory-hierarchy.png" alt=""></p><p>从上至下，存储设备的速度变得更慢，容量更大。顶层是最快的寄存器，CPU 可以在一个时钟周期内访问，接下来是 L1 - L3 缓存（它们用的就是之前所说的 SRAM），然后就是计算机主存（DRAM），再往下就是磁盘等等。</p><p>而 Inter Core i7 中的高速缓存如下：</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/intel-core-i7.png" alt=""></p><p>Intel Core i7 处理器的的每个 CPU 芯片有 4 个核。每个核有自己私有的 L1，L2 高速缓存，所有的核共享 L3 统一高速缓存。</p><h3 id="高速缓存的读和写"><a href="#高速缓存的读和写" class="headerlink" title="高速缓存的读和写"></a>高速缓存的读和写</h3><p>略过把内存地址映射到快速缓存块的内容（这里不需要相关知识），高速缓存的读分为缓存命中和缓存不命中。</p><ul><li>对于缓存命中，即当程序需要读取 K + 1 层的某个数据时，当前 K 层的缓存已经存在，那么直接读取数据</li><li>而对于缓存不命中，即 K 层没有存储数据，那么将从 K + 1 层缓存读取数据，同时如果 K 层的缓存已经满了，可能需要覆盖现存的块。如通过 LRU 算法替换被访问时间距现在最远的块。</li></ul><p>而对于高速缓存的写则有两种方案</p><ul><li><p>直写（write through） + 非写分配（not write allocate）：</p><ul><li><p>直写：写命中时（即要写一个已经缓存的数据），同时写入缓存以及主内存</p></li><li><p>非写分配：写不命中时，不将写入位置读入缓存，直接将数据写入主内存</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/write_through.png" alt=""></p></li></ul></li><li><p>回写（write back） + 写分配（write allocate）：</p><ul><li><p>回写：写命中时，只写入缓存，只在数据被替换出缓存时才会将数据写到主内存</p></li><li><p>写分配：写不命中时，将写入位置读入缓存，然后以写命中的方式进行写入（即回写）</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/write_back.png" alt=""></p></li></ul></li></ul><p>有些（大多数是比较老的）CPU 只使用直写模式，有些只使用回写模式，还有一些，一级缓存使用直写而二级缓存使用回写。这样做虽然在一级和二级缓存之间产生了不必要的数据流量，但二级缓存和更低级缓存或内存之间依然保留了回写的优势。对于直写（write through），它需要一个写缓冲区（write buffer）将高速缓存写入的数据保存的主内存中</p><blockquote><i class="far fa-bell"></i> <p> &emsp;&emsp;写缓冲区的作用类似于异步处理来提高性能，比如当 CPU 的写入速度比缓存响应的还快时则减少了等待的时间，大大提高性能；同时它还能聚合多个写入到同一个缓存块从而减少下一级缓存的流量</p></blockquote><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>如果系统只有一个 CPU 核在工作，那么一些都没有问题。而如果一个 CPU 有多个核，且每个核都有自己的缓存，那么就会遇到问题：如果某个 CPU 缓存段中对应的内存内容被另外一个 CPU 改了，它无法感知到。而对于回写模式，写指令甚至会在执行过后很久才会真正写到 DRAM 中，这就造成了多组缓存不一致的问题。</p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;注意，这个问题的原因不在于多核而在于多组缓存。假如多个 CPU 核共用一组缓存，是不会存在这个问题的</p></blockquote><p>为了保证缓存一致性，MESI 协议就出现了。MESI 是四种缓存段状态的首字母缩写，任何多核系统中的缓存段都处于只有四种状态：失效（Invalid）缓存段，共享（Shared）缓存段，独占（Exclusive）缓存段，已修改（Modified）缓存段。</p><blockquote><i class="far fa-bell"></i> <ul><li>失效（Invalid）缓存段: 要么已经不在缓存中，要么它的内容已经过时。为了达到缓存的目的，这种状态的段将会被忽略。一旦缓存段被标记为失效，那效果就等同于它从来没被加载到缓存中。 </li><li>共享（Shared）缓存段，它是和主内存内容保持一致的一份拷贝，在这种状态下的缓存段只能被读取，不能被写入。多组缓存可以同时拥有针对同一内存地址的共享缓存段，这就是名称的由来。</li><li>独占（Exclusive）缓存段，和 S 状态一样，也是和主内存内容保持一致的一份拷贝。区别在于，如果一个处理器持有了某个 E 状态的缓存段，那其他处理器就不能同时持有它，所以叫“独占”。这意味着，如果其他处理器原本也持有同一缓存段，那么它会马上变成“失效”状态。</li><li>已修改（Modified）缓存段，属于脏段，它们已经被所属的处理器修改了。如果一个段处于已修改状态，那么它在其他处理器缓存中的拷贝马上会变成失效状态，这个规律和E状态一样。此外，已修改缓存段如果被丢弃或标记为失效，那么先要把它的内容回写到内存中——这和回写模式下常规的脏段处理方式一样。</li></ul></blockquote><p>该协议保证：只有当缓存段处于 E 或 M 状态时处理器才能去修改它，也就是说只有这两种状态下，处理器是独占这个缓存段的。当处理器想写某个缓存段时，如果它没有独占权，它必须先发送一条“我要独占权”的请求给总线，这会通知其他处理器，把它们拥有的同一缓存段的拷贝失效。</p><p>而如果有其他处理器想读取这个缓存段，独占或已修改的缓存段必须先回到“共享”状态。如果是已修改的缓存段，那么还要先把内容回写到内存中。 </p><p>也就是说，<strong>MESI 保证一旦某个缓存段被回写修改后（M 状态），任意缓存级别的所有缓存段的内容和它对应的内存内容一致</strong></p><h3 id="写缓冲区和失效队列"><a href="#写缓冲区和失效队列" class="headerlink" title="写缓冲区和失效队列"></a>写缓冲区和失效队列</h3><p>缓存一致性已经能够保证对单个地址的读写的内存上的完整一致性，但是同步等待其他处理器指令返回影响了处理性能。<strong>因此在寄存器和 L1 缓存之间会有读写缓冲区（LoadBuffer,  StoreBuffer），合称排序缓冲（Memoryordering Buffers ，MOB ）。它们使得 CPU 异步处理读写指令，即当前处理器不需要等待其他处理器的失效确认（Invalidate Acknowlege）返回，会直接处理接下去的指令。</strong>  比如</p><ul><li>写指令：对于已处于 E（独占）状态的缓存行，CPU 会直接写入缓存行；而对于其他需要切换回 E 状态的情况，则首先向其他处理器发出失效指令，接着把要写入到主存的值写到 StoreBuffer，然后处理接下去指令。而 StoreBuffer 中的数据则等待失效确认（Invalidate Acknowlege）返回后统一刷新到内存。</li><li>读指令：对于处于 S（共享）状态的缓存行命中时，CPU 会直接读取缓存完成读指令；而对于其他状态需要切回 S 状态的情况，则会放入 LoadBuffer 中等待确认后处理</li></ul><p>但是这会导致一个严重的问题：</p><p>&emsp;&emsp;<em>即使读写指令本身是按照顺序执行的，但最终仍然存在指令重排序</em></p><p>比如按顺序执行 A, B 两个写指令，A 写指令所在缓存行处于 S 状态，B 写指令所在缓存行处于E状态，那么 B 会比 A 先完成写入操作；又或者按顺序执行 C, D 两个读指令，C 读指令所在缓存行处于 I 状态，D 读指令所在缓存行处于 S 状态，那么 D 会比 C 先完成读取操作。</p><p>同时处理器执行失效也不是一个简单的操作，它需要占用处理器的时间，如果接受的 invalidate 请求过多，cpu 处理速度就跟不上，因此又出现了失效队列（invalidate queue），它保证：</p><ul><li><p>对于所有的收到的 Invalidate 请求，Invalidate Acknowlege 消息必须立刻发送返回</p></li><li><p>Invalidate 并不真正执行，而是被放在一个失效队列中，在方便的时候才会去执行。</p><blockquote><p>当然，这里必须不能太慢。也就是说，cpu 实际上给出了一个承诺，如果一个 invalidatge 请求在 invalidate queue 中，那么对于这个请求相关的 cacheline，在该请求被处理完成前，cpu 不会再发送任何与该 cacheline 相关的 MESI 消息。 </p></blockquote></li></ul><p>同样这也会导致一个严重的问题：</p><p>&emsp;&emsp;<em>读取的时候有可能会读到过时的数据</em> </p><p>比如 CPU0 执行写指令，它向 CPU1 发出失效指令，然后 CPU1 立刻返回失效确认，但实际上并未真正执行失效操作。这时 CPU0 则更新了缓存行，造成了不同处理器直接的数据不一致。</p><p>所以我们现在可以总结下目前遇到的问题：</p><ul><li><strong>乱序处理器在满足 As-if-Serial 特性的基础下，本身就不会严格按照程序的顺序向缓存发送内存操作指令，导致指令重排序。</strong> </li><li><strong>Java 运行时环境的 JIT 编译器指令重排序</strong> </li><li><strong>由于 store buffer 和 invalidate queue 导致的内存可见性问题（即内存重排序）</strong> </li></ul><blockquote><p><i class="far fa-bell"></i> </p><p>&emsp;&emsp;As-if-serial 语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。比如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">double</span> pi  = <span class="hljs-number">3.14</span>;    <span class="hljs-comment">// A</span></span><br><span class="line"><span class="hljs-keyword">double</span> r   = <span class="hljs-number">1.0</span>;     <span class="hljs-comment">// B</span></span><br><span class="line"><span class="hljs-keyword">double</span> area = pi <em> r </em> r; <span class="hljs-comment">// C </span></span><br></pre></td></tr></table></figure><p>这里例子中，A 和 B 可以重排序，但是 A 和 C，B 和 C 不行，因为它们存在数据依赖关系。但需要注意的是，控制依赖仍然会存在重排序，比如：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReorderExample</span> </span>&#123;</span><br><span class="line">​    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;</span><br><span class="line">​    <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="hljs-number">1</span>;                   <span class="hljs-comment">//1</span></span><br><span class="line">        flag = <span class="hljs-keyword">true</span>;             <span class="hljs-comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function">Public <span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (flag) &#123;                <span class="hljs-comment">//3</span></span><br><span class="line">            <span class="hljs-keyword">int</span> i =  a * a;        <span class="hljs-comment">//4</span></span><br><span class="line">            ……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来 3 和 4 存在控制依赖关系，不应该重排序，而实际上，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。这里 3 和 4 操作可能会被重排序为：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 先把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中</span></span><br><span class="line">temp = a * a;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">if</span>(flag)&#123;</span><br><span class="line">​    <span class="hljs-comment">// 当flag为真后再赋值进去</span></span><br><span class="line">​    <span class="hljs-keyword">int</span> i = temp </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>那么它们会导致什么问题呢？我们以两个典型的案例来让问题显形：</p><ul><li><p>CPUB 依赖于 CPUA 发出的信号来执行逻辑</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DRAM: x = 0; y = false;</span><br><span class="line"></span><br><span class="line">CPUA:</span><br><span class="line">  x = 1;</span><br><span class="line">  y = true;</span><br><span class="line"></span><br><span class="line">CPUB:</span><br><span class="line">  if(y)&#123;</span><br><span class="line">    assert x = 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个案例有可能会出现 CPUB 断言错误的情况，可能原因有以下几种</p><ul><li>由于指令重排序，CPUA 的两个写入指令重排序，导致 CPUB 读取到 y = true 时，x = 0</li><li>虽然指令未重排序，但由于 store buffer 的存在导致 CPUA 对 x = 1的指令写入主内存不及时使得 y = true 先被写入内存，那么 CPUB 就有可能读到老数据</li><li>虽然指令未重排序，但由于 invalidate queue 的存在导致虽然 Invalidate Acknowlege 返回后使得 store buffer 的数据已经回写到主存，但是由于失效消息未处理导致 CPUB 的缓存行仍有效，读到了老数据。</li></ul></li><li><p>CPUA，CPUB 互相读取对方的写入</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DRAM:</span><br><span class="line">  x, y, r1, r2 = 0</span><br><span class="line"></span><br><span class="line">CPUA:</span><br><span class="line">  x = 1;</span><br><span class="line">  r1 = y;</span><br><span class="line">  </span><br><span class="line">CPUB：</span><br><span class="line">  y = 1;</span><br><span class="line">  r2 = x;</span><br></pre></td></tr></table></figure><p>和上述类似同样的原因，这个案例有可能会出现 r1 = r2 = 0 的情况。</p></li></ul><p>为了解决上述案例产生的问题，内存屏障诞生  =͟͟͞͞( •̀д•́)</p><h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>JDK1.7 根据 store/load 指令的先后顺序将内存屏障分为以下四种：</p><p><img src="https://zzcoder.oss-cn-hangzhou.aliyuncs.com/juc/jdk-memory-barriers.png" alt=""></p><ul><li><p>LoadLoad 屏障</p><ul><li>防止 LoadLoad 屏障前后的读指令的指令重排序</li><li>处理器以阻塞的方式先处理失效队列的消息，防止读取到老数据</li></ul></li><li><p>StoreStore 屏障</p><ul><li>防止 StoreStore 屏障前后的写指令的指令重排序</li><li>处理器以阻塞的方式将当前存储缓存（store buffer）的值写回主存</li></ul></li><li><p>LoadStore 屏障</p><ul><li>防止 LoadStore 屏障前的读指令和屏障后的写指令的指令重排序</li><li>处理器以阻塞的方式先处理失效队列的消息，防止读取到老数据</li></ul><p>在 JVM 中，实际上它和 LoadLoad 屏障作用是相同的，底层都是调用 acquire() 方法</p></li><li><p>StoreLoad 屏障</p><ul><li><strong>防止 StoreLoad 屏障前后的所有读写指令的指令重排序</strong></li><li>处理器以阻塞的方式将当前存储缓存（store buffer）的值写回主存</li><li>处理器以阻塞的方式先处理失效队列的消息，防止读取到老数据</li></ul><p>该屏障同时具备另三种屏障的作用，因此开销也最大。</p></li></ul><p>它们并不是真正意义上的内存屏障，只是一种抽象的概念。在不同硬件中，内存屏障会有不同的实现。比如 x86 的 64 位 CPU 提供了 mfence, lfence, sfence 指令来提供内存屏障，而 x86 的 32 位 CPU 则不提供 mfence、lfence、sfence 三条汇编指令的支持。因此 Linux 内核定义 smp_mb, smp_rmb，smp_wmb 三种内存屏障来处理不同处理器架构（比如对于 X86-64 直接使用上述指令，而对于 X86-32 则通过 lock 前缀来实现）</p><h2 id="案例重现"><a href="#案例重现" class="headerlink" title="案例重现"></a>案例重现</h2><p>了解了内存屏障的作用后，我们重新再来分析之前的两个案例</p><ul><li><p>CPUB 依赖于 CPUA 发出的信号来执行逻辑</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DRAM: </span><br><span class="line">  x = 0; y = false;</span><br><span class="line"></span><br><span class="line">CPUA:</span><br><span class="line">  x = 1;</span><br><span class="line">  StoreStore()</span><br><span class="line">  y = true;</span><br><span class="line"></span><br><span class="line">CPUB:</span><br><span class="line">  if(y)&#123;</span><br><span class="line">    LoadLoad()</span><br><span class="line">    assert x = 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们在 CPUA 和 CPUB 的程序中分别插入 StoreStore 屏障和 LoadLoad 屏障。它们能保证以下三点：</p><ul><li>CPUA 的写写指令，CPUB 的读读指令不能重排序</li><li>CPUA 写入 x 变量的值后保证将 store buffer 缓存的数据写回主内存。即写入 x 到主内存一定先于 y</li><li>CPUB 在读取到 y 的值后保证先处理 invalidate queue 的失效消息，即读取到 y 会重新从主内存获取最新的 x 的值</li></ul><p>那么这就保证一个顺序链：x 写入到主存 &lt; y 写入到主存 &lt; y 从主存读取数据 &lt; x 从主存读取数据。也就意味值：一旦 CPUB 读取到 y = true，x 的值总是等于 1</p></li><li><p>CPUA，CPUB 互相读取对方的写入</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DRAM:</span><br><span class="line">  x, y, r1, r2 = 0</span><br><span class="line"></span><br><span class="line">CPUA:</span><br><span class="line">  x = 1;</span><br><span class="line">  StoreLoad();</span><br><span class="line">  r1 = y;</span><br><span class="line">  </span><br><span class="line">CPUB：</span><br><span class="line">  y = 1;</span><br><span class="line">  StoreLoad();</span><br><span class="line">  r2 = x;</span><br></pre></td></tr></table></figure><p>我们在 CPUA 和 CPUB 的程序中都插入了 StoreLoad 屏障。它们能保证以下三点：</p><ul><li><p>CPUA 和 CPUB 均不会对写入 x 和读取 y 两个操作重排序</p></li><li><p>CPUA 和 CPUB 写入值后保证将 store buffer 缓存的数据写回主内存</p></li><li>CPUA 和 CPUB 读取值之前保证先处理 invalidate queue，即总是读到主内存的最新数据</li></ul><p>那么我们可以推导出，当任一处理器执行到读取指令时，必定已经写入了当前值到主存且重新从主存读取数据，那么 r1 = r2 = 0 的情况也是不可能的了。</p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;该案例必须使用 StoreLoad 屏障。因为 CPUA 的读的值依赖于 CPUB 的写，而 CPUB 的读的值也依赖于 CPUA 的写，那么就需要同时保证写的及时性和读的正确性了。而每个处理器同时插入两条屏障（LoadLoad 屏障，StoreStore 屏障）也是不行的，因为它们都不能保证读写指令的重排序。</p></blockquote></li></ul><h2 id="volatile小解"><a href="#volatile小解" class="headerlink" title="volatile小解"></a>volatile小解</h2><p>JMM 通过内存屏障实现了 volatile 的内存语义，这里简单的讨论它的两点特性</p><p>&emsp;&emsp;<code>volatile 如何保证读取能读取到最新值？</code></p><p>仅从 CPU 层面来看，单个变量能够保证最终一致性的，即总能在一定时间内读取到最新值，因此不会存在读不到最新值的情况。但由于 Java 的 JIT 即时编译器的存在，会使得生成的汇编指令总是从寄存器暂存的数据获取值（甚至直接将值定义为常量），因此会有即使变量在主存更新了依然无法读取到变量的最新值的情况。</p><blockquote><i class="far fa-bell"></i> <p>&emsp;&emsp;寄存器不同于高速缓存，CPU 大多只能与寄存器交互（有些也可以和 L1 缓存交互，这里的高速缓存指的是无法直接交互的缓存），高速缓存的存在是因为 CPU 和主存交互太慢，需要缓存来提供性能。那么如果 CPU 始终从寄存器的暂存数据中读取，即使缓存是最终一致的，也会永远都不到最新值。</p></blockquote><p>而 volatile 的读基于 C++ 的 volatile 实现：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">inline</span> jint OrderAccess::load_acquire(<span class="hljs-keyword">volatile</span> jint* p) &#123; <span class="hljs-keyword">return</span> *p; &#125;</span><br></pre></td></tr></table></figure><p>它是一种编译器屏障，会禁止编译器优化，生成的加载指令不能从寄存器取值，而是总是从内存中加载（虽然由于高速缓存的存在，实际上总是从缓存加载），而因为缓存是最终一致的，因此可以保证可见性。</p><p>&emsp;&emsp;<code>volatile 如何保证写入最新值？</code></p><p>volatile 变量在写入后会插入 StoreLoad 屏障（lock 前缀的效果同 StoreLoad 屏障），即</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__asm__ volatile (&quot;lock; addl $0,0(%%rsp)&quot; : : : &quot;cc&quot;, &quot;memory&quot;);</span><br></pre></td></tr></table></figure><p>这样就保证了每次写入都会到主内存。</p><blockquote><i class="far fa-bell"></i> <ul><li><p>volatile 写之前会插入 StoreStore，防止和之前的任何写指令重排序</p></li><li><p>volatile 读之后会插入 LoadLoad，LoadStore 屏障，保证不和之后的读写指令重排序</p></li></ul><p>至于原因，可以参考之前的两个案例。实际上通过 volatile 关键字就能保证上述两个案例的并发正确性</p></blockquote><h2 id="Final小解"><a href="#Final小解" class="headerlink" title="Final小解"></a>Final小解</h2><p>JMM 同样通过内存屏障在一些情景下实现 final 的内存语义，这里也简单的讨论下</p><ul><li><p>初始读取共享对象与初始读取该共享对象的 final 成员变量之间不能重排序</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = sharedRef; </span><br><span class="line">... ; </span><br><span class="line">i = x.finalField;</span><br></pre></td></tr></table></figure><p>当存在数据依赖关系时，编译器本身不会对它们重排序。但确实有一些处理器会对这种情况进行重排序，因此特别制定了这一规则</p></li><li><p>如果在构造函数中有一条 final 字段的 store 指令，同时这个字段是一个引用，那么它将不能与构造函数外后续可以让持有这个 final 字段的对象被其他线程访问的指令重排。…代表构建方法边界</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x.finalField = v; ... ; sharedRef = x;</span><br><span class="line"></span><br><span class="line">v.afield = 1; x.finalField = v; ... ; sharedRef = x;</span><br></pre></td></tr></table></figure><p>JMM 为了满足 final 的这种特殊规则，实际上就是加了一个 StoreStore 屏障</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.finalField = v; ... ; StoreStore() sharedRef = x;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">深入理解计算机系统(第三版)</a></li><li><a href="https://en.wikipedia.org/wiki/Cache_(computing" target="_blank" rel="noopener">Cache (computing) Wiki</a>)</li><li><a href="https://www.cnblogs.com/jzssuanfa/p/7388066.html" target="_blank" rel="noopener">聊聊高并发（三十四）Java内存模型那些事（二）理解CPU快速缓存的工作原理</a></li><li><a href="http://witmax.cn/cache-writing-policies.html" target="_blank" rel="noopener">Cache写机制：Write-through与Write-back</a></li><li><a href="https://en.wikipedia.org/wiki/Write_buffer" target="_blank" rel="noopener">Write buffer Wiki</a></li><li><a href="https://stackoverflow.com/questions/33783862/why-we-use-write-buffer-in-mipscache" target="_blank" rel="noopener">why we use write buffer in mipscache?</a></li><li><a href="http://www.infoq.com/cn/articles/cache-coherency-primer" target="_blank" rel="noopener">缓存一致性（Cache Coherency）入门</a></li><li><a href="https://www.cnblogs.com/yanlong300/p/8986041.html" target="_blank" rel="noopener">CPU缓存一致性协议MESI</a></li><li><a href="https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/" target="_blank" rel="noopener">Memory Barriers Are Like Source Control Operations</a></li><li><a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt" target="_blank" rel="noopener">linux-kernel-memory-barriers</a></li><li><a href="https://www.cnblogs.com/wewill/p/8098189.html" target="_blank" rel="noopener">内存屏障保证缓存一致性</a></li><li><a href="https://tech.meituan.com/java_memory_reordering.html" target="_blank" rel="noopener">Java内存访问重排序的研究</a></li><li><a href="http://0xffffff.org/2017/02/21/40-atomic-variable-mutex-and-memory-barrier/" target="_blank" rel="noopener">聊聊原子变量、锁、内存屏障那点事</a></li><li><a href="https://www.cnblogs.com/icanth/archive/2012/06/10/2544300.html" target="_blank" rel="noopener">LINUX内核之内存屏障</a></li><li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">The JSR-133 Cookbook for Compiler Writers</a></li><li><a href="https://www.jianshu.com/p/c6f190018db1" target="_blank" rel="noopener">指令重排序</a></li><li><a href="https://stackoverflow.com/questions/26307071/does-the-c-volatile-keyword-introduce-a-memory-fence" target="_blank" rel="noopener">Does the C++ volatile keyword introduce a memory fence?</a></li><li><a href="https://juejin.im/post/5ae9b41b518825670b33e6c4" target="_blank" rel="noopener">彻底理解volatile</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;现代计算机大多数采用多核处理器或多处理器以提高性能，同时每个处理器通常存在一层或多层高速缓存，这将会更进一步加快对数据的访问。但是这也带来了新的挑战，即同一数据在不同处理器之间并不保证一致。所以为了保证数据的可见性，内存屏障应运而生。它能够刷新或使本地处理器高速缓存失效，以便查看其他处理器进行的写入的最新值或使该处理器的写入对其他处理器可见。而 Java 内存模型用于屏蔽不同硬件所带来的内存访问差异，以实现程序在不同平台能保证一致的并发效果。那么在并发环境下如何正确的使用内存屏障成为了首要问题。&lt;/p&gt;
&lt;h2 id=&quot;硬件内存架构&quot;&gt;&lt;a href=&quot;#硬件内存架构&quot; class=&quot;headerlink&quot; title=&quot;硬件内存架构&quot;&gt;&lt;/a&gt;硬件内存架构&lt;/h2&gt;&lt;p&gt;Java 内存模型是对硬件内存模型的抽象，因此理解它需要一些硬件基础知识。这里主要介绍 &lt;strong&gt;处理器的存储器结构&lt;/strong&gt; 和 &lt;strong&gt;处理器的高速缓存与缓存一致性&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;随机访问存储器（RAM）&quot;&gt;&lt;a href=&quot;#随机访问存储器（RAM）&quot; class=&quot;headerlink&quot; title=&quot;随机访问存储器（RAM）&quot;&gt;&lt;/a&gt;随机访问存储器（RAM）&lt;/h3&gt;&lt;p&gt;随机访问存储器（RAM），是用于和 CPU 交换数据的内部存储器。根据存储单元的工作原理不同可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态的存储器（DRAM）&lt;/li&gt;
&lt;li&gt;静态的存储器（SRAM）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SRAM 比 DRAM 更快，但也更贵，因此 SRAM 主要作为高速缓存存储器（Cache，如 CPU 的 L1，L2），而 DRAM 则作为计算机主存。而我们常说的内存指的就是是计算机的主内存 DRAM。&lt;/p&gt;
    
    </summary>
    
      <category term="JUC" scheme="http://yoursite.com/categories/JUC/"/>
    
    
      <category term="可见性" scheme="http://yoursite.com/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
      <category term="内存屏障" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
</feed>
